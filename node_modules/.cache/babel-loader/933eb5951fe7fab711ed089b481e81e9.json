{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must have required property '${missingProperty}'`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{missingProperty: ${missingProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      schemaCode,\n      data,\n      $data,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    if (!$data && schema.length === 0) return;\n    const useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties;\n      const {\n        definedProperties\n      } = cxt.it;\n\n      for (const requiredKey of schema) {\n        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n          (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n        }\n      }\n    }\n\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        for (const prop of schema) {\n          (0, code_1.checkReportMissingProp)(cxt, prop);\n        }\n      }\n    }\n\n    function exitOnErrorMode() {\n      const missing = gen.let(\"missing\");\n\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, prop => {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n      });\n    }\n\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, () => {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), () => {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","missingProperty","def","keyword","type","schemaType","$data","code","cxt","gen","schema","schemaCode","data","it","opts","length","useLoop","loopRequired","allErrors","allErrorsMode","exitOnErrorMode","strictRequired","props","parentSchema","properties","definedProperties","requiredKey","undefined","has","schemaPath","schemaEnv","baseId","errSchemaPath","msg","block$data","codegen_1","loopAllRequired","prop","missing","let","valid","loopUntilMissing","ok","if","else","forOf","setParams","ownProperties","assign","break","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/validation/required.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}