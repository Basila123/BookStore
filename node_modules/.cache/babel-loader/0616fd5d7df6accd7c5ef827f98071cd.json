{"ast":null,"code":"'use strict';\n\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\n\nconst {\n  pathElems\n} = require('./_collections.js');\n\nconst {\n  path2js,\n  js2path\n} = require('./_path.js');\n\nconst {\n  applyTransforms\n} = require('./_applyTransforms.js');\n\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools');\n\nexports.name = 'convertPathData';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5,\n    // coefficient of rounding error\n    tolerance: 0.5 // percentage of radius\n\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true,\n  noSpaceAfterFlags: false,\n  // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n  forceAbsolutePath: false\n};\nlet roundData;\nlet precision;\nlet error;\nlet arcThreshold;\nlet arcTolerance;\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\nexports.fn = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = params.floatPrecision;\n          error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n\n          if (params.makeArcs) {\n            arcThreshold = params.makeArcs.threshold;\n            arcTolerance = params.makeArcs.tolerance;\n          }\n\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n          const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === 'dynamic' || computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap = computedStyle['stroke-linecap'] && (computedStyle['stroke-linecap'].type === 'dynamic' || computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n          var data = path2js(node); // TODO: get rid of functions returns\n\n          if (data.length) {\n            if (params.applyTransforms) {\n              applyTransforms(node, data, params);\n            }\n\n            convertToRelative(data);\n            data = filters(data, params, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid\n            });\n\n            if (params.utilizeAbsolute) {\n              data = convertToMixed(data, params);\n            }\n\n            js2path(node, data, params);\n          }\n        }\n      }\n    }\n  };\n};\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nconst convertToRelative = pathData => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let {\n      command,\n      args\n    } = pathItem; // moveto (x y)\n\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n\n      args[0] -= cursor[0];\n      args[1] -= cursor[1]; // update start and cursor\n\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    } // lineto (x y)\n\n\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    } // horizontal lineto (x)\n\n\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    } // vertical lineto (y)\n\n\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    } // curveto (x1 y1 x2 y2 x y)\n\n\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    } // smooth curveto (x2 y2 x y)\n\n\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    } // quadratic Bézier curveto (x1 y1 x y)\n\n\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    } // smooth quadratic Bézier curveto (x y)\n\n\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    } // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n\n\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    } // closepath\n\n\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args; // store absolute coordinates for later use\n    // base should preserve reference from other element\n\n    pathItem.base = prevCoords;\n    pathItem.coords = [cursor[0], cursor[1]];\n    prevCoords = pathItem.coords;\n  }\n\n  return pathData;\n};\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction filters(path, params, _ref) {\n  let {\n    maybeHasStrokeAndLinecap,\n    hasMarkerMid\n  } = _ref;\n  var stringify = data2Path.bind(null, params),\n      relSubpoint = [0, 0],\n      pathBase = [0, 0],\n      prev = {};\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n          circle;\n\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        if (command === 'c' || command === 's') {\n          var pdata = prev.args,\n              n = pdata.length; // (-x, -y) of the prev tangent point relative to the current point\n\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      } // convert curves to arcs if possible\n\n\n      if (params.makeArcs && (command == 'c' || command == 's') && isConvex(sdata) && (circle = findCircle(sdata))) {\n        var r = roundData([circle.radius])[0],\n            angle = findArcAngle(sdata, circle),\n            sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n            arc = {\n          command: 'a',\n          args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n          coords: item.coords.slice(),\n          base: item.base\n        },\n            output = [arc],\n            // relative coordinates to adjust the found circle\n        relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n            relCircle = {\n          center: relCenter,\n          radius: circle.radius\n        },\n            arcCurves = [item],\n            hasPrev = 0,\n            suffix = '',\n            nextLonghand;\n\n        if (prev.command == 'c' && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [prevData[4] + circle.center[0], prevData[5] + circle.center[1]],\n            radius: circle.radius\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        } // check if next curves are fitting the arc\n\n\n        for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.command);) {\n          var nextData = next.args;\n\n          if (next.command == 's') {\n            nextLonghand = makeLonghand({\n              command: 's',\n              args: next.args.slice()\n            }, path[j - 1].args);\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [arc.base[0] + arc.args[5], arc.base[1] + arc.args[6]];\n              arc = {\n                command: 'a',\n                args: [r, r, 0, 0, sweep, next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],\n                coords: next.coords,\n                base: arc.coords\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.args);\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            prev.command = 'a';\n            prev.args = prevArc.args;\n            item.base = prev.coords = prevArc.coords;\n          }\n\n          arc = output.shift();\n\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n          }\n\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          item.coords = arc.coords;\n        }\n      } // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n\n\n      if (precision !== false) {\n        if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n          for (var i = data.length; i--;) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n\n        roundData(data);\n        if (command == 'h') relSubpoint[0] += data[0];else if (command == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      } // convert straight curves into lines segments\n\n\n      if (params.straightCurves) {\n        if (command === 'c' && isCurveStraightLine(data) || command === 's' && isCurveStraightLine(sdata)) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 't' && prev.command !== 'q' && prev.command !== 't') {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      } // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n\n\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      } // collapse repeated commands\n      // h 20 h 30 -> h 50\n\n\n      if (params.collapseRepeated && hasMarkerMid === false && (command === 'm' || command === 'h' || command === 'v') && prev.command && command == prev.command.toLowerCase() && (command != 'h' && command != 'v' || prev.args[0] >= 0 == data[0] >= 0)) {\n        prev.args[0] += data[0];\n\n        if (command != 'h' && command != 'v') {\n          prev.args[1] += data[1];\n        }\n\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      } // convert curves into smooth shorthands\n\n\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (prev.command === 'c' && data[0] === -(prev.args[2] - prev.args[4]) && data[1] === -(prev.args[3] - prev.args[5])) {\n            command = 's';\n            data = data.slice(2);\n          } // s + c → s + s\n          else if (prev.command === 's' && data[0] === -(prev.args[0] - prev.args[2]) && data[1] === -(prev.args[1] - prev.args[3])) {\n            command = 's';\n            data = data.slice(2);\n          } // [^cs] + c → [^cs] + s\n          else if (prev.command !== 'c' && prev.command !== 's' && data[0] === 0 && data[1] === 0) {\n            command = 's';\n            data = data.slice(2);\n          }\n        } // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (prev.command === 'q' && data[0] === prev.args[2] - prev.args[0] && data[1] === prev.args[3] - prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          } // t + q → t + t\n          else if (prev.command === 't' && data[2] === prev.args[0] && data[3] === prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      } // remove useless non-first path segments\n\n\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ((command === 'l' || command === 'h' || command === 'v' || command === 'q' || command === 't' || command === 'c' || command === 's') && data.every(function (i) {\n          return i === 0;\n        })) {\n          path[index] = prev;\n          return false;\n        } // a 25,25 -30 0,1 0,0\n\n\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.command = command;\n      item.args = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n  return path;\n}\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n\n    var command = item.command,\n        data = item.args,\n        adata = data.slice();\n\n    if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n      for (var i = adata.length; i--;) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n        relativeDataStr = cleanupOutData(data, params); // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n\n    if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))) {\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n\n    prev = item;\n    return true;\n  });\n  return path;\n}\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction isConvex(data) {\n  var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n  return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];\n}\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\n\n\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3],\n      // y1 - y2\n  b1 = coords[2] - coords[0],\n      // x2 - x1\n  c1 = coords[0] * coords[3] - coords[2] * coords[1],\n      // x1 * y2 - x2 * y1\n  // Next line equation parameters\n  a2 = coords[5] - coords[7],\n      // y1 - y2\n  b2 = coords[6] - coords[4],\n      // x2 - x1\n  c2 = coords[4] * coords[7] - coords[5] * coords[6],\n      // x1 * y2 - x2 * y1\n  denom = a1 * b2 - a2 * b1;\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n\n  if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {\n    return cross;\n  }\n}\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0;) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n}\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction round(data) {\n  for (var i = data.length; i-- > 0;) {\n    data[i] = Math.round(data[i]);\n  }\n\n  return data;\n}\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n      a = -data[i + 1],\n      // y1 − y2 (y1 = 0)\n  b = data[i],\n      // x2 − x1 (x1 = 0)\n  d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) return false;\n  }\n\n  return true;\n}\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n\n    case 't':\n      item.command = 'q';\n      break;\n  }\n\n  item.args.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n  return item;\n}\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n      cubT = sqrT * t,\n      mt = 1 - t,\n      sqrMt = mt * mt;\n  return [3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4], 3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]];\n}\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n      m1 = [midPoint[0] / 2, midPoint[1] / 2],\n      m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n      center = getIntersection([m1[0], m1[1], m1[0] + m1[1], m1[1] - m1[0], m2[0], m2[1], m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])]),\n      radius = center && getDistance([0, 0], center),\n      tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n  if (center && radius < 1e15 && [1 / 4, 3 / 4].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n  })) return {\n    center: center,\n    radius: radius\n  };\n}\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n  });\n}\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius\n  });\n}\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n      y1 = -relCircle.center[1],\n      x2 = curve[4] - relCircle.center[0],\n      y2 = curve[5] - relCircle.center[1];\n  return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));\n}\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n\n    return pathString + item.command + strData;\n  }, '');\n}","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/convertPathData.js"],"names":["collectStylesheet","computeStyle","require","pathElems","path2js","js2path","applyTransforms","cleanupOutData","exports","name","type","active","description","params","applyTransformsStroked","makeArcs","threshold","tolerance","straightCurves","lineShorthands","curveSmoothShorthands","floatPrecision","transformPrecision","removeUseless","collapseRepeated","utilizeAbsolute","leadingZero","negativeExtraSpace","noSpaceAfterFlags","forceAbsolutePath","roundData","precision","error","arcThreshold","arcTolerance","fn","root","stylesheet","element","enter","node","includes","attributes","d","computedStyle","Math","pow","toFixed","strongRound","round","hasMarkerMid","maybeHasStroke","stroke","value","maybeHasLinecap","maybeHasStrokeAndLinecap","data","length","convertToRelative","filters","convertToMixed","pathData","start","cursor","prevCoords","i","pathItem","command","args","base","coords","path","stringify","data2Path","bind","relSubpoint","pathBase","prev","filter","item","index","next","sdata","circle","concat","pdata","n","isConvex","findCircle","r","radius","angle","findArcAngle","sweep","arc","slice","output","relCenter","center","relCircle","arcCurves","hasPrev","suffix","nextLonghand","isArcPrev","unshift","prevData","prevAngle","PI","j","indexOf","nextData","makeLonghand","isArc","push","prevArc","shift","splice","apply","isCurveStraightLine","pop","toLowerCase","every","adata","absoluteDataStr","relativeDataStr","charCodeAt","test","toUpperCase","getIntersection","a1","b1","c1","a2","b2","c2","denom","cross","isNaN","isFinite","rounded","abs","a","b","sqrt","getDistance","point1","point2","hypot","getCubicBezierPoint","curve","t","sqrT","cubT","mt","sqrMt","midPoint","m1","m2","min","point","x1","y1","x2","y2","acos","reduce","pathString","strData"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA,iBAAF;AAAqBC,EAAAA;AAArB,IAAsCC,OAAO,CAAC,iBAAD,CAAnD;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAgBD,OAAO,CAAC,mBAAD,CAA7B;;AACA,MAAM;AAAEE,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAuBH,OAAO,CAAC,YAAD,CAApC;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAsBJ,OAAO,CAAC,uBAAD,CAAnC;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAqBL,OAAO,CAAC,mBAAD,CAAlC;;AAEAM,OAAO,CAACC,IAAR,GAAe,iBAAf;AACAD,OAAO,CAACE,IAAR,GAAe,SAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,IAAjB;AACAH,OAAO,CAACI,WAAR,GACE,sEADF;AAGAJ,OAAO,CAACK,MAAR,GAAiB;AACfP,EAAAA,eAAe,EAAE,IADF;AAEfQ,EAAAA,sBAAsB,EAAE,IAFT;AAGfC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,SAAS,EAAE,GADH;AACQ;AAChBC,IAAAA,SAAS,EAAE,GAFH,CAEQ;;AAFR,GAHK;AAOfC,EAAAA,cAAc,EAAE,IAPD;AAQfC,EAAAA,cAAc,EAAE,IARD;AASfC,EAAAA,qBAAqB,EAAE,IATR;AAUfC,EAAAA,cAAc,EAAE,CAVD;AAWfC,EAAAA,kBAAkB,EAAE,CAXL;AAYfC,EAAAA,aAAa,EAAE,IAZA;AAafC,EAAAA,gBAAgB,EAAE,IAbH;AAcfC,EAAAA,eAAe,EAAE,IAdF;AAefC,EAAAA,WAAW,EAAE,IAfE;AAgBfC,EAAAA,kBAAkB,EAAE,IAhBL;AAiBfC,EAAAA,iBAAiB,EAAE,KAjBJ;AAiBW;AAC1BC,EAAAA,iBAAiB,EAAE;AAlBJ,CAAjB;AAqBA,IAAIC,SAAJ;AACA,IAAIC,SAAJ;AACA,IAAIC,KAAJ;AACA,IAAIC,YAAJ;AACA,IAAIC,YAAJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA1B,OAAO,CAAC2B,EAAR,GAAa,CAACC,IAAD,EAAOvB,MAAP,KAAkB;AAC7B,QAAMwB,UAAU,GAAGrC,iBAAiB,CAACoC,IAAD,CAApC;AACA,SAAO;AACLE,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAGC,IAAD,IAAU;AACf,YAAIrC,SAAS,CAACsC,QAAV,CAAmBD,IAAI,CAAC/B,IAAxB,KAAiC+B,IAAI,CAACE,UAAL,CAAgBC,CAAhB,IAAqB,IAA1D,EAAgE;AAC9D,gBAAMC,aAAa,GAAG3C,YAAY,CAACoC,UAAD,EAAaG,IAAb,CAAlC;AACAT,UAAAA,SAAS,GAAGlB,MAAM,CAACQ,cAAnB;AACAW,UAAAA,KAAK,GACHD,SAAS,KAAK,KAAd,GACI,CAACc,IAAI,CAACC,GAAL,CAAS,GAAT,EAAcf,SAAd,EAAyBgB,OAAzB,CAAiChB,SAAjC,CADL,GAEI,IAHN;AAIAD,UAAAA,SAAS,GAAGC,SAAS,GAAG,CAAZ,IAAiBA,SAAS,GAAG,EAA7B,GAAkCiB,WAAlC,GAAgDC,KAA5D;;AACA,cAAIpC,MAAM,CAACE,QAAX,EAAqB;AACnBkB,YAAAA,YAAY,GAAGpB,MAAM,CAACE,QAAP,CAAgBC,SAA/B;AACAkB,YAAAA,YAAY,GAAGrB,MAAM,CAACE,QAAP,CAAgBE,SAA/B;AACD;;AACD,gBAAMiC,YAAY,GAAGN,aAAa,CAAC,YAAD,CAAb,IAA+B,IAApD;AAEA,gBAAMO,cAAc,GAClBP,aAAa,CAACQ,MAAd,KACCR,aAAa,CAACQ,MAAd,CAAqB1C,IAArB,KAA8B,SAA9B,IACCkC,aAAa,CAACQ,MAAd,CAAqBC,KAArB,KAA+B,MAFjC,CADF;AAIA,gBAAMC,eAAe,GACnBV,aAAa,CAAC,gBAAD,CAAb,KACCA,aAAa,CAAC,gBAAD,CAAb,CAAgClC,IAAhC,KAAyC,SAAzC,IACCkC,aAAa,CAAC,gBAAD,CAAb,CAAgCS,KAAhC,KAA0C,MAF5C,CADF;AAIA,gBAAME,wBAAwB,GAAGJ,cAAc,IAAIG,eAAnD;AAEA,cAAIE,IAAI,GAAGpD,OAAO,CAACoC,IAAD,CAAlB,CAxB8D,CA0B9D;;AACA,cAAIgB,IAAI,CAACC,MAAT,EAAiB;AACf,gBAAI5C,MAAM,CAACP,eAAX,EAA4B;AAC1BA,cAAAA,eAAe,CAACkC,IAAD,EAAOgB,IAAP,EAAa3C,MAAb,CAAf;AACD;;AAED6C,YAAAA,iBAAiB,CAACF,IAAD,CAAjB;AAEAA,YAAAA,IAAI,GAAGG,OAAO,CAACH,IAAD,EAAO3C,MAAP,EAAe;AAC3B0C,cAAAA,wBAD2B;AAE3BL,cAAAA;AAF2B,aAAf,CAAd;;AAKA,gBAAIrC,MAAM,CAACY,eAAX,EAA4B;AAC1B+B,cAAAA,IAAI,GAAGI,cAAc,CAACJ,IAAD,EAAO3C,MAAP,CAArB;AACD;;AAEDR,YAAAA,OAAO,CAACmC,IAAD,EAAOgB,IAAP,EAAa3C,MAAb,CAAP;AACD;AACF;AACF;AAhDM;AADJ,GAAP;AAoDD,CAtDD;AAwDA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM6C,iBAAiB,GAAIG,QAAD,IAAc;AACtC,MAAIC,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAZ;AACA,MAAIC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAb;AACA,MAAIC,UAAU,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAjB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACJ,MAA7B,EAAqCQ,CAAC,IAAI,CAA1C,EAA6C;AAC3C,UAAMC,QAAQ,GAAGL,QAAQ,CAACI,CAAD,CAAzB;AACA,QAAI;AAAEE,MAAAA,OAAF;AAAWC,MAAAA;AAAX,QAAoBF,QAAxB,CAF2C,CAI3C;;AACA,QAAIC,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAN,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB;AACAD,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB;AACD;;AACD,QAAII,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACA;AACA,UAAIF,CAAC,KAAK,CAAV,EAAa;AACXE,QAAAA,OAAO,GAAG,GAAV;AACD;;AACDC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB,CAPmB,CAQnB;;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAN,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB;AACAD,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB;AACD,KAzB0C,CA2B3C;;;AACA,QAAII,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KAvC0C,CAyC3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KAlD0C,CAoD3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA7D0C,CA+D3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA/E0C,CAiF3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA/F0C,CAiG3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA/G0C,CAiH3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA7H0C,CA+H3C;;;AACA,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnBJ,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD;;AACD,QAAID,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACAA,MAAAA,OAAO,GAAG,GAAV;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAK,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWL,MAAM,CAAC,CAAD,CAAjB;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACAL,MAAAA,MAAM,CAAC,CAAD,CAAN,IAAaK,IAAI,CAAC,CAAD,CAAjB;AACD,KA3I0C,CA6I3C;;;AACA,QAAID,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC;AACAJ,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAAjB;AACAC,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAAjB;AACD;;AAEDI,IAAAA,QAAQ,CAACC,OAAT,GAAmBA,OAAnB;AACAD,IAAAA,QAAQ,CAACE,IAAT,GAAgBA,IAAhB,CArJ2C,CAsJ3C;AACA;;AACAF,IAAAA,QAAQ,CAACG,IAAT,GAAgBL,UAAhB;AACAE,IAAAA,QAAQ,CAACI,MAAT,GAAkB,CAACP,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB,CAAlB;AACAC,IAAAA,UAAU,GAAGE,QAAQ,CAACI,MAAtB;AACD;;AAED,SAAOT,QAAP;AACD,CAnKD;AAqKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,OAAT,CAAiBY,IAAjB,EAAuB1D,MAAvB,QAA2E;AAAA,MAA5C;AAAE0C,IAAAA,wBAAF;AAA4BL,IAAAA;AAA5B,GAA4C;AACzE,MAAIsB,SAAS,GAAGC,SAAS,CAACC,IAAV,CAAe,IAAf,EAAqB7D,MAArB,CAAhB;AAAA,MACE8D,WAAW,GAAG,CAAC,CAAD,EAAI,CAAJ,CADhB;AAAA,MAEEC,QAAQ,GAAG,CAAC,CAAD,EAAI,CAAJ,CAFb;AAAA,MAGEC,IAAI,GAAG,EAHT;AAKAN,EAAAA,IAAI,GAAGA,IAAI,CAACO,MAAL,CAAY,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBT,IAAvB,EAA6B;AAC9C,QAAIJ,OAAO,GAAGY,IAAI,CAACZ,OAAnB;AACA,QAAIX,IAAI,GAAGuB,IAAI,CAACX,IAAhB;AACA,QAAIa,IAAI,GAAGV,IAAI,CAACS,KAAK,GAAG,CAAT,CAAf;;AAEA,QAAIb,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC,UAAIe,KAAK,GAAG1B,IAAZ;AAAA,UACE2B,MADF;;AAGA,UAAIhB,OAAO,KAAK,GAAhB,EAAqB;AACnBe,QAAAA,KAAK,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAOE,MAAP,CAAc5B,IAAd,CAAR;;AAEA,YAAIW,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC,cAAIkB,KAAK,GAAGR,IAAI,CAACT,IAAjB;AAAA,cACEkB,CAAC,GAAGD,KAAK,CAAC5B,MADZ,CADsC,CAItC;;AACAyB,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWG,KAAK,CAACC,CAAC,GAAG,CAAL,CAAL,GAAeD,KAAK,CAACC,CAAC,GAAG,CAAL,CAA/B;AACAJ,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWG,KAAK,CAACC,CAAC,GAAG,CAAL,CAAL,GAAeD,KAAK,CAACC,CAAC,GAAG,CAAL,CAA/B;AACD;AACF,OAfqC,CAiBtC;;;AACA,UACEzE,MAAM,CAACE,QAAP,KACCoD,OAAO,IAAI,GAAX,IAAkBA,OAAO,IAAI,GAD9B,KAEAoB,QAAQ,CAACL,KAAD,CAFR,KAGCC,MAAM,GAAGK,UAAU,CAACN,KAAD,CAHpB,CADF,EAKE;AACA,YAAIO,CAAC,GAAG3D,SAAS,CAAC,CAACqD,MAAM,CAACO,MAAR,CAAD,CAAT,CAA2B,CAA3B,CAAR;AAAA,YACEC,KAAK,GAAGC,YAAY,CAACV,KAAD,EAAQC,MAAR,CADtB;AAAA,YAEEU,KAAK,GAAGX,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAhB,GAAsBA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAtC,GAA4C,CAA5C,GAAgD,CAAhD,GAAoD,CAF9D;AAAA,YAGEY,GAAG,GAAG;AACJ3B,UAAAA,OAAO,EAAE,GADL;AAEJC,UAAAA,IAAI,EAAE,CAACqB,CAAD,EAAIA,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAaI,KAAb,EAAoBX,KAAK,CAAC,CAAD,CAAzB,EAA8BA,KAAK,CAAC,CAAD,CAAnC,CAFF;AAGJZ,UAAAA,MAAM,EAAES,IAAI,CAACT,MAAL,CAAYyB,KAAZ,EAHJ;AAIJ1B,UAAAA,IAAI,EAAEU,IAAI,CAACV;AAJP,SAHR;AAAA,YASE2B,MAAM,GAAG,CAACF,GAAD,CATX;AAAA,YAUE;AACAG,QAAAA,SAAS,GAAG,CACVd,MAAM,CAACe,MAAP,CAAc,CAAd,IAAmBhB,KAAK,CAAC,CAAD,CADd,EAEVC,MAAM,CAACe,MAAP,CAAc,CAAd,IAAmBhB,KAAK,CAAC,CAAD,CAFd,CAXd;AAAA,YAeEiB,SAAS,GAAG;AAAED,UAAAA,MAAM,EAAED,SAAV;AAAqBP,UAAAA,MAAM,EAAEP,MAAM,CAACO;AAApC,SAfd;AAAA,YAgBEU,SAAS,GAAG,CAACrB,IAAD,CAhBd;AAAA,YAiBEsB,OAAO,GAAG,CAjBZ;AAAA,YAkBEC,MAAM,GAAG,EAlBX;AAAA,YAmBEC,YAnBF;;AAqBA,YACG1B,IAAI,CAACV,OAAL,IAAgB,GAAhB,IACCoB,QAAQ,CAACV,IAAI,CAACT,IAAN,CADT,IAECoC,SAAS,CAAC3B,IAAI,CAACT,IAAN,EAAYe,MAAZ,CAFX,IAGCN,IAAI,CAACV,OAAL,IAAgB,GAAhB,IAAuBU,IAAI,CAACK,KAA5B,IAAqCsB,SAAS,CAAC3B,IAAI,CAACK,KAAN,EAAaC,MAAb,CAJjD,EAKE;AACAiB,UAAAA,SAAS,CAACK,OAAV,CAAkB5B,IAAlB;AACAiB,UAAAA,GAAG,CAACzB,IAAJ,GAAWQ,IAAI,CAACR,IAAhB;AACAyB,UAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc0B,GAAG,CAACxB,MAAJ,CAAW,CAAX,IAAgBwB,GAAG,CAACzB,IAAJ,CAAS,CAAT,CAA9B;AACAyB,UAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc0B,GAAG,CAACxB,MAAJ,CAAW,CAAX,IAAgBwB,GAAG,CAACzB,IAAJ,CAAS,CAAT,CAA9B;AACA,cAAIqC,QAAQ,GAAG7B,IAAI,CAACV,OAAL,IAAgB,GAAhB,GAAsBU,IAAI,CAACK,KAA3B,GAAmCL,IAAI,CAACT,IAAvD;AACA,cAAIuC,SAAS,GAAGf,YAAY,CAACc,QAAD,EAAW;AACrCR,YAAAA,MAAM,EAAE,CACNQ,QAAQ,CAAC,CAAD,CAAR,GAAcvB,MAAM,CAACe,MAAP,CAAc,CAAd,CADR,EAENQ,QAAQ,CAAC,CAAD,CAAR,GAAcvB,MAAM,CAACe,MAAP,CAAc,CAAd,CAFR,CAD6B;AAKrCR,YAAAA,MAAM,EAAEP,MAAM,CAACO;AALsB,WAAX,CAA5B;AAOAC,UAAAA,KAAK,IAAIgB,SAAT;AACA,cAAIhB,KAAK,GAAG9C,IAAI,CAAC+D,EAAjB,EAAqBd,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc,CAAd;AACrBiC,UAAAA,OAAO,GAAG,CAAV;AACD,SA3CD,CA6CA;;;AACA,aACE,IAAIQ,CAAC,GAAG7B,KADV,EAEE,CAACC,IAAI,GAAGV,IAAI,CAAC,EAAEsC,CAAH,CAAZ,KAAsB,CAAC,KAAKC,OAAL,CAAa7B,IAAI,CAACd,OAAlB,CAFzB,GAIE;AACA,cAAI4C,QAAQ,GAAG9B,IAAI,CAACb,IAApB;;AACA,cAAIa,IAAI,CAACd,OAAL,IAAgB,GAApB,EAAyB;AACvBoC,YAAAA,YAAY,GAAGS,YAAY,CACzB;AAAE7C,cAAAA,OAAO,EAAE,GAAX;AAAgBC,cAAAA,IAAI,EAAEa,IAAI,CAACb,IAAL,CAAU2B,KAAV;AAAtB,aADyB,EAEzBxB,IAAI,CAACsC,CAAC,GAAG,CAAL,CAAJ,CAAYzC,IAFa,CAA3B;AAIA2C,YAAAA,QAAQ,GAAGR,YAAY,CAACnC,IAAxB;AACAmC,YAAAA,YAAY,CAACnC,IAAb,GAAoB2C,QAAQ,CAAChB,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAApB;AACAO,YAAAA,MAAM,GAAG9B,SAAS,CAAC,CAAC+B,YAAD,CAAD,CAAlB;AACD;;AACD,cAAIhB,QAAQ,CAACwB,QAAD,CAAR,IAAsBE,KAAK,CAACF,QAAD,EAAWZ,SAAX,CAA/B,EAAsD;AACpDR,YAAAA,KAAK,IAAIC,YAAY,CAACmB,QAAD,EAAWZ,SAAX,CAArB;AACA,gBAAIR,KAAK,GAAG,IAAI9C,IAAI,CAAC+D,EAAjB,GAAsB,IAA1B,EAAgC,MAFoB,CAEb;;AACvC,gBAAIjB,KAAK,GAAG9C,IAAI,CAAC+D,EAAjB,EAAqBd,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc,CAAd;AACrBgC,YAAAA,SAAS,CAACc,IAAV,CAAejC,IAAf;;AACA,gBAAI,IAAIpC,IAAI,CAAC+D,EAAT,GAAcjB,KAAd,GAAsB,IAA1B,EAAgC;AAC9B;AACAG,cAAAA,GAAG,CAACxB,MAAJ,GAAaW,IAAI,CAACX,MAAlB;AACAwB,cAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc0B,GAAG,CAACxB,MAAJ,CAAW,CAAX,IAAgBwB,GAAG,CAACzB,IAAJ,CAAS,CAAT,CAA9B;AACAyB,cAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc0B,GAAG,CAACxB,MAAJ,CAAW,CAAX,IAAgBwB,GAAG,CAACzB,IAAJ,CAAS,CAAT,CAA9B;AACD,aALD,MAKO;AACL;AACAyB,cAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc,KAAK+B,SAAS,CAACD,MAAV,CAAiB,CAAjB,IAAsBa,QAAQ,CAAC,CAAD,CAAnC,CAAd;AACAjB,cAAAA,GAAG,CAAC1B,IAAJ,CAAS,CAAT,IAAc,KAAK+B,SAAS,CAACD,MAAV,CAAiB,CAAjB,IAAsBa,QAAQ,CAAC,CAAD,CAAnC,CAAd;AACAjB,cAAAA,GAAG,CAACxB,MAAJ,GAAa,CACXwB,GAAG,CAACzB,IAAJ,CAAS,CAAT,IAAcyB,GAAG,CAAC1B,IAAJ,CAAS,CAAT,CADH,EAEX0B,GAAG,CAACzB,IAAJ,CAAS,CAAT,IAAcyB,GAAG,CAAC1B,IAAJ,CAAS,CAAT,CAFH,CAAb;AAIA0B,cAAAA,GAAG,GAAG;AACJ3B,gBAAAA,OAAO,EAAE,GADL;AAEJC,gBAAAA,IAAI,EAAE,CACJqB,CADI,EAEJA,CAFI,EAGJ,CAHI,EAIJ,CAJI,EAKJI,KALI,EAMJZ,IAAI,CAACX,MAAL,CAAY,CAAZ,IAAiBwB,GAAG,CAACxB,MAAJ,CAAW,CAAX,CANb,EAOJW,IAAI,CAACX,MAAL,CAAY,CAAZ,IAAiBwB,GAAG,CAACxB,MAAJ,CAAW,CAAX,CAPb,CAFF;AAWJA,gBAAAA,MAAM,EAAEW,IAAI,CAACX,MAXT;AAYJD,gBAAAA,IAAI,EAAEyB,GAAG,CAACxB;AAZN,eAAN;AAcA0B,cAAAA,MAAM,CAACkB,IAAP,CAAYpB,GAAZ;AACAe,cAAAA,CAAC;AACD;AACD;;AACDZ,YAAAA,SAAS,CAAC,CAAD,CAAT,IAAgBc,QAAQ,CAAC,CAAD,CAAxB;AACAd,YAAAA,SAAS,CAAC,CAAD,CAAT,IAAgBc,QAAQ,CAAC,CAAD,CAAxB;AACD,WAtCD,MAsCO;AACR;;AAED,YAAI,CAACvC,SAAS,CAACwB,MAAD,CAAT,GAAoBM,MAArB,EAA6B7C,MAA7B,GAAsCe,SAAS,CAAC4B,SAAD,CAAT,CAAqB3C,MAA/D,EAAuE;AACrE,cAAIc,IAAI,CAACsC,CAAD,CAAJ,IAAWtC,IAAI,CAACsC,CAAD,CAAJ,CAAQ1C,OAAR,IAAmB,GAAlC,EAAuC;AACrC6C,YAAAA,YAAY,CAACzC,IAAI,CAACsC,CAAD,CAAL,EAAUtC,IAAI,CAACsC,CAAC,GAAG,CAAL,CAAJ,CAAYzC,IAAtB,CAAZ;AACD;;AACD,cAAIiC,OAAJ,EAAa;AACX,gBAAIc,OAAO,GAAGnB,MAAM,CAACoB,KAAP,EAAd;AACAtF,YAAAA,SAAS,CAACqF,OAAO,CAAC/C,IAAT,CAAT;AACAO,YAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBwC,OAAO,CAAC/C,IAAR,CAAa,CAAb,IAAkBS,IAAI,CAACT,IAAL,CAAUS,IAAI,CAACT,IAAL,CAAUX,MAAV,GAAmB,CAA7B,CAApC;AACAkB,YAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBwC,OAAO,CAAC/C,IAAR,CAAa,CAAb,IAAkBS,IAAI,CAACT,IAAL,CAAUS,IAAI,CAACT,IAAL,CAAUX,MAAV,GAAmB,CAA7B,CAApC;AACAoB,YAAAA,IAAI,CAACV,OAAL,GAAe,GAAf;AACAU,YAAAA,IAAI,CAACT,IAAL,GAAY+C,OAAO,CAAC/C,IAApB;AACAW,YAAAA,IAAI,CAACV,IAAL,GAAYQ,IAAI,CAACP,MAAL,GAAc6C,OAAO,CAAC7C,MAAlC;AACD;;AACDwB,UAAAA,GAAG,GAAGE,MAAM,CAACoB,KAAP,EAAN;;AACA,cAAIhB,SAAS,CAAC3C,MAAV,IAAoB,CAAxB,EAA2B;AACzBsB,YAAAA,IAAI,CAACG,KAAL,GAAaA,KAAK,CAACa,KAAN,EAAb,CADyB,CACG;AAC7B,WAFD,MAEO,IAAIK,SAAS,CAAC3C,MAAV,GAAmB,CAAnB,GAAuB4C,OAAvB,GAAiC,CAArC,EAAwC;AAC7C;AACA9B,YAAAA,IAAI,CAAC8C,MAAL,CAAYC,KAAZ,CACE/C,IADF,EAEE,CAACS,KAAK,GAAG,CAAT,EAAYoB,SAAS,CAAC3C,MAAV,GAAmB,CAAnB,GAAuB4C,OAAnC,EAA4CjB,MAA5C,CAAmDY,MAAnD,CAFF;AAID;;AACD,cAAI,CAACF,GAAL,EAAU,OAAO,KAAP;AACV3B,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,GAAGsC,GAAG,CAAC1B,IAAX;AACAW,UAAAA,IAAI,CAACT,MAAL,GAAcwB,GAAG,CAACxB,MAAlB;AACD;AACF,OAzJqC,CA2JtC;AACA;AACA;;;AACA,UAAIvC,SAAS,KAAK,KAAlB,EAAyB;AACvB,YACEoC,OAAO,KAAK,GAAZ,IACAA,OAAO,KAAK,GADZ,IAEAA,OAAO,KAAK,GAFZ,IAGAA,OAAO,KAAK,GAHZ,IAIAA,OAAO,KAAK,GAJZ,IAKAA,OAAO,KAAK,GANd,EAOE;AACA,eAAK,IAAIF,CAAC,GAAGT,IAAI,CAACC,MAAlB,EAA0BQ,CAAC,EAA3B,GAAiC;AAC/BT,YAAAA,IAAI,CAACS,CAAD,CAAJ,IAAWc,IAAI,CAACV,IAAL,CAAUJ,CAAC,GAAG,CAAd,IAAmBU,WAAW,CAACV,CAAC,GAAG,CAAL,CAAzC;AACD;AACF,SAXD,MAWO,IAAIE,OAAO,IAAI,GAAf,EAAoB;AACzBX,UAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWuB,IAAI,CAACV,IAAL,CAAU,CAAV,IAAeM,WAAW,CAAC,CAAD,CAArC;AACD,SAFM,MAEA,IAAIR,OAAO,IAAI,GAAf,EAAoB;AACzBX,UAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWuB,IAAI,CAACV,IAAL,CAAU,CAAV,IAAeM,WAAW,CAAC,CAAD,CAArC;AACD,SAFM,MAEA,IAAIR,OAAO,IAAI,GAAf,EAAoB;AACzBX,UAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWuB,IAAI,CAACV,IAAL,CAAU,CAAV,IAAeM,WAAW,CAAC,CAAD,CAArC;AACAnB,UAAAA,IAAI,CAAC,CAAD,CAAJ,IAAWuB,IAAI,CAACV,IAAL,CAAU,CAAV,IAAeM,WAAW,CAAC,CAAD,CAArC;AACD;;AACD7C,QAAAA,SAAS,CAAC0B,IAAD,CAAT;AAEA,YAAIW,OAAO,IAAI,GAAf,EAAoBQ,WAAW,CAAC,CAAD,CAAX,IAAkBnB,IAAI,CAAC,CAAD,CAAtB,CAApB,KACK,IAAIW,OAAO,IAAI,GAAf,EAAoBQ,WAAW,CAAC,CAAD,CAAX,IAAkBnB,IAAI,CAAC,CAAD,CAAtB,CAApB,KACA;AACHmB,UAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBnB,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAAtB;AACAkB,UAAAA,WAAW,CAAC,CAAD,CAAX,IAAkBnB,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAAtB;AACD;AACD3B,QAAAA,SAAS,CAAC6C,WAAD,CAAT;;AAEA,YAAIR,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtCS,UAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcD,WAAW,CAAC,CAAD,CAAzB;AACAC,UAAAA,QAAQ,CAAC,CAAD,CAAR,GAAcD,WAAW,CAAC,CAAD,CAAzB;AACD;AACF,OAhMqC,CAkMtC;;;AACA,UAAI9D,MAAM,CAACK,cAAX,EAA2B;AACzB,YACGiD,OAAO,KAAK,GAAZ,IAAmBoD,mBAAmB,CAAC/D,IAAD,CAAvC,IACCW,OAAO,KAAK,GAAZ,IAAmBoD,mBAAmB,CAACrC,KAAD,CAFzC,EAGE;AACA,cAAID,IAAI,IAAIA,IAAI,CAACd,OAAL,IAAgB,GAA5B,EAAiC6C,YAAY,CAAC/B,IAAD,EAAOzB,IAAP,CAAZ,CADjC,CAC2D;;AAC3DW,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAC,CAAZ,CAAP;AACD,SAPD,MAOO,IAAI5B,OAAO,KAAK,GAAZ,IAAmBoD,mBAAmB,CAAC/D,IAAD,CAA1C,EAAkD;AACvD,cAAIyB,IAAI,IAAIA,IAAI,CAACd,OAAL,IAAgB,GAA5B,EAAiC6C,YAAY,CAAC/B,IAAD,EAAOzB,IAAP,CAAZ,CADsB,CACI;;AAC3DW,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAC,CAAZ,CAAP;AACD,SAJM,MAIA,IACL5B,OAAO,KAAK,GAAZ,IACAU,IAAI,CAACV,OAAL,KAAiB,GADjB,IAEAU,IAAI,CAACV,OAAL,KAAiB,GAHZ,EAIL;AACAA,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAC,CAAZ,CAAP;AACD,SAPM,MAOA,IAAI5B,OAAO,KAAK,GAAZ,KAAoBX,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAZ,IAAiBA,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAjD,CAAJ,EAAyD;AAC9DW,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAC,CAAZ,CAAP;AACD;AACF,OA1NqC,CA4NtC;AACA;AACA;;;AACA,UAAIlF,MAAM,CAACM,cAAP,IAAyBgD,OAAO,KAAK,GAAzC,EAA8C;AAC5C,YAAIX,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAhB,EAAmB;AACjBW,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,CAACgE,GAAL;AACD,SAHD,MAGO,IAAIhE,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAhB,EAAmB;AACxBW,UAAAA,OAAO,GAAG,GAAV;AACAX,UAAAA,IAAI,CAAC4D,KAAL;AACD;AACF,OAvOqC,CAyOtC;AACA;;;AACA,UACEvG,MAAM,CAACW,gBAAP,IACA0B,YAAY,KAAK,KADjB,KAECiB,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAA/B,IAAsCA,OAAO,KAAK,GAFnD,KAGAU,IAAI,CAACV,OAHL,IAIAA,OAAO,IAAIU,IAAI,CAACV,OAAL,CAAasD,WAAb,EAJX,KAKEtD,OAAO,IAAI,GAAX,IAAkBA,OAAO,IAAI,GAA9B,IACCU,IAAI,CAACT,IAAL,CAAU,CAAV,KAAgB,CAAhB,IAAqBZ,IAAI,CAAC,CAAD,CAAJ,IAAW,CANlC,CADF,EAQE;AACAqB,QAAAA,IAAI,CAACT,IAAL,CAAU,CAAV,KAAgBZ,IAAI,CAAC,CAAD,CAApB;;AACA,YAAIW,OAAO,IAAI,GAAX,IAAkBA,OAAO,IAAI,GAAjC,EAAsC;AACpCU,UAAAA,IAAI,CAACT,IAAL,CAAU,CAAV,KAAgBZ,IAAI,CAAC,CAAD,CAApB;AACD;;AACDqB,QAAAA,IAAI,CAACP,MAAL,GAAcS,IAAI,CAACT,MAAnB;AACAC,QAAAA,IAAI,CAACS,KAAD,CAAJ,GAAcH,IAAd;AACA,eAAO,KAAP;AACD,OA3PqC,CA6PtC;;;AACA,UAAIhE,MAAM,CAACO,qBAAP,IAAgCyD,IAAI,CAACV,OAAzC,EAAkD;AAChD;AACA,YAAIA,OAAO,KAAK,GAAhB,EAAqB;AACnB;AACA,cACEU,IAAI,CAACV,OAAL,KAAiB,GAAjB,IACAX,IAAI,CAAC,CAAD,CAAJ,KAAY,EAAEqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAAjB,CADZ,IAEAZ,IAAI,CAAC,CAAD,CAAJ,KAAY,EAAEqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAAjB,CAHd,EAIE;AACAD,YAAAA,OAAO,GAAG,GAAV;AACAX,YAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAX,CAAP;AACD,WAPD,CASA;AATA,eAUK,IACHlB,IAAI,CAACV,OAAL,KAAiB,GAAjB,IACAX,IAAI,CAAC,CAAD,CAAJ,KAAY,EAAEqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAAjB,CADZ,IAEAZ,IAAI,CAAC,CAAD,CAAJ,KAAY,EAAEqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAAjB,CAHT,EAIH;AACAD,YAAAA,OAAO,GAAG,GAAV;AACAX,YAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAX,CAAP;AACD,WAPI,CASL;AATK,eAUA,IACHlB,IAAI,CAACV,OAAL,KAAiB,GAAjB,IACAU,IAAI,CAACV,OAAL,KAAiB,GADjB,IAEAX,IAAI,CAAC,CAAD,CAAJ,KAAY,CAFZ,IAGAA,IAAI,CAAC,CAAD,CAAJ,KAAY,CAJT,EAKH;AACAW,YAAAA,OAAO,GAAG,GAAV;AACAX,YAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAX,CAAP;AACD;AACF,SA/BD,CAiCA;AAjCA,aAkCK,IAAI5B,OAAO,KAAK,GAAhB,EAAqB;AACxB;AACA,cACEU,IAAI,CAACV,OAAL,KAAiB,GAAjB,IACAX,IAAI,CAAC,CAAD,CAAJ,KAAYqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAD3B,IAEAZ,IAAI,CAAC,CAAD,CAAJ,KAAYqB,IAAI,CAACT,IAAL,CAAU,CAAV,IAAeS,IAAI,CAACT,IAAL,CAAU,CAAV,CAH7B,EAIE;AACAD,YAAAA,OAAO,GAAG,GAAV;AACAX,YAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAX,CAAP;AACD,WAPD,CASA;AATA,eAUK,IACHlB,IAAI,CAACV,OAAL,KAAiB,GAAjB,IACAX,IAAI,CAAC,CAAD,CAAJ,KAAYqB,IAAI,CAACT,IAAL,CAAU,CAAV,CADZ,IAEAZ,IAAI,CAAC,CAAD,CAAJ,KAAYqB,IAAI,CAACT,IAAL,CAAU,CAAV,CAHT,EAIH;AACAD,YAAAA,OAAO,GAAG,GAAV;AACAX,YAAAA,IAAI,GAAGA,IAAI,CAACuC,KAAL,CAAW,CAAX,CAAP;AACD;AACF;AACF,OAvTqC,CAyTtC;;;AACA,UAAIlF,MAAM,CAACU,aAAP,IAAwB,CAACgC,wBAA7B,EAAuD;AACrD;AACA,YACE,CAACY,OAAO,KAAK,GAAZ,IACCA,OAAO,KAAK,GADb,IAECA,OAAO,KAAK,GAFb,IAGCA,OAAO,KAAK,GAHb,IAICA,OAAO,KAAK,GAJb,IAKCA,OAAO,KAAK,GALb,IAMCA,OAAO,KAAK,GANd,KAOAX,IAAI,CAACkE,KAAL,CAAW,UAAUzD,CAAV,EAAa;AACtB,iBAAOA,CAAC,KAAK,CAAb;AACD,SAFD,CARF,EAWE;AACAM,UAAAA,IAAI,CAACS,KAAD,CAAJ,GAAcH,IAAd;AACA,iBAAO,KAAP;AACD,SAhBoD,CAkBrD;;;AACA,YAAIV,OAAO,KAAK,GAAZ,IAAmBX,IAAI,CAAC,CAAD,CAAJ,KAAY,CAA/B,IAAoCA,IAAI,CAAC,CAAD,CAAJ,KAAY,CAApD,EAAuD;AACrDe,UAAAA,IAAI,CAACS,KAAD,CAAJ,GAAcH,IAAd;AACA,iBAAO,KAAP;AACD;AACF;;AAEDE,MAAAA,IAAI,CAACZ,OAAL,GAAeA,OAAf;AACAY,MAAAA,IAAI,CAACX,IAAL,GAAYZ,IAAZ;AAEAqB,MAAAA,IAAI,GAAGE,IAAP;AACD,KAvVD,MAuVO;AACL;AACAJ,MAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBC,QAAQ,CAAC,CAAD,CAAzB;AACAD,MAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBC,QAAQ,CAAC,CAAD,CAAzB;AACA,UAAIC,IAAI,CAACV,OAAL,KAAiB,GAAjB,IAAwBU,IAAI,CAACV,OAAL,KAAiB,GAA7C,EAAkD,OAAO,KAAP;AAClDU,MAAAA,IAAI,GAAGE,IAAP;AACD;;AAED,WAAO,IAAP;AACD,GArWM,CAAP;AAuWA,SAAOR,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASX,cAAT,CAAwBW,IAAxB,EAA8B1D,MAA9B,EAAsC;AACpC,MAAIgE,IAAI,GAAGN,IAAI,CAAC,CAAD,CAAf;AAEAA,EAAAA,IAAI,GAAGA,IAAI,CAACO,MAAL,CAAY,UAAUC,IAAV,EAAgBC,KAAhB,EAAuB;AACxC,QAAIA,KAAK,IAAI,CAAb,EAAgB,OAAO,IAAP;;AAChB,QAAID,IAAI,CAACZ,OAAL,KAAiB,GAAjB,IAAwBY,IAAI,CAACZ,OAAL,KAAiB,GAA7C,EAAkD;AAChDU,MAAAA,IAAI,GAAGE,IAAP;AACA,aAAO,IAAP;AACD;;AAED,QAAIZ,OAAO,GAAGY,IAAI,CAACZ,OAAnB;AAAA,QACEX,IAAI,GAAGuB,IAAI,CAACX,IADd;AAAA,QAEEuD,KAAK,GAAGnE,IAAI,CAACuC,KAAL,EAFV;;AAIA,QACE5B,OAAO,KAAK,GAAZ,IACAA,OAAO,KAAK,GADZ,IAEAA,OAAO,KAAK,GAFZ,IAGAA,OAAO,KAAK,GAHZ,IAIAA,OAAO,KAAK,GAJZ,IAKAA,OAAO,KAAK,GANd,EAOE;AACA,WAAK,IAAIF,CAAC,GAAG0D,KAAK,CAAClE,MAAnB,EAA2BQ,CAAC,EAA5B,GAAkC;AAChC0D,QAAAA,KAAK,CAAC1D,CAAD,CAAL,IAAYc,IAAI,CAACV,IAAL,CAAUJ,CAAC,GAAG,CAAd,CAAZ;AACD;AACF,KAXD,MAWO,IAAIE,OAAO,IAAI,GAAf,EAAoB;AACzBwD,MAAAA,KAAK,CAAC,CAAD,CAAL,IAAY5C,IAAI,CAACV,IAAL,CAAU,CAAV,CAAZ;AACD,KAFM,MAEA,IAAIF,OAAO,IAAI,GAAf,EAAoB;AACzBwD,MAAAA,KAAK,CAAC,CAAD,CAAL,IAAY5C,IAAI,CAACV,IAAL,CAAU,CAAV,CAAZ;AACD,KAFM,MAEA,IAAIF,OAAO,IAAI,GAAf,EAAoB;AACzBwD,MAAAA,KAAK,CAAC,CAAD,CAAL,IAAY5C,IAAI,CAACV,IAAL,CAAU,CAAV,CAAZ;AACAsD,MAAAA,KAAK,CAAC,CAAD,CAAL,IAAY5C,IAAI,CAACV,IAAL,CAAU,CAAV,CAAZ;AACD;;AAEDvC,IAAAA,SAAS,CAAC6F,KAAD,CAAT;AAEA,QAAIC,eAAe,GAAGrH,cAAc,CAACoH,KAAD,EAAQ9G,MAAR,CAApC;AAAA,QACEgH,eAAe,GAAGtH,cAAc,CAACiD,IAAD,EAAO3C,MAAP,CADlC,CAjCwC,CAoCxC;AACA;AACA;AACA;;AACA,QACEA,MAAM,CAACgB,iBAAP,IACC+F,eAAe,CAACnE,MAAhB,GAAyBoE,eAAe,CAACpE,MAAzC,IACC,EACE5C,MAAM,CAACc,kBAAP,IACAwC,OAAO,IAAIU,IAAI,CAACV,OADhB,IAEAU,IAAI,CAACV,OAAL,CAAa2D,UAAb,CAAwB,CAAxB,IAA6B,EAF7B,IAGAF,eAAe,CAACnE,MAAhB,IAA0BoE,eAAe,CAACpE,MAAhB,GAAyB,CAHnD,KAICD,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV,IACE,OAAOuE,IAAP,CAAYvE,IAAI,CAAC,CAAD,CAAhB,KAAwBqB,IAAI,CAACT,IAAL,CAAUS,IAAI,CAACT,IAAL,CAAUX,MAAV,GAAmB,CAA7B,IAAkC,CAL7D,CADF,CAHJ,EAWE;AACAsB,MAAAA,IAAI,CAACZ,OAAL,GAAeA,OAAO,CAAC6D,WAAR,EAAf;AACAjD,MAAAA,IAAI,CAACX,IAAL,GAAYuD,KAAZ;AACD;;AAED9C,IAAAA,IAAI,GAAGE,IAAP;AAEA,WAAO,IAAP;AACD,GA3DM,CAAP;AA6DA,SAAOR,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgB,QAAT,CAAkB/B,IAAlB,EAAwB;AACtB,MAAI0C,MAAM,GAAG+B,eAAe,CAAC,CAC3B,CAD2B,EAE3B,CAF2B,EAG3BzE,IAAI,CAAC,CAAD,CAHuB,EAI3BA,IAAI,CAAC,CAAD,CAJuB,EAK3BA,IAAI,CAAC,CAAD,CALuB,EAM3BA,IAAI,CAAC,CAAD,CANuB,EAO3BA,IAAI,CAAC,CAAD,CAPuB,EAQ3BA,IAAI,CAAC,CAAD,CARuB,CAAD,CAA5B;AAWA,SACE0C,MAAM,IACN1C,IAAI,CAAC,CAAD,CAAJ,GAAU0C,MAAM,CAAC,CAAD,CAAhB,IAAuBA,MAAM,CAAC,CAAD,CAAN,GAAY,CADnC,IAEA1C,IAAI,CAAC,CAAD,CAAJ,GAAU0C,MAAM,CAAC,CAAD,CAAhB,IAAuBA,MAAM,CAAC,CAAD,CAAN,GAAY,CAFnC,IAGA1C,IAAI,CAAC,CAAD,CAAJ,GAAU0C,MAAM,CAAC,CAAD,CAAhB,IAAuBA,MAAM,CAAC,CAAD,CAAN,GAAY1C,IAAI,CAAC,CAAD,CAHvC,IAIAA,IAAI,CAAC,CAAD,CAAJ,GAAU0C,MAAM,CAAC,CAAD,CAAhB,IAAuBA,MAAM,CAAC,CAAD,CAAN,GAAY1C,IAAI,CAAC,CAAD,CALzC;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASyE,eAAT,CAAyB3D,MAAzB,EAAiC;AAC/B;AACA,MAAI4D,EAAE,GAAG5D,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA3B;AAAA,MAAgC;AAC9B6D,EAAAA,EAAE,GAAG7D,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CADzB;AAAA,MAC8B;AAC5B8D,EAAAA,EAAE,GAAG9D,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAlB,GAAwBA,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAFjD;AAAA,MAEsD;AACpD;AACA+D,EAAAA,EAAE,GAAG/D,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAJzB;AAAA,MAI8B;AAC5BgE,EAAAA,EAAE,GAAGhE,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CALzB;AAAA,MAK8B;AAC5BiE,EAAAA,EAAE,GAAGjE,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAlB,GAAwBA,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CANjD;AAAA,MAMsD;AACpDkE,EAAAA,KAAK,GAAGN,EAAE,GAAGI,EAAL,GAAUD,EAAE,GAAGF,EAPzB;AASA,MAAI,CAACK,KAAL,EAAY,OAXmB,CAWX;;AAEpB,MAAIC,KAAK,GAAG,CAAC,CAACN,EAAE,GAAGI,EAAL,GAAUD,EAAE,GAAGF,EAAhB,IAAsBI,KAAvB,EAA8B,CAACN,EAAE,GAAGK,EAAL,GAAUF,EAAE,GAAGD,EAAhB,IAAsB,CAACI,KAArD,CAAZ;;AACA,MACE,CAACE,KAAK,CAACD,KAAK,CAAC,CAAD,CAAN,CAAN,IACA,CAACC,KAAK,CAACD,KAAK,CAAC,CAAD,CAAN,CADN,IAEAE,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAFR,IAGAE,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,CAJV,EAKE;AACA,WAAOA,KAAP;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASzF,WAAT,CAAqBQ,IAArB,EAA2B;AACzB,OAAK,IAAIS,CAAC,GAAGT,IAAI,CAACC,MAAlB,EAA0BQ,CAAC,KAAK,CAAhC,GAAqC;AACnC,QAAIT,IAAI,CAACS,CAAD,CAAJ,CAAQlB,OAAR,CAAgBhB,SAAhB,KAA8ByB,IAAI,CAACS,CAAD,CAAtC,EAA2C;AACzC,UAAI2E,OAAO,GAAG,CAACpF,IAAI,CAACS,CAAD,CAAJ,CAAQlB,OAAR,CAAgBhB,SAAS,GAAG,CAA5B,CAAf;AACAyB,MAAAA,IAAI,CAACS,CAAD,CAAJ,GACE,CAACpB,IAAI,CAACgG,GAAL,CAASD,OAAO,GAAGpF,IAAI,CAACS,CAAD,CAAvB,EAA4BlB,OAA5B,CAAoChB,SAAS,GAAG,CAAhD,CAAD,IAAuDC,KAAvD,GACI,CAACwB,IAAI,CAACS,CAAD,CAAJ,CAAQlB,OAAR,CAAgBhB,SAAhB,CADL,GAEI6G,OAHN;AAID;AACF;;AACD,SAAOpF,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASP,KAAT,CAAeO,IAAf,EAAqB;AACnB,OAAK,IAAIS,CAAC,GAAGT,IAAI,CAACC,MAAlB,EAA0BQ,CAAC,KAAK,CAAhC,GAAqC;AACnCT,IAAAA,IAAI,CAACS,CAAD,CAAJ,GAAUpB,IAAI,CAACI,KAAL,CAAWO,IAAI,CAACS,CAAD,CAAf,CAAV;AACD;;AACD,SAAOT,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAS+D,mBAAT,CAA6B/D,IAA7B,EAAmC;AACjC;AACA,MAAIS,CAAC,GAAGT,IAAI,CAACC,MAAL,GAAc,CAAtB;AAAA,MACEqF,CAAC,GAAG,CAACtF,IAAI,CAACS,CAAC,GAAG,CAAL,CADX;AAAA,MACoB;AAClB8E,EAAAA,CAAC,GAAGvF,IAAI,CAACS,CAAD,CAFV;AAAA,MAEe;AACbtB,EAAAA,CAAC,GAAG,KAAKmG,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAjB,CAHN,CAFiC,CAKN;;AAE3B,MAAI9E,CAAC,IAAI,CAAL,IAAU,CAAC0E,QAAQ,CAAChG,CAAD,CAAvB,EAA4B,OAAO,KAAP,CAPK,CAOS;AAE1C;;AACA,SAAO,CAACsB,CAAC,IAAI,CAAN,KAAY,CAAnB,EAAsB;AACpB,QAAIpB,IAAI,CAACmG,IAAL,CAAUnG,IAAI,CAACC,GAAL,CAASgG,CAAC,GAAGtF,IAAI,CAACS,CAAD,CAAR,GAAc8E,CAAC,GAAGvF,IAAI,CAACS,CAAC,GAAG,CAAL,CAA/B,EAAwC,CAAxC,IAA6CtB,CAAvD,IAA4DX,KAAhE,EACE,OAAO,KAAP;AACH;;AAED,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASgF,YAAT,CAAsBjC,IAAtB,EAA4BvB,IAA5B,EAAkC;AAChC,UAAQuB,IAAI,CAACZ,OAAb;AACE,SAAK,GAAL;AACEY,MAAAA,IAAI,CAACZ,OAAL,GAAe,GAAf;AACA;;AACF,SAAK,GAAL;AACEY,MAAAA,IAAI,CAACZ,OAAL,GAAe,GAAf;AACA;AANJ;;AAQAY,EAAAA,IAAI,CAACX,IAAL,CAAUqC,OAAV,CACEjD,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAAJ,GAAwBD,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAD9B,EAEED,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAAJ,GAAwBD,IAAI,CAACA,IAAI,CAACC,MAAL,GAAc,CAAf,CAF9B;AAIA,SAAOsB,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASkE,WAAT,CAAqBC,MAArB,EAA6BC,MAA7B,EAAqC;AACnC,SAAOtG,IAAI,CAACuG,KAAL,CAAWF,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAA7B,EAAkCD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAApD,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,mBAAT,CAA6BC,KAA7B,EAAoCC,CAApC,EAAuC;AACrC,MAAIC,IAAI,GAAGD,CAAC,GAAGA,CAAf;AAAA,MACEE,IAAI,GAAGD,IAAI,GAAGD,CADhB;AAAA,MAEEG,EAAE,GAAG,IAAIH,CAFX;AAAA,MAGEI,KAAK,GAAGD,EAAE,GAAGA,EAHf;AAKA,SAAO,CACL,IAAIC,KAAJ,GAAYJ,CAAZ,GAAgBD,KAAK,CAAC,CAAD,CAArB,GAA2B,IAAII,EAAJ,GAASF,IAAT,GAAgBF,KAAK,CAAC,CAAD,CAAhD,GAAsDG,IAAI,GAAGH,KAAK,CAAC,CAAD,CAD7D,EAEL,IAAIK,KAAJ,GAAYJ,CAAZ,GAAgBD,KAAK,CAAC,CAAD,CAArB,GAA2B,IAAII,EAAJ,GAASF,IAAT,GAAgBF,KAAK,CAAC,CAAD,CAAhD,GAAsDG,IAAI,GAAGH,KAAK,CAAC,CAAD,CAF7D,CAAP;AAID;AAED;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAS9D,UAAT,CAAoB8D,KAApB,EAA2B;AACzB,MAAIM,QAAQ,GAAGP,mBAAmB,CAACC,KAAD,EAAQ,IAAI,CAAZ,CAAlC;AAAA,MACEO,EAAE,GAAG,CAACD,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAf,EAAkBA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAhC,CADP;AAAA,MAEEE,EAAE,GAAG,CAAC,CAACF,QAAQ,CAAC,CAAD,CAAR,GAAcN,KAAK,CAAC,CAAD,CAApB,IAA2B,CAA5B,EAA+B,CAACM,QAAQ,CAAC,CAAD,CAAR,GAAcN,KAAK,CAAC,CAAD,CAApB,IAA2B,CAA1D,CAFP;AAAA,MAGEpD,MAAM,GAAG+B,eAAe,CAAC,CACvB4B,EAAE,CAAC,CAAD,CADqB,EAEvBA,EAAE,CAAC,CAAD,CAFqB,EAGvBA,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAHa,EAIvBA,EAAE,CAAC,CAAD,CAAF,GAAQA,EAAE,CAAC,CAAD,CAJa,EAKvBC,EAAE,CAAC,CAAD,CALqB,EAMvBA,EAAE,CAAC,CAAD,CANqB,EAOvBA,EAAE,CAAC,CAAD,CAAF,IAASA,EAAE,CAAC,CAAD,CAAF,GAAQF,QAAQ,CAAC,CAAD,CAAzB,CAPuB,EAQvBE,EAAE,CAAC,CAAD,CAAF,IAASA,EAAE,CAAC,CAAD,CAAF,GAAQF,QAAQ,CAAC,CAAD,CAAzB,CARuB,CAAD,CAH1B;AAAA,MAaElE,MAAM,GAAGQ,MAAM,IAAI+C,WAAW,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,EAAS/C,MAAT,CAbhC;AAAA,MAcEjF,SAAS,GAAG4B,IAAI,CAACkH,GAAL,CAAS9H,YAAY,GAAGD,KAAxB,EAAgCE,YAAY,GAAGwD,MAAhB,GAA0B,GAAzD,CAdd;AAgBA,MACEQ,MAAM,IACNR,MAAM,GAAG,IADT,IAEA,CAAC,IAAI,CAAL,EAAQ,IAAI,CAAZ,EAAegC,KAAf,CAAqB,UAAUsC,KAAV,EAAiB;AACpC,WACEnH,IAAI,CAACgG,GAAL,CACEI,WAAW,CAACI,mBAAmB,CAACC,KAAD,EAAQU,KAAR,CAApB,EAAoC9D,MAApC,CAAX,GAAyDR,MAD3D,KAEKzE,SAHP;AAKD,GAND,CAHF,EAWE,OAAO;AAAEiF,IAAAA,MAAM,EAAEA,MAAV;AAAkBR,IAAAA,MAAM,EAAEA;AAA1B,GAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASuB,KAAT,CAAeqC,KAAf,EAAsBnE,MAAtB,EAA8B;AAC5B,MAAIlE,SAAS,GAAG4B,IAAI,CAACkH,GAAL,CACd9H,YAAY,GAAGD,KADD,EAEbE,YAAY,GAAGiD,MAAM,CAACO,MAAvB,GAAiC,GAFnB,CAAhB;AAKA,SAAO,CAAC,CAAD,EAAI,IAAI,CAAR,EAAW,IAAI,CAAf,EAAkB,IAAI,CAAtB,EAAyB,CAAzB,EAA4BgC,KAA5B,CAAkC,UAAUsC,KAAV,EAAiB;AACxD,WACEnH,IAAI,CAACgG,GAAL,CACEI,WAAW,CAACI,mBAAmB,CAACC,KAAD,EAAQU,KAAR,CAApB,EAAoC7E,MAAM,CAACe,MAA3C,CAAX,GACEf,MAAM,CAACO,MAFX,KAGKzE,SAJP;AAMD,GAPM,CAAP;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASuF,SAAT,CAAmB8C,KAAnB,EAA0BnE,MAA1B,EAAkC;AAChC,SAAO8B,KAAK,CAACqC,KAAD,EAAQ;AAClBpD,IAAAA,MAAM,EAAE,CAACf,MAAM,CAACe,MAAP,CAAc,CAAd,IAAmBoD,KAAK,CAAC,CAAD,CAAzB,EAA8BnE,MAAM,CAACe,MAAP,CAAc,CAAd,IAAmBoD,KAAK,CAAC,CAAD,CAAtD,CADU;AAElB5D,IAAAA,MAAM,EAAEP,MAAM,CAACO;AAFG,GAAR,CAAZ;AAID;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,YAAT,CAAsB0D,KAAtB,EAA6BnD,SAA7B,EAAwC;AACtC,MAAI8D,EAAE,GAAG,CAAC9D,SAAS,CAACD,MAAV,CAAiB,CAAjB,CAAV;AAAA,MACEgE,EAAE,GAAG,CAAC/D,SAAS,CAACD,MAAV,CAAiB,CAAjB,CADR;AAAA,MAEEiE,EAAE,GAAGb,KAAK,CAAC,CAAD,CAAL,GAAWnD,SAAS,CAACD,MAAV,CAAiB,CAAjB,CAFlB;AAAA,MAGEkE,EAAE,GAAGd,KAAK,CAAC,CAAD,CAAL,GAAWnD,SAAS,CAACD,MAAV,CAAiB,CAAjB,CAHlB;AAKA,SAAOrD,IAAI,CAACwH,IAAL,CACL,CAACJ,EAAE,GAAGE,EAAL,GAAUD,EAAE,GAAGE,EAAhB,IAAsBvH,IAAI,CAACmG,IAAL,CAAU,CAACiB,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAhB,KAAuBC,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAtC,CAAV,CADjB,CAAP;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAS3F,SAAT,CAAmB5D,MAAnB,EAA2BgD,QAA3B,EAAqC;AACnC,SAAOA,QAAQ,CAACyG,MAAT,CAAgB,UAAUC,UAAV,EAAsBxF,IAAtB,EAA4B;AACjD,QAAIyF,OAAO,GAAG,EAAd;;AACA,QAAIzF,IAAI,CAACX,IAAT,EAAe;AACboG,MAAAA,OAAO,GAAGjK,cAAc,CAACuB,SAAS,CAACiD,IAAI,CAACX,IAAL,CAAU2B,KAAV,EAAD,CAAV,EAA+BlF,MAA/B,CAAxB;AACD;;AACD,WAAO0J,UAAU,GAAGxF,IAAI,CAACZ,OAAlB,GAA4BqG,OAAnC;AACD,GANM,EAMJ,EANI,CAAP;AAOD","sourcesContent":["'use strict';\n\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { pathElems } = require('./_collections.js');\nconst { path2js, js2path } = require('./_path.js');\nconst { applyTransforms } = require('./_applyTransforms.js');\nconst { cleanupOutData } = require('../lib/svgo/tools');\n\nexports.name = 'convertPathData';\nexports.type = 'visitor';\nexports.active = true;\nexports.description =\n  'optimizes path data: writes in shorter form, applies transformations';\n\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5, // coefficient of rounding error\n    tolerance: 0.5, // percentage of radius\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true,\n  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n  forceAbsolutePath: false,\n};\n\nlet roundData;\nlet precision;\nlet error;\nlet arcThreshold;\nlet arcTolerance;\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node) => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = params.floatPrecision;\n          error =\n            precision !== false\n              ? +Math.pow(0.1, precision).toFixed(precision)\n              : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n          if (params.makeArcs) {\n            arcThreshold = params.makeArcs.threshold;\n            arcTolerance = params.makeArcs.tolerance;\n          }\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n\n          const maybeHasStroke =\n            computedStyle.stroke &&\n            (computedStyle.stroke.type === 'dynamic' ||\n              computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap =\n            computedStyle['stroke-linecap'] &&\n            (computedStyle['stroke-linecap'].type === 'dynamic' ||\n              computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n\n          var data = path2js(node);\n\n          // TODO: get rid of functions returns\n          if (data.length) {\n            if (params.applyTransforms) {\n              applyTransforms(node, data, params);\n            }\n\n            convertToRelative(data);\n\n            data = filters(data, params, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid,\n            });\n\n            if (params.utilizeAbsolute) {\n              data = convertToMixed(data, params);\n            }\n\n            js2path(node, data, params);\n          }\n        }\n      },\n    },\n  };\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nconst convertToRelative = (pathData) => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    // closepath\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n    // store absolute coordinates for later use\n    // base should preserve reference from other element\n    pathItem.base = prevCoords;\n    pathItem.coords = [cursor[0], cursor[1]];\n    prevCoords = pathItem.coords;\n  }\n\n  return pathData;\n};\n\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {\n  var stringify = data2Path.bind(null, params),\n    relSubpoint = [0, 0],\n    pathBase = [0, 0],\n    prev = {};\n\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n        circle;\n\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        if (command === 'c' || command === 's') {\n          var pdata = prev.args,\n            n = pdata.length;\n\n          // (-x, -y) of the prev tangent point relative to the current point\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      }\n\n      // convert curves to arcs if possible\n      if (\n        params.makeArcs &&\n        (command == 'c' || command == 's') &&\n        isConvex(sdata) &&\n        (circle = findCircle(sdata))\n      ) {\n        var r = roundData([circle.radius])[0],\n          angle = findArcAngle(sdata, circle),\n          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n          arc = {\n            command: 'a',\n            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n            coords: item.coords.slice(),\n            base: item.base,\n          },\n          output = [arc],\n          // relative coordinates to adjust the found circle\n          relCenter = [\n            circle.center[0] - sdata[4],\n            circle.center[1] - sdata[5],\n          ],\n          relCircle = { center: relCenter, radius: circle.radius },\n          arcCurves = [item],\n          hasPrev = 0,\n          suffix = '',\n          nextLonghand;\n\n        if (\n          (prev.command == 'c' &&\n            isConvex(prev.args) &&\n            isArcPrev(prev.args, circle)) ||\n          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))\n        ) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [\n              prevData[4] + circle.center[0],\n              prevData[5] + circle.center[1],\n            ],\n            radius: circle.radius,\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        }\n\n        // check if next curves are fitting the arc\n        for (\n          var j = index;\n          (next = path[++j]) && ~'cs'.indexOf(next.command);\n\n        ) {\n          var nextData = next.args;\n          if (next.command == 's') {\n            nextLonghand = makeLonghand(\n              { command: 's', args: next.args.slice() },\n              path[j - 1].args\n            );\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [\n                arc.base[0] + arc.args[5],\n                arc.base[1] + arc.args[6],\n              ];\n              arc = {\n                command: 'a',\n                args: [\n                  r,\n                  r,\n                  0,\n                  0,\n                  sweep,\n                  next.coords[0] - arc.coords[0],\n                  next.coords[1] - arc.coords[1],\n                ],\n                coords: next.coords,\n                base: arc.coords,\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.args);\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            prev.command = 'a';\n            prev.args = prevArc.args;\n            item.base = prev.coords = prevArc.coords;\n          }\n          arc = output.shift();\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(\n              path,\n              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)\n            );\n          }\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          item.coords = arc.coords;\n        }\n      }\n\n      // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n      if (precision !== false) {\n        if (\n          command === 'm' ||\n          command === 'l' ||\n          command === 't' ||\n          command === 'q' ||\n          command === 's' ||\n          command === 'c'\n        ) {\n          for (var i = data.length; i--; ) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n        roundData(data);\n\n        if (command == 'h') relSubpoint[0] += data[0];\n        else if (command == 'v') relSubpoint[1] += data[0];\n        else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      }\n\n      // convert straight curves into lines segments\n      if (params.straightCurves) {\n        if (\n          (command === 'c' && isCurveStraightLine(data)) ||\n          (command === 's' && isCurveStraightLine(sdata))\n        ) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (\n          command === 't' &&\n          prev.command !== 'q' &&\n          prev.command !== 't'\n        ) {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      }\n\n      // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      }\n\n      // collapse repeated commands\n      // h 20 h 30 -> h 50\n      if (\n        params.collapseRepeated &&\n        hasMarkerMid === false &&\n        (command === 'm' || command === 'h' || command === 'v') &&\n        prev.command &&\n        command == prev.command.toLowerCase() &&\n        ((command != 'h' && command != 'v') ||\n          prev.args[0] >= 0 == data[0] >= 0)\n      ) {\n        prev.args[0] += data[0];\n        if (command != 'h' && command != 'v') {\n          prev.args[1] += data[1];\n        }\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      }\n\n      // convert curves into smooth shorthands\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (\n            prev.command === 'c' &&\n            data[0] === -(prev.args[2] - prev.args[4]) &&\n            data[1] === -(prev.args[3] - prev.args[5])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // s + c → s + s\n          else if (\n            prev.command === 's' &&\n            data[0] === -(prev.args[0] - prev.args[2]) &&\n            data[1] === -(prev.args[1] - prev.args[3])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // [^cs] + c → [^cs] + s\n          else if (\n            prev.command !== 'c' &&\n            prev.command !== 's' &&\n            data[0] === 0 &&\n            data[1] === 0\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n        }\n\n        // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (\n            prev.command === 'q' &&\n            data[0] === prev.args[2] - prev.args[0] &&\n            data[1] === prev.args[3] - prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n\n          // t + q → t + t\n          else if (\n            prev.command === 't' &&\n            data[2] === prev.args[0] &&\n            data[3] === prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      }\n\n      // remove useless non-first path segments\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if (\n          (command === 'l' ||\n            command === 'h' ||\n            command === 'v' ||\n            command === 'q' ||\n            command === 't' ||\n            command === 'c' ||\n            command === 's') &&\n          data.every(function (i) {\n            return i === 0;\n          })\n        ) {\n          path[index] = prev;\n          return false;\n        }\n\n        // a 25,25 -30 0,1 0,0\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.command = command;\n      item.args = data;\n\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n\n    var command = item.command,\n      data = item.args,\n      adata = data.slice();\n\n    if (\n      command === 'm' ||\n      command === 'l' ||\n      command === 't' ||\n      command === 'q' ||\n      command === 's' ||\n      command === 'c'\n    ) {\n      for (var i = adata.length; i--; ) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n\n    var absoluteDataStr = cleanupOutData(adata, params),\n      relativeDataStr = cleanupOutData(data, params);\n\n    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n    if (\n      params.forceAbsolutePath ||\n      (absoluteDataStr.length < relativeDataStr.length &&\n        !(\n          params.negativeExtraSpace &&\n          command == prev.command &&\n          prev.command.charCodeAt(0) > 96 &&\n          absoluteDataStr.length == relativeDataStr.length - 1 &&\n          (data[0] < 0 ||\n            (/^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))\n        ))\n    ) {\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n\n    prev = item;\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction isConvex(data) {\n  var center = getIntersection([\n    0,\n    0,\n    data[2],\n    data[3],\n    data[0],\n    data[1],\n    data[4],\n    data[5],\n  ]);\n\n  return (\n    center &&\n    data[2] < center[0] == center[0] < 0 &&\n    data[3] < center[1] == center[1] < 0 &&\n    data[4] < center[0] == center[0] < data[0] &&\n    data[5] < center[1] == center[1] < data[1]\n  );\n}\n\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3], // y1 - y2\n    b1 = coords[2] - coords[0], // x2 - x1\n    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1\n    // Next line equation parameters\n    a2 = coords[5] - coords[7], // y1 - y2\n    b2 = coords[6] - coords[4], // x2 - x1\n    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1\n    denom = a1 * b2 - a2 * b1;\n\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n  if (\n    !isNaN(cross[0]) &&\n    !isNaN(cross[1]) &&\n    isFinite(cross[0]) &&\n    isFinite(cross[1])\n  ) {\n    return cross;\n  }\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0; ) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n}\n\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction round(data) {\n  for (var i = data.length; i-- > 0; ) {\n    data[i] = Math.round(data[i]);\n  }\n  return data;\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n    a = -data[i + 1], // y1 − y2 (y1 = 0)\n    b = data[i], // x2 − x1 (x1 = 0)\n    d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n    case 't':\n      item.command = 'q';\n      break;\n  }\n  item.args.unshift(\n    data[data.length - 2] - data[data.length - 4],\n    data[data.length - 1] - data[data.length - 3]\n  );\n  return item;\n}\n\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n    cubT = sqrT * t,\n    mt = 1 - t,\n    sqrMt = mt * mt;\n\n  return [\n    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],\n    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],\n  ];\n}\n\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n    m1 = [midPoint[0] / 2, midPoint[1] / 2],\n    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n    center = getIntersection([\n      m1[0],\n      m1[1],\n      m1[0] + m1[1],\n      m1[1] - m1[0],\n      m2[0],\n      m2[1],\n      m2[0] + (m2[1] - midPoint[1]),\n      m2[1] - (m2[0] - midPoint[0]),\n    ]),\n    radius = center && getDistance([0, 0], center),\n    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);\n\n  if (\n    center &&\n    radius < 1e15 &&\n    [1 / 4, 3 / 4].every(function (point) {\n      return (\n        Math.abs(\n          getDistance(getCubicBezierPoint(curve, point), center) - radius\n        ) <= tolerance\n      );\n    })\n  )\n    return { center: center, radius: radius };\n}\n\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(\n    arcThreshold * error,\n    (arcTolerance * circle.radius) / 100\n  );\n\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return (\n      Math.abs(\n        getDistance(getCubicBezierPoint(curve, point), circle.center) -\n          circle.radius\n      ) <= tolerance\n    );\n  });\n}\n\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius,\n  });\n}\n\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n    y1 = -relCircle.center[1],\n    x2 = curve[4] - relCircle.center[0],\n    y2 = curve[5] - relCircle.center[1];\n\n  return Math.acos(\n    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n  );\n}\n\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n    return pathString + item.command + strData;\n  }, '');\n}\n"]},"metadata":{},"sourceType":"script"}