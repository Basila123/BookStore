{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst stable = require('stable');\n\nconst csstree = require('css-tree'); // @ts-ignore not defined in @types/csso\n\n\nconst specificity = require('csso/lib/restructure/prepare/specificity');\n\nconst {\n  visit,\n  matches\n} = require('./xast.js');\n\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs\n} = require('../plugins/_collections.js'); // @ts-ignore not defined in @types/csstree\n\n\nconst csstreeWalkSkip = csstree.walk.skip;\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}\n */\n\nconst parseRule = (ruleNode, dynamic) => {\n  let selectors;\n  let selectorsSpecificity;\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n\n  const declarations = [];\n  csstree.walk(ruleNode, cssNode => {\n    if (cssNode.type === 'SelectorList') {\n      // compute specificity from original node to consider pseudo classes\n      selectorsSpecificity = specificity(cssNode);\n      const newSelectorsNode = csstree.clone(cssNode);\n      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          dynamic = true;\n          list.remove(item);\n        }\n      });\n      selectors = csstree.generate(newSelectorsNode);\n      return csstreeWalkSkip;\n    }\n\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n      return csstreeWalkSkip;\n    }\n  });\n\n  if (selectors == null || selectorsSpecificity == null) {\n    throw Error('assert');\n  }\n\n  return {\n    dynamic,\n    selectors,\n    specificity: selectorsSpecificity,\n    declarations\n  };\n};\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\n\n\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Rule') {\n      rules.push(parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n\n      csstree.walk(cssNode, ruleNode => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\n\n\nconst parseStyleDeclarations = css => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n  return declarations;\n};\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\n\n\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map(); // collect attributes\n\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, false);\n    }\n  } // collect matching rules\n\n\n  for (const {\n    selectors,\n    declarations,\n    dynamic\n  } of stylesheet.rules) {\n    if (matches(node, selectors)) {\n      for (const {\n        name,\n        value,\n        important\n      } of declarations) {\n        const computed = computedStyle[name];\n\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n\n        if (dynamic) {\n          computedStyle[name] = {\n            type: 'dynamic',\n            inherited: false\n          };\n          continue;\n        }\n\n        if (computed == null || important === true || importantStyles.get(name) === false) {\n          computedStyle[name] = {\n            type: 'static',\n            inherited: false,\n            value\n          };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  } // collect inline styles\n\n\n  const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);\n\n  for (const {\n    name,\n    value,\n    important\n  } of styleDeclarations) {\n    const computed = computedStyle[name];\n\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n\n    if (computed == null || important === true || importantStyles.get(name) === false) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\n\n\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\n\n\nconst collectStylesheet = root => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode); // find and parse all styles\n\n        if (node.name === 'style') {\n          const dynamic = node.attributes.media != null && node.attributes.media !== 'all';\n\n          if (node.attributes.type == null || node.attributes.type === '' || node.attributes.type === 'text/css') {\n            const children = node.children;\n\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      }\n    }\n  }); // sort by selectors specificity\n\n  stable.inplace(rules, (a, b) => compareSpecificity(a.specificity, b.specificity));\n  return {\n    rules,\n    parents\n  };\n};\n\nexports.collectStylesheet = collectStylesheet;\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\n\nconst computeStyle = (stylesheet, node) => {\n  const {\n    parents\n  } = stylesheet; // collect inherited styles\n\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (computedStyles[name] == null && // ignore not inheritable styles\n      inheritableAttrs.includes(name) === true && presentationNonInheritableGroupAttrs.includes(name) === false) {\n        computedStyles[name] = { ...computed,\n          inherited: true\n        };\n      }\n    }\n\n    parent = parents.get(parent);\n  }\n\n  return computedStyles;\n};\n\nexports.computeStyle = computeStyle;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/lib/style.js"],"names":["stable","require","csstree","specificity","visit","matches","attrsGroups","inheritableAttrs","presentationNonInheritableGroupAttrs","csstreeWalkSkip","walk","skip","parseRule","ruleNode","dynamic","selectors","selectorsSpecificity","declarations","cssNode","type","newSelectorsNode","clone","pseudoClassNode","item","list","remove","generate","push","name","property","value","important","Error","parseStylesheet","css","rules","ast","parse","parseValue","parseAtrulePrelude","parseStyleDeclarations","context","computeOwnStyle","stylesheet","node","computedStyle","importantStyles","Map","Object","entries","attributes","presentation","includes","inherited","set","computed","get","styleDeclarations","style","compareSpecificity","a","b","i","collectStylesheet","root","parents","element","enter","parentNode","media","children","child","inplace","exports","computeStyle","computedStyles","parent","inheritedStyles"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst stable = require('stable');\nconst csstree = require('css-tree');\n// @ts-ignore not defined in @types/csso\nconst specificity = require('csso/lib/restructure/prepare/specificity');\nconst { visit, matches } = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs,\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  let selectors;\n  let selectorsSpecificity;\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  csstree.walk(ruleNode, (cssNode) => {\n    if (cssNode.type === 'SelectorList') {\n      // compute specificity from original node to consider pseudo classes\n      selectorsSpecificity = specificity(cssNode);\n      const newSelectorsNode = csstree.clone(cssNode);\n      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          dynamic = true;\n          list.remove(item);\n        }\n      });\n      selectors = csstree.generate(newSelectorsNode);\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  if (selectors == null || selectorsSpecificity == null) {\n    throw Error('assert');\n  }\n  return {\n    dynamic,\n    selectors,\n    specificity: selectorsSpecificity,\n    declarations,\n  };\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Rule') {\n      rules.push(parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, (ruleNode) => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\nconst parseStyleDeclarations = (css) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const { selectors, declarations, dynamic } of stylesheet.rules) {\n    if (matches(node, selectors)) {\n      for (const { name, value, important } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = { type: 'dynamic', inherited: false };\n          continue;\n        }\n        if (\n          computed == null ||\n          important === true ||\n          importantStyles.get(name) === false\n        ) {\n          computedStyle[name] = { type: 'static', inherited: false, value };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations =\n    node.attributes.style == null\n      ? []\n      : parseStyleDeclarations(node.attributes.style);\n  for (const { name, value, important } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (\n      computed == null ||\n      important === true ||\n      importantStyles.get(name) === false\n    ) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = (root) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode);\n        // find and parse all styles\n        if (node.name === 'style') {\n          const dynamic =\n            node.attributes.media != null && node.attributes.media !== 'all';\n          if (\n            node.attributes.type == null ||\n            node.attributes.type === '' ||\n            node.attributes.type === 'text/css'\n          ) {\n            const children = node.children;\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      },\n    },\n  });\n  // sort by selectors specificity\n  stable.inplace(rules, (a, b) =>\n    compareSpecificity(a.specificity, b.specificity)\n  );\n  return { rules, parents };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const { parents } = stylesheet;\n  // collect inherited styles\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (\n        computedStyles[name] == null &&\n        // ignore not inheritable styles\n        inheritableAttrs.includes(name) === true &&\n        presentationNonInheritableGroupAttrs.includes(name) === false\n      ) {\n        computedStyles[name] = { ...computed, inherited: true };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;\n"]},"metadata":{},"sourceType":"script"}