{"ast":null,"code":"'use strict';\n\nconst joinGridValue = require('../lib/joinGridValue');\n\nconst normalizeGridAutoFlow = gridAutoFlow => {\n  let newValue = {\n    front: '',\n    back: ''\n  };\n  let shouldNormalize = false;\n  gridAutoFlow.walk(node => {\n    if (node.value === 'dense') {\n      shouldNormalize = true;\n      newValue.back = node.value;\n    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      shouldNormalize = false;\n    }\n  });\n\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n\n  return gridAutoFlow;\n};\n\nconst normalizeGridColumnRowGap = gridGap => {\n  let newValue = {\n    front: '',\n    back: ''\n  };\n  let shouldNormalize = false;\n  gridGap.walk(node => {\n    // console.log(node);\n    if (node.value === 'normal') {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      newValue.back = `${newValue.back} ${node.value}`;\n    }\n  });\n\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n\n  return gridGap;\n};\n\nconst normalizeGridColumnRow = grid => {\n  // cant do normalization here using node, so copy it as a string\n  let gridValue = grid.toString().split('/'); // node -> string value, split ->  \" 2 / 3 span \" ->  [' 2','3 span ']\n\n  if (gridValue.length > 1) {\n    return joinGridValue(gridValue.map(gridLine => {\n      let normalizeValue = {\n        front: '',\n        back: ''\n      };\n      gridLine = gridLine.trim(); // '3 span ' -> '3 span'\n\n      gridLine.split(' ').forEach(node => {\n        // ['3','span']\n        if (node === 'span') {\n          normalizeValue.front = node; // span _\n        } else {\n          normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3\n        }\n      });\n      return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3\n    }) // returns \"2 / span 3\"\n    );\n  } // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end\n\n\n  return gridValue.map(gridLine => {\n    let normalizeValue = {\n      front: '',\n      back: ''\n    };\n    gridLine = gridLine.trim();\n    gridLine.split(' ').forEach(node => {\n      if (node === 'span') {\n        normalizeValue.front = node;\n      } else {\n        normalizeValue.back = `${normalizeValue.back} ${node}`;\n      }\n    });\n    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;\n  });\n};\n\nmodule.exports = {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-ordered-values/src/rules/grid.js"],"names":["joinGridValue","require","normalizeGridAutoFlow","gridAutoFlow","newValue","front","back","shouldNormalize","walk","node","value","includes","trim","toLowerCase","normalizeGridColumnRowGap","gridGap","normalizeGridColumnRow","grid","gridValue","toString","split","length","map","gridLine","normalizeValue","forEach","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst joinGridValue = require('../lib/joinGridValue');\n\nconst normalizeGridAutoFlow = (gridAutoFlow) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridAutoFlow.walk((node) => {\n    if (node.value === 'dense') {\n      shouldNormalize = true;\n      newValue.back = node.value;\n    } else if (['row', 'column'].includes(node.value.trim().toLowerCase())) {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      shouldNormalize = false;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridAutoFlow;\n};\n\nconst normalizeGridColumnRowGap = (gridGap) => {\n  let newValue = { front: '', back: '' };\n  let shouldNormalize = false;\n  gridGap.walk((node) => {\n    // console.log(node);\n    if (node.value === 'normal') {\n      shouldNormalize = true;\n      newValue.front = node.value;\n    } else {\n      newValue.back = `${newValue.back} ${node.value}`;\n    }\n  });\n  if (shouldNormalize) {\n    return `${newValue.front.trim()} ${newValue.back.trim()}`;\n  }\n  return gridGap;\n};\n\nconst normalizeGridColumnRow = (grid) => {\n  // cant do normalization here using node, so copy it as a string\n  let gridValue = grid.toString().split('/'); // node -> string value, split ->  \" 2 / 3 span \" ->  [' 2','3 span ']\n  if (gridValue.length > 1) {\n    return joinGridValue(\n      gridValue.map((gridLine) => {\n        let normalizeValue = {\n          front: '',\n          back: '',\n        };\n        gridLine = gridLine.trim(); // '3 span ' -> '3 span'\n        gridLine.split(' ').forEach((node) => {\n          // ['3','span']\n          if (node === 'span') {\n            normalizeValue.front = node; // span _\n          } else {\n            normalizeValue.back = `${normalizeValue.back} ${node}`; // _ 3\n          }\n        });\n        return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`; // span 3\n      })\n      // returns \"2 / span 3\"\n    );\n  }\n  // doing this separating if `/` is not present as while joining('/') , it will add `/` at the end\n  return gridValue.map((gridLine) => {\n    let normalizeValue = {\n      front: '',\n      back: '',\n    };\n    gridLine = gridLine.trim();\n    gridLine.split(' ').forEach((node) => {\n      if (node === 'span') {\n        normalizeValue.front = node;\n      } else {\n        normalizeValue.back = `${normalizeValue.back} ${node}`;\n      }\n    });\n    return `${normalizeValue.front.trim()} ${normalizeValue.back.trim()}`;\n  });\n};\n\nmodule.exports = {\n  normalizeGridAutoFlow,\n  normalizeGridColumnRowGap,\n  normalizeGridColumnRow,\n};\n"]},"metadata":{},"sourceType":"script"}