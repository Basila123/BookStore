{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst validation_error_1 = require(\"../runtime/validation_error\");\n\nconst names_1 = require(\"./names\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n\n}\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n\n  let _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`; // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  let _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = this.opts.uriResolver.parse(ref);\n  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  const id = (0, resolve_1.normalizeId)(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, _ref) {\n  let {\n    baseId,\n    schema,\n    root\n  } = _ref;\n\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return;\n    const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n    if (partSchema === undefined) return;\n    schema = partSchema; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n  }\n\n  let env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["SchemaEnv","constructor","env","schema","schemaId","root","baseId","_a","schemaPath","localRefs","meta","$async","refs","exports","compileSchema","sch","_sch","getCompilingSchema","call","rootId","opts","uriResolver","es5","lines","code","ownProperties","gen","codegen_1","scope","_ValidationError","scopeValue","ref","validation_error_1","validateName","scopeName","schemaCxt","allErrors","data","names_1","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","optimize","validateCode","toString","scopeRefs","process","makeValidate","Function","validate","get","value","errors","scopeValues","_values","unevaluated","props","items","evaluated","undefined","dynamicProps","dynamicItems","e","logger","error","delete","resolveRef","schOrFunc","resolve","inlineOrCompile","inlineRefs","schEnv","sameSchemaEnv","s1","s2","schemas","resolveSchema","p","parse","refPath","Object","keys","length","getJsonPointer","id","schOrRef","schId","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","slice","split","partSchema","has","$ref","RULES"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/compile/index.ts"],"sourcesContent":["import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n"]},"metadata":{},"sourceType":"script"}