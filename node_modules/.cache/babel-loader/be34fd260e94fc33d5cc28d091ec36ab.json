{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    const eql = (0, util_1.useFunc)(gen, equal_1.default);\n    let valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${eql}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AACA;;AACA;;AAIA,MAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE,4CAD2B;AAEpCC,QAAM,EAAE;AAAA,QAAC;AAACC;AAAD,KAAD;AAAA,WAAkB,gBAAC,mBAAmBA,UAAU,GAAhD;AAAA;AAF4B,CAAtC;AAKA,MAAMC,GAAG,GAA0B;AACjCC,SAAO,EAAE,MADwB;AAEjCC,YAAU,EAAE,OAFqB;AAGjCC,OAAK,EAAE,IAH0B;AAIjCP,OAJiC;;AAKjCQ,MAAI,CAACC,GAAD,EAAgB;AAClB,UAAM;AAACC,SAAD;AAAMC,UAAN;AAAYJ,WAAZ;AAAmBK,YAAnB;AAA2BT,gBAA3B;AAAuCU;AAAvC,QAA6CJ,GAAnD;AACA,QAAI,CAACF,KAAD,IAAUK,MAAM,CAACE,MAAP,KAAkB,CAAhC,EAAmC,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACnC,UAAMC,OAAO,GAAGJ,MAAM,CAACE,MAAP,IAAiBD,EAAE,CAACI,IAAH,CAAQC,QAAzC;AACA,UAAMC,GAAG,GAAG,oBAAQT,GAAR,EAAaU,eAAb,CAAZ;AACA,QAAIC,KAAJ;;AACA,QAAIL,OAAO,IAAIT,KAAf,EAAsB;AACpBc,WAAK,GAAGX,GAAG,CAACY,GAAJ,CAAQ,OAAR,CAAR;AACAb,SAAG,CAACc,UAAJ,CAAeF,KAAf,EAAsBH,QAAtB;AACD,KAHD,MAGO;AACL;AACA,UAAI,CAACM,KAAK,CAACC,OAAN,CAAcb,MAAd,CAAL,EAA4B,MAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;AAC5B,YAAMW,OAAO,GAAGhB,GAAG,CAACiB,KAAJ,CAAU,SAAV,EAAqBxB,UAArB,CAAhB;AACAkB,WAAK,GAAG,kBAAG,GAAGT,MAAM,CAACgB,GAAP,CAAW,CAACC,EAAD,EAAcC,CAAd,KAA4BC,SAAS,CAACL,OAAD,EAAUI,CAAV,CAAhD,CAAN,CAAR;AACD;;AACDrB,OAAG,CAACuB,IAAJ,CAASX,KAAT;;AAEA,aAASH,QAAT,GAAiB;AACfR,SAAG,CAACuB,MAAJ,CAAWZ,KAAX,EAAkB,KAAlB;AACAX,SAAG,CAACwB,KAAJ,CAAU,GAAV,EAAe/B,UAAf,EAAoCgC,CAAD,IACjCzB,GAAG,CAAC0B,EAAJ,CAAO,gBAAC,GAAGjB,GAAG,IAAIR,IAAI,KAAKwB,CAAC,GAA5B,EAAiC,MAAMzB,GAAG,CAACuB,MAAJ,CAAWZ,KAAX,EAAkB,IAAlB,EAAwBgB,KAAxB,EAAvC,CADF;AAGD;;AAED,aAASN,SAAT,CAAmBL,OAAnB,EAAkCI,CAAlC,EAA2C;AACzC,YAAMQ,GAAG,GAAG1B,MAAM,CAACkB,CAAD,CAAlB;AACA,aAAO,OAAOQ,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,GACH,gBAAC,GAAGnB,GAAG,IAAIR,IAAI,KAAKe,OAAO,IAAII,CAAC,IAD7B,GAEH,gBAAC,GAAGnB,IAAI,QAAQ2B,GAAG,EAFvB;AAGD;AACF;;AAnCgC,CAAnC;AAsCAC,kBAAenC,GAAf","names":["error","message","params","schemaCode","def","keyword","schemaType","$data","code","cxt","gen","data","schema","it","length","Error","useLoop","opts","loopEnum","eql","equal_1","valid","let","block$data","Array","isArray","vSchema","const","map","_x","i","equalCode","pass","assign","forOf","v","if","break","sch","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/vocabularies/validation/enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    const eql = useFunc(gen, equal)\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${eql}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}