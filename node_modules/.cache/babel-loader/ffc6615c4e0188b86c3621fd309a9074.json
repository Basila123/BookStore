{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst {\n  optimize\n} = require('svgo');\n\nconst {\n  encode,\n  decode\n} = require('./lib/url');\n\nconst PLUGIN = 'postcss-svgo';\nconst dataURI = /data:image\\/svg\\+xml(;((charset=)?utf-8|base64))?,/i;\nconst dataURIBase64 = /data:image\\/svg\\+xml;base64,/i; // the following regex will globally match:\n// \\b([\\w-]+)       --> a word (a sequence of one or more [alphanumeric|underscore|dash] characters; followed by\n// \\s*=\\s*          --> an equal sign character (=) between optional whitespaces; followed by\n// \\\\\"([\\S\\s]+?)\\\\\" --> any characters (including whitespaces and newlines) between literal escaped quotes (\\\")\n\nconst escapedQuotes = /\\b([\\w-]+)\\s*=\\s*\\\\\"([\\S\\s]+?)\\\\\"/g;\n/**\n * @param {string} input the SVG string\n * @param {boolean} encode whether to encode the result\n * @return {object} the minification result\n */\n\nfunction minifySVG(input, opts) {\n  let svg = input;\n  let decodedUri, isUriEncoded;\n\n  try {\n    decodedUri = decode(input);\n    isUriEncoded = decodedUri !== input;\n  } catch (e) {\n    // Swallow exception if we cannot decode the value\n    isUriEncoded = false;\n  }\n\n  if (isUriEncoded) {\n    svg = decodedUri;\n  }\n\n  if (opts.encode !== undefined) {\n    isUriEncoded = opts.encode;\n  } // normalize all escaped quote characters from svg attributes\n  // from <svg attr=\\\"value\\\"... /> to <svg attr=\"value\"... />\n  // see: https://github.com/cssnano/cssnano/issues/1194\n\n\n  svg = svg.replace(escapedQuotes, '$1=\"$2\"');\n  const result = optimize(svg, opts);\n\n  if (result.error) {\n    throw new Error(result.error);\n  }\n\n  return {\n    result: result.data,\n    isUriEncoded\n  };\n}\n\nfunction minify(decl, opts, postcssResult) {\n  const parsed = valueParser(decl.value);\n  const minified = parsed.walk(node => {\n    if (node.type !== 'function' || node.value.toLowerCase() !== 'url' || !node.nodes.length) {\n      return;\n    }\n\n    let {\n      value,\n      quote\n    } = node.nodes[0];\n    let optimizedValue;\n\n    try {\n      if (dataURIBase64.test(value)) {\n        const url = new URL(value);\n        const base64String = `${url.protocol}${url.pathname}`.replace(dataURI, '');\n        const svg = Buffer.from(base64String, 'base64').toString('utf8');\n        const {\n          result\n        } = minifySVG(svg, opts);\n        const data = Buffer.from(result).toString('base64');\n        optimizedValue = 'data:image/svg+xml;base64,' + data + url.hash;\n      } else if (dataURI.test(value)) {\n        const svg = value.replace(dataURI, '');\n        const {\n          result,\n          isUriEncoded\n        } = minifySVG(svg, opts);\n        let data = isUriEncoded ? encode(result) : result; // Should always encode # otherwise we yield a broken SVG\n        // in Firefox (works in Chrome however). See this issue:\n        // https://github.com/cssnano/cssnano/issues/245\n\n        data = data.replace(/#/g, '%23');\n        optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;\n        quote = isUriEncoded ? '\"' : \"'\";\n      } else {\n        return;\n      }\n    } catch (error) {\n      decl.warn(postcssResult, `${error}`);\n      return;\n    }\n\n    node.nodes[0] = Object.assign({}, node.nodes[0], {\n      value: optimizedValue,\n      quote: quote,\n      type: 'string',\n      before: '',\n      after: ''\n    });\n    return false;\n  });\n  decl.value = minified.toString();\n}\n\nfunction pluginCreator() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    postcssPlugin: PLUGIN,\n\n    OnceExit(css, _ref) {\n      let {\n        result\n      } = _ref;\n      css.walkDecls(decl => {\n        if (!dataURI.test(decl.value)) {\n          return;\n        }\n\n        minify(decl, opts, result);\n      });\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/src/index.js"],"names":["valueParser","require","optimize","encode","decode","PLUGIN","dataURI","dataURIBase64","escapedQuotes","minifySVG","input","opts","svg","decodedUri","isUriEncoded","e","undefined","replace","result","error","Error","data","minify","decl","postcssResult","parsed","value","minified","walk","node","type","toLowerCase","nodes","length","quote","optimizedValue","test","url","URL","base64String","protocol","pathname","Buffer","from","toString","hash","warn","Object","assign","before","after","pluginCreator","postcssPlugin","OnceExit","css","walkDecls","postcss","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\nconst { optimize } = require('svgo');\nconst { encode, decode } = require('./lib/url');\n\nconst PLUGIN = 'postcss-svgo';\nconst dataURI = /data:image\\/svg\\+xml(;((charset=)?utf-8|base64))?,/i;\nconst dataURIBase64 = /data:image\\/svg\\+xml;base64,/i;\n\n// the following regex will globally match:\n// \\b([\\w-]+)       --> a word (a sequence of one or more [alphanumeric|underscore|dash] characters; followed by\n// \\s*=\\s*          --> an equal sign character (=) between optional whitespaces; followed by\n// \\\\\"([\\S\\s]+?)\\\\\" --> any characters (including whitespaces and newlines) between literal escaped quotes (\\\")\nconst escapedQuotes = /\\b([\\w-]+)\\s*=\\s*\\\\\"([\\S\\s]+?)\\\\\"/g;\n\n/**\n * @param {string} input the SVG string\n * @param {boolean} encode whether to encode the result\n * @return {object} the minification result\n */\nfunction minifySVG(input, opts) {\n  let svg = input;\n  let decodedUri, isUriEncoded;\n  try {\n    decodedUri = decode(input);\n    isUriEncoded = decodedUri !== input;\n  } catch (e) {\n    // Swallow exception if we cannot decode the value\n    isUriEncoded = false;\n  }\n\n  if (isUriEncoded) {\n    svg = decodedUri;\n  }\n\n  if (opts.encode !== undefined) {\n    isUriEncoded = opts.encode;\n  }\n\n  // normalize all escaped quote characters from svg attributes\n  // from <svg attr=\\\"value\\\"... /> to <svg attr=\"value\"... />\n  // see: https://github.com/cssnano/cssnano/issues/1194\n  svg = svg.replace(escapedQuotes, '$1=\"$2\"');\n\n  const result = optimize(svg, opts);\n  if (result.error) {\n    throw new Error(result.error);\n  }\n\n  return { result: result.data, isUriEncoded };\n}\n\nfunction minify(decl, opts, postcssResult) {\n  const parsed = valueParser(decl.value);\n\n  const minified = parsed.walk((node) => {\n    if (\n      node.type !== 'function' ||\n      node.value.toLowerCase() !== 'url' ||\n      !node.nodes.length\n    ) {\n      return;\n    }\n\n    let { value, quote } = node.nodes[0];\n    let optimizedValue;\n\n    try {\n      if (dataURIBase64.test(value)) {\n        const url = new URL(value);\n        const base64String = `${url.protocol}${url.pathname}`.replace(\n          dataURI,\n          ''\n        );\n        const svg = Buffer.from(base64String, 'base64').toString('utf8');\n        const { result } = minifySVG(svg, opts);\n        const data = Buffer.from(result).toString('base64');\n        optimizedValue = 'data:image/svg+xml;base64,' + data + url.hash;\n      } else if (dataURI.test(value)) {\n        const svg = value.replace(dataURI, '');\n        const { result, isUriEncoded } = minifySVG(svg, opts);\n        let data = isUriEncoded ? encode(result) : result;\n        // Should always encode # otherwise we yield a broken SVG\n        // in Firefox (works in Chrome however). See this issue:\n        // https://github.com/cssnano/cssnano/issues/245\n        data = data.replace(/#/g, '%23');\n        optimizedValue = 'data:image/svg+xml;charset=utf-8,' + data;\n        quote = isUriEncoded ? '\"' : \"'\";\n      } else {\n        return;\n      }\n    } catch (error) {\n      decl.warn(postcssResult, `${error}`);\n      return;\n    }\n    node.nodes[0] = Object.assign({}, node.nodes[0], {\n      value: optimizedValue,\n      quote: quote,\n      type: 'string',\n      before: '',\n      after: '',\n    });\n\n    return false;\n  });\n\n  decl.value = minified.toString();\n}\n\nfunction pluginCreator(opts = {}) {\n  return {\n    postcssPlugin: PLUGIN,\n\n    OnceExit(css, { result }) {\n      css.walkDecls((decl) => {\n        if (!dataURI.test(decl.value)) {\n          return;\n        }\n\n        minify(decl, opts, result);\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]},"metadata":{},"sourceType":"script"}