{"ast":null,"code":"'use strict';\n\nconst {\n  visit\n} = require('../lib/xast.js');\n\nconst {\n  inheritableAttrs,\n  pathElems\n} = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'moveElemsAttrsToGroup';\nexports.active = true;\nexports.description = 'Move common attributes of group children to the group';\n/**\n * Move common attributes of group children to the group\n *\n * @example\n * <g attr1=\"val1\">\n *     <g attr2=\"val2\">\n *         text\n *     </g>\n *     <circle attr2=\"val2\" attr3=\"val3\"/>\n * </g>\n *              ⬇\n * <g attr1=\"val1\" attr2=\"val2\">\n *     <g>\n *         text\n *     </g>\n *    <circle attr3=\"val3\"/>\n * </g>\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<void>}\n */\n\nexports.fn = root => {\n  // find if any style element is present\n  let deoptimizedWithStyles = false;\n  visit(root, {\n    element: {\n      enter: node => {\n        if (node.name === 'style') {\n          deoptimizedWithStyles = true;\n        }\n      }\n    }\n  });\n  return {\n    element: {\n      exit: node => {\n        // process only groups with more than 1 children\n        if (node.name !== 'g' || node.children.length <= 1) {\n          return;\n        } // deoptimize the plugin when style elements are present\n        // selectors may rely on id, classes or tag names\n\n\n        if (deoptimizedWithStyles) {\n          return;\n        }\n        /**\n         * find common attributes in group children\n         * @type {Map<string, string>}\n         */\n\n\n        const commonAttributes = new Map();\n        let initial = true;\n        let everyChildIsPath = true;\n\n        for (const child of node.children) {\n          if (child.type === 'element') {\n            if (pathElems.includes(child.name) === false) {\n              everyChildIsPath = false;\n            }\n\n            if (initial) {\n              initial = false; // collect all inheritable attributes from first child element\n\n              for (const [name, value] of Object.entries(child.attributes)) {\n                // consider only inheritable attributes\n                if (inheritableAttrs.includes(name)) {\n                  commonAttributes.set(name, value);\n                }\n              }\n            } else {\n              // exclude uncommon attributes from initial list\n              for (const [name, value] of commonAttributes) {\n                if (child.attributes[name] !== value) {\n                  commonAttributes.delete(name);\n                }\n              }\n            }\n          }\n        } // preserve transform on children when group has clip-path or mask\n\n\n        if (node.attributes['clip-path'] != null || node.attributes.mask != null) {\n          commonAttributes.delete('transform');\n        } // preserve transform when all children are paths\n        // so the transform could be applied to path data by other plugins\n\n\n        if (everyChildIsPath) {\n          commonAttributes.delete('transform');\n        } // add common children attributes to group\n\n\n        for (const [name, value] of commonAttributes) {\n          if (name === 'transform') {\n            if (node.attributes.transform != null) {\n              node.attributes.transform = `${node.attributes.transform} ${value}`;\n            } else {\n              node.attributes.transform = value;\n            }\n          } else {\n            node.attributes[name] = value;\n          }\n        } // delete common attributes from children\n\n\n        for (const child of node.children) {\n          if (child.type === 'element') {\n            for (const [name] of commonAttributes) {\n              delete child.attributes[name];\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/moveElemsAttrsToGroup.js"],"names":["visit","require","inheritableAttrs","pathElems","exports","type","name","active","description","fn","root","deoptimizedWithStyles","element","enter","node","exit","children","length","commonAttributes","Map","initial","everyChildIsPath","child","includes","value","Object","entries","attributes","set","delete","mask","transform"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAYC,OAAO,CAAC,gBAAD,CAAzB;;AACA,MAAM;AAAEC,EAAAA,gBAAF;AAAoBC,EAAAA;AAApB,IAAkCF,OAAO,CAAC,mBAAD,CAA/C;;AAEAG,OAAO,CAACC,IAAR,GAAe,SAAf;AACAD,OAAO,CAACE,IAAR,GAAe,uBAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,IAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,uDAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,OAAO,CAACK,EAAR,GAAcC,IAAD,IAAU;AACrB;AACA,MAAIC,qBAAqB,GAAG,KAA5B;AACAX,EAAAA,KAAK,CAACU,IAAD,EAAO;AACVE,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAGC,IAAD,IAAU;AACf,YAAIA,IAAI,CAACR,IAAL,KAAc,OAAlB,EAA2B;AACzBK,UAAAA,qBAAqB,GAAG,IAAxB;AACD;AACF;AALM;AADC,GAAP,CAAL;AAUA,SAAO;AACLC,IAAAA,OAAO,EAAE;AACPG,MAAAA,IAAI,EAAGD,IAAD,IAAU;AACd;AACA,YAAIA,IAAI,CAACR,IAAL,KAAc,GAAd,IAAqBQ,IAAI,CAACE,QAAL,CAAcC,MAAd,IAAwB,CAAjD,EAAoD;AAClD;AACD,SAJa,CAMd;AACA;;;AACA,YAAIN,qBAAJ,EAA2B;AACzB;AACD;AAED;AACR;AACA;AACA;;;AACQ,cAAMO,gBAAgB,GAAG,IAAIC,GAAJ,EAAzB;AACA,YAAIC,OAAO,GAAG,IAAd;AACA,YAAIC,gBAAgB,GAAG,IAAvB;;AACA,aAAK,MAAMC,KAAX,IAAoBR,IAAI,CAACE,QAAzB,EAAmC;AACjC,cAAIM,KAAK,CAACjB,IAAN,KAAe,SAAnB,EAA8B;AAC5B,gBAAIF,SAAS,CAACoB,QAAV,CAAmBD,KAAK,CAAChB,IAAzB,MAAmC,KAAvC,EAA8C;AAC5Ce,cAAAA,gBAAgB,GAAG,KAAnB;AACD;;AACD,gBAAID,OAAJ,EAAa;AACXA,cAAAA,OAAO,GAAG,KAAV,CADW,CAEX;;AACA,mBAAK,MAAM,CAACd,IAAD,EAAOkB,KAAP,CAAX,IAA4BC,MAAM,CAACC,OAAP,CAAeJ,KAAK,CAACK,UAArB,CAA5B,EAA8D;AAC5D;AACA,oBAAIzB,gBAAgB,CAACqB,QAAjB,CAA0BjB,IAA1B,CAAJ,EAAqC;AACnCY,kBAAAA,gBAAgB,CAACU,GAAjB,CAAqBtB,IAArB,EAA2BkB,KAA3B;AACD;AACF;AACF,aATD,MASO;AACL;AACA,mBAAK,MAAM,CAAClB,IAAD,EAAOkB,KAAP,CAAX,IAA4BN,gBAA5B,EAA8C;AAC5C,oBAAII,KAAK,CAACK,UAAN,CAAiBrB,IAAjB,MAA2BkB,KAA/B,EAAsC;AACpCN,kBAAAA,gBAAgB,CAACW,MAAjB,CAAwBvB,IAAxB;AACD;AACF;AACF;AACF;AACF,SA1Ca,CA4Cd;;;AACA,YACEQ,IAAI,CAACa,UAAL,CAAgB,WAAhB,KAAgC,IAAhC,IACAb,IAAI,CAACa,UAAL,CAAgBG,IAAhB,IAAwB,IAF1B,EAGE;AACAZ,UAAAA,gBAAgB,CAACW,MAAjB,CAAwB,WAAxB;AACD,SAlDa,CAoDd;AACA;;;AACA,YAAIR,gBAAJ,EAAsB;AACpBH,UAAAA,gBAAgB,CAACW,MAAjB,CAAwB,WAAxB;AACD,SAxDa,CA0Dd;;;AACA,aAAK,MAAM,CAACvB,IAAD,EAAOkB,KAAP,CAAX,IAA4BN,gBAA5B,EAA8C;AAC5C,cAAIZ,IAAI,KAAK,WAAb,EAA0B;AACxB,gBAAIQ,IAAI,CAACa,UAAL,CAAgBI,SAAhB,IAA6B,IAAjC,EAAuC;AACrCjB,cAAAA,IAAI,CAACa,UAAL,CAAgBI,SAAhB,GAA6B,GAAEjB,IAAI,CAACa,UAAL,CAAgBI,SAAU,IAAGP,KAAM,EAAlE;AACD,aAFD,MAEO;AACLV,cAAAA,IAAI,CAACa,UAAL,CAAgBI,SAAhB,GAA4BP,KAA5B;AACD;AACF,WAND,MAMO;AACLV,YAAAA,IAAI,CAACa,UAAL,CAAgBrB,IAAhB,IAAwBkB,KAAxB;AACD;AACF,SArEa,CAuEd;;;AACA,aAAK,MAAMF,KAAX,IAAoBR,IAAI,CAACE,QAAzB,EAAmC;AACjC,cAAIM,KAAK,CAACjB,IAAN,KAAe,SAAnB,EAA8B;AAC5B,iBAAK,MAAM,CAACC,IAAD,CAAX,IAAqBY,gBAArB,EAAuC;AACrC,qBAAOI,KAAK,CAACK,UAAN,CAAiBrB,IAAjB,CAAP;AACD;AACF;AACF;AACF;AAhFM;AADJ,GAAP;AAoFD,CAjGD","sourcesContent":["'use strict';\n\nconst { visit } = require('../lib/xast.js');\nconst { inheritableAttrs, pathElems } = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'moveElemsAttrsToGroup';\nexports.active = true;\nexports.description = 'Move common attributes of group children to the group';\n\n/**\n * Move common attributes of group children to the group\n *\n * @example\n * <g attr1=\"val1\">\n *     <g attr2=\"val2\">\n *         text\n *     </g>\n *     <circle attr2=\"val2\" attr3=\"val3\"/>\n * </g>\n *              ⬇\n * <g attr1=\"val1\" attr2=\"val2\">\n *     <g>\n *         text\n *     </g>\n *    <circle attr3=\"val3\"/>\n * </g>\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<void>}\n */\nexports.fn = (root) => {\n  // find if any style element is present\n  let deoptimizedWithStyles = false;\n  visit(root, {\n    element: {\n      enter: (node) => {\n        if (node.name === 'style') {\n          deoptimizedWithStyles = true;\n        }\n      },\n    },\n  });\n\n  return {\n    element: {\n      exit: (node) => {\n        // process only groups with more than 1 children\n        if (node.name !== 'g' || node.children.length <= 1) {\n          return;\n        }\n\n        // deoptimize the plugin when style elements are present\n        // selectors may rely on id, classes or tag names\n        if (deoptimizedWithStyles) {\n          return;\n        }\n\n        /**\n         * find common attributes in group children\n         * @type {Map<string, string>}\n         */\n        const commonAttributes = new Map();\n        let initial = true;\n        let everyChildIsPath = true;\n        for (const child of node.children) {\n          if (child.type === 'element') {\n            if (pathElems.includes(child.name) === false) {\n              everyChildIsPath = false;\n            }\n            if (initial) {\n              initial = false;\n              // collect all inheritable attributes from first child element\n              for (const [name, value] of Object.entries(child.attributes)) {\n                // consider only inheritable attributes\n                if (inheritableAttrs.includes(name)) {\n                  commonAttributes.set(name, value);\n                }\n              }\n            } else {\n              // exclude uncommon attributes from initial list\n              for (const [name, value] of commonAttributes) {\n                if (child.attributes[name] !== value) {\n                  commonAttributes.delete(name);\n                }\n              }\n            }\n          }\n        }\n\n        // preserve transform on children when group has clip-path or mask\n        if (\n          node.attributes['clip-path'] != null ||\n          node.attributes.mask != null\n        ) {\n          commonAttributes.delete('transform');\n        }\n\n        // preserve transform when all children are paths\n        // so the transform could be applied to path data by other plugins\n        if (everyChildIsPath) {\n          commonAttributes.delete('transform');\n        }\n\n        // add common children attributes to group\n        for (const [name, value] of commonAttributes) {\n          if (name === 'transform') {\n            if (node.attributes.transform != null) {\n              node.attributes.transform = `${node.attributes.transform} ${value}`;\n            } else {\n              node.attributes.transform = value;\n            }\n          } else {\n            node.attributes[name] = value;\n          }\n        }\n\n        // delete common attributes from children\n        for (const child of node.children) {\n          if (child.type === 'element') {\n            for (const [name] of commonAttributes) {\n              delete child.attributes[name];\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}