{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1.str)`must match \"${params.ifClause}\" schema`;\n  },\n  params: _ref2 => {\n    let {\n      params\n    } = _ref2;\n    return (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`;\n  }\n};\nconst def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      it\n    } = cxt;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    const hasThen = hasSchema(it, \"then\");\n    const hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    const valid = gen.let(\"valid\", true);\n    const schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, () => cxt.error(true));\n\n    function validateIf() {\n      const schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return () => {\n        const schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n\n};\n\nfunction hasSchema(it, keyword) {\n  const schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","ifClause","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/applicator/if.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}