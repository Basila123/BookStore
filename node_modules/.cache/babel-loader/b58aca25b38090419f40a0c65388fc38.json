{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst dataType_1 = require(\"../../compile/validate/dataType\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{i: ${i}, j: ${j}}`;\n  }\n};\nconst def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      parentSchema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && !schema) return;\n    const valid = gen.let(\"valid\");\n    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);\n    cxt.ok(valid);\n\n    function validateUniqueItems() {\n      const i = gen.let(\"i\", (0, codegen_1._)`${data}.length`);\n      const j = gen.let(\"j\");\n      cxt.setParams({\n        i,\n        j\n      });\n      gen.assign(valid, true);\n      gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n    }\n\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(t => t === \"object\" || t === \"array\");\n    }\n\n    function loopN(i, j) {\n      const item = gen.name(\"item\");\n      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      const indices = gen.const(\"indices\", (0, codegen_1._)`{}`);\n      gen.for((0, codegen_1._)`;${i}--;`, () => {\n        gen.let(item, (0, codegen_1._)`${data}[${i}]`);\n        gen.if(wrongType, (0, codegen_1._)`continue`);\n        if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == \"string\"`, (0, codegen_1._)`${item} += \"_\"`);\n        gen.if((0, codegen_1._)`typeof ${indices}[${item}] == \"number\"`, () => {\n          gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);\n      });\n    }\n\n    function loopN2(i, j) {\n      const eql = (0, util_1.useFunc)(gen, equal_1.default);\n      const outer = gen.name(\"outer\");\n      gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n        cxt.error();\n        gen.assign(valid, false).break(outer);\n      })));\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","i","j","def","keyword","type","schemaType","$data","code","cxt","gen","data","schema","parentSchema","schemaCode","it","valid","let","itemTypes","items","block$data","validateUniqueItems","ok","setParams","assign","if","canOptimize","loopN","loopN2","length","some","t","item","name","wrongType","opts","strictNumbers","dataType_1","Wrong","indices","const","for","break","eql","equal_1","outer","label","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}