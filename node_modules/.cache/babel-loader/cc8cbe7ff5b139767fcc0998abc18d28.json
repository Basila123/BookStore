{"ast":null,"code":"'use strict';\n\nexports.name = 'removeAttrs';\nexports.type = 'visitor';\nexports.active = false;\nexports.description = 'removes specified attributes';\nconst DEFAULT_SEPARATOR = ':';\nconst ENOATTRS = `Warning: The plugin \"removeAttrs\" requires the \"attrs\" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: \"removeAttrs\",\n    params: {\n      attrs: \"(fill|stroke)\"\n    }\n  }\n]\n`;\n/**\n * Remove attributes\n *\n * @example elemSeparator\n *   format: string\n *\n * @example preserveCurrentColor\n *   format: boolean\n *\n * @example attrs:\n *\n *   format: [ element* : attribute* : value* ]\n *\n *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)\n *   attribute : regexp (wrapped into ^...$)\n *   value     : regexp (wrapped into ^...$), single * or omitted > all values\n *\n *   examples:\n *\n *     > basic: remove fill attribute\n *     ---\n *     removeAttrs:\n *       attrs: 'fill'\n *\n *     > remove fill attribute on path element\n *     ---\n *       attrs: 'path:fill'\n *\n *     > remove fill attribute on path element where value is none\n *     ---\n *       attrs: 'path:fill:none'\n *\n *\n *     > remove all fill and stroke attribute\n *     ---\n *       attrs:\n *         - 'fill'\n *         - 'stroke'\n *\n *     [is same as]\n *\n *       attrs: '(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke):.*'\n *\n *\n *     > remove all stroke related attributes\n *     ----\n *     attrs: 'stroke.*'\n *\n *\n * @author Benny Schudel\n *\n * @type {import('../lib/types').Plugin<{\n *   elemSeparator?: string,\n *   preserveCurrentColor?: boolean,\n *   attrs: string | Array<string>\n * }>}\n */\n\nexports.fn = (root, params) => {\n  if (typeof params.attrs == 'undefined') {\n    console.warn(ENOATTRS);\n    return null;\n  }\n\n  const elemSeparator = typeof params.elemSeparator == 'string' ? params.elemSeparator : DEFAULT_SEPARATOR;\n  const preserveCurrentColor = typeof params.preserveCurrentColor == 'boolean' ? params.preserveCurrentColor : false;\n  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];\n  return {\n    element: {\n      enter: node => {\n        for (let pattern of attrs) {\n          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*\n          if (pattern.includes(elemSeparator) === false) {\n            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join(''); // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value\n          } else if (pattern.split(elemSeparator).length < 3) {\n            pattern = [pattern, elemSeparator, '.*'].join('');\n          } // create regexps for element, attribute name, and attribute value\n\n\n          const list = pattern.split(elemSeparator).map(value => {\n            // adjust single * to match anything\n            if (value === '*') {\n              value = '.*';\n            }\n\n            return new RegExp(['^', value, '$'].join(''), 'i');\n          }); // matches element\n\n          if (list[0].test(node.name)) {\n            // loop attributes\n            for (const [name, value] of Object.entries(node.attributes)) {\n              const isFillCurrentColor = preserveCurrentColor && name == 'fill' && value == 'currentColor';\n              const isStrokeCurrentColor = preserveCurrentColor && name == 'stroke' && value == 'currentColor';\n\n              if (!isFillCurrentColor && !isStrokeCurrentColor && // matches attribute name\n              list[1].test(name) && // matches attribute value\n              list[2].test(value)) {\n                delete node.attributes[name];\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/removeAttrs.js"],"names":["exports","name","type","active","description","DEFAULT_SEPARATOR","ENOATTRS","fn","root","params","attrs","console","warn","elemSeparator","preserveCurrentColor","Array","isArray","element","enter","node","pattern","includes","join","split","length","list","map","value","RegExp","test","Object","entries","attributes","isFillCurrentColor","isStrokeCurrentColor"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,IAAR,GAAe,aAAf;AACAD,OAAO,CAACE,IAAR,GAAe,SAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,KAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,8BAAtB;AAEA,MAAMC,iBAAiB,GAAG,GAA1B;AACA,MAAMC,QAAQ,GAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAN,OAAO,CAACO,EAAR,GAAa,CAACC,IAAD,EAAOC,MAAP,KAAkB;AAC7B,MAAI,OAAOA,MAAM,CAACC,KAAd,IAAuB,WAA3B,EAAwC;AACtCC,IAAAA,OAAO,CAACC,IAAR,CAAaN,QAAb;AACA,WAAO,IAAP;AACD;;AAED,QAAMO,aAAa,GACjB,OAAOJ,MAAM,CAACI,aAAd,IAA+B,QAA/B,GACIJ,MAAM,CAACI,aADX,GAEIR,iBAHN;AAIA,QAAMS,oBAAoB,GACxB,OAAOL,MAAM,CAACK,oBAAd,IAAsC,SAAtC,GACIL,MAAM,CAACK,oBADX,GAEI,KAHN;AAIA,QAAMJ,KAAK,GAAGK,KAAK,CAACC,OAAN,CAAcP,MAAM,CAACC,KAArB,IAA8BD,MAAM,CAACC,KAArC,GAA6C,CAACD,MAAM,CAACC,KAAR,CAA3D;AAEA,SAAO;AACLO,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAGC,IAAD,IAAU;AACf,aAAK,IAAIC,OAAT,IAAoBV,KAApB,EAA2B;AACzB;AACA,cAAIU,OAAO,CAACC,QAAR,CAAiBR,aAAjB,MAAoC,KAAxC,EAA+C;AAC7CO,YAAAA,OAAO,GAAG,CAAC,IAAD,EAAOP,aAAP,EAAsBO,OAAtB,EAA+BP,aAA/B,EAA8C,IAA9C,EAAoDS,IAApD,CACR,EADQ,CAAV,CAD6C,CAI7C;AACD,WALD,MAKO,IAAIF,OAAO,CAACG,KAAR,CAAcV,aAAd,EAA6BW,MAA7B,GAAsC,CAA1C,EAA6C;AAClDJ,YAAAA,OAAO,GAAG,CAACA,OAAD,EAAUP,aAAV,EAAyB,IAAzB,EAA+BS,IAA/B,CAAoC,EAApC,CAAV;AACD,WATwB,CAWzB;;;AACA,gBAAMG,IAAI,GAAGL,OAAO,CAACG,KAAR,CAAcV,aAAd,EAA6Ba,GAA7B,CAAkCC,KAAD,IAAW;AACvD;AACA,gBAAIA,KAAK,KAAK,GAAd,EAAmB;AACjBA,cAAAA,KAAK,GAAG,IAAR;AACD;;AACD,mBAAO,IAAIC,MAAJ,CAAW,CAAC,GAAD,EAAMD,KAAN,EAAa,GAAb,EAAkBL,IAAlB,CAAuB,EAAvB,CAAX,EAAuC,GAAvC,CAAP;AACD,WANY,CAAb,CAZyB,CAoBzB;;AACA,cAAIG,IAAI,CAAC,CAAD,CAAJ,CAAQI,IAAR,CAAaV,IAAI,CAAClB,IAAlB,CAAJ,EAA6B;AAC3B;AACA,iBAAK,MAAM,CAACA,IAAD,EAAO0B,KAAP,CAAX,IAA4BG,MAAM,CAACC,OAAP,CAAeZ,IAAI,CAACa,UAApB,CAA5B,EAA6D;AAC3D,oBAAMC,kBAAkB,GACtBnB,oBAAoB,IACpBb,IAAI,IAAI,MADR,IAEA0B,KAAK,IAAI,cAHX;AAIA,oBAAMO,oBAAoB,GACxBpB,oBAAoB,IACpBb,IAAI,IAAI,QADR,IAEA0B,KAAK,IAAI,cAHX;;AAIA,kBACE,CAACM,kBAAD,IACA,CAACC,oBADD,IAEA;AACAT,cAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQI,IAAR,CAAa5B,IAAb,CAHA,IAIA;AACAwB,cAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQI,IAAR,CAAaF,KAAb,CANF,EAOE;AACA,uBAAOR,IAAI,CAACa,UAAL,CAAgB/B,IAAhB,CAAP;AACD;AACF;AACF;AACF;AACF;AA/CM;AADJ,GAAP;AAmDD,CAnED","sourcesContent":["'use strict';\n\nexports.name = 'removeAttrs';\nexports.type = 'visitor';\nexports.active = false;\nexports.description = 'removes specified attributes';\n\nconst DEFAULT_SEPARATOR = ':';\nconst ENOATTRS = `Warning: The plugin \"removeAttrs\" requires the \"attrs\" parameter.\nIt should have a pattern to remove, otherwise the plugin is a noop.\nConfig example:\n\nplugins: [\n  {\n    name: \"removeAttrs\",\n    params: {\n      attrs: \"(fill|stroke)\"\n    }\n  }\n]\n`;\n\n/**\n * Remove attributes\n *\n * @example elemSeparator\n *   format: string\n *\n * @example preserveCurrentColor\n *   format: boolean\n *\n * @example attrs:\n *\n *   format: [ element* : attribute* : value* ]\n *\n *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)\n *   attribute : regexp (wrapped into ^...$)\n *   value     : regexp (wrapped into ^...$), single * or omitted > all values\n *\n *   examples:\n *\n *     > basic: remove fill attribute\n *     ---\n *     removeAttrs:\n *       attrs: 'fill'\n *\n *     > remove fill attribute on path element\n *     ---\n *       attrs: 'path:fill'\n *\n *     > remove fill attribute on path element where value is none\n *     ---\n *       attrs: 'path:fill:none'\n *\n *\n *     > remove all fill and stroke attribute\n *     ---\n *       attrs:\n *         - 'fill'\n *         - 'stroke'\n *\n *     [is same as]\n *\n *       attrs: '(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke)'\n *\n *     [is same as]\n *\n *       attrs: '.*:(fill|stroke):.*'\n *\n *\n *     > remove all stroke related attributes\n *     ----\n *     attrs: 'stroke.*'\n *\n *\n * @author Benny Schudel\n *\n * @type {import('../lib/types').Plugin<{\n *   elemSeparator?: string,\n *   preserveCurrentColor?: boolean,\n *   attrs: string | Array<string>\n * }>}\n */\nexports.fn = (root, params) => {\n  if (typeof params.attrs == 'undefined') {\n    console.warn(ENOATTRS);\n    return null;\n  }\n\n  const elemSeparator =\n    typeof params.elemSeparator == 'string'\n      ? params.elemSeparator\n      : DEFAULT_SEPARATOR;\n  const preserveCurrentColor =\n    typeof params.preserveCurrentColor == 'boolean'\n      ? params.preserveCurrentColor\n      : false;\n  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];\n\n  return {\n    element: {\n      enter: (node) => {\n        for (let pattern of attrs) {\n          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*\n          if (pattern.includes(elemSeparator) === false) {\n            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join(\n              ''\n            );\n            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value\n          } else if (pattern.split(elemSeparator).length < 3) {\n            pattern = [pattern, elemSeparator, '.*'].join('');\n          }\n\n          // create regexps for element, attribute name, and attribute value\n          const list = pattern.split(elemSeparator).map((value) => {\n            // adjust single * to match anything\n            if (value === '*') {\n              value = '.*';\n            }\n            return new RegExp(['^', value, '$'].join(''), 'i');\n          });\n\n          // matches element\n          if (list[0].test(node.name)) {\n            // loop attributes\n            for (const [name, value] of Object.entries(node.attributes)) {\n              const isFillCurrentColor =\n                preserveCurrentColor &&\n                name == 'fill' &&\n                value == 'currentColor';\n              const isStrokeCurrentColor =\n                preserveCurrentColor &&\n                name == 'stroke' &&\n                value == 'currentColor';\n              if (\n                !isFillCurrentColor &&\n                !isStrokeCurrentColor &&\n                // matches attribute name\n                list[1].test(name) &&\n                // matches attribute value\n                list[2].test(value)\n              ) {\n                delete node.attributes[name];\n              }\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}