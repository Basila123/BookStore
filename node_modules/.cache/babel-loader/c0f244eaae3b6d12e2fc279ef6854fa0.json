{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  stringifyPathData\n} = require('../lib/path.js');\n\nconst {\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'converts basic shapes to more compact path form';\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   convertArcs?: boolean,\n *   floatPrecision?: number\n * }>}\n */\n\nexports.fn = (root, params) => {\n  const {\n    convertArcs = false,\n    floatPrecision: precision\n  } = params;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (node.name === 'rect' && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height); // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const pathData = [{\n            command: 'M',\n            args: [x, y]\n          }, {\n            command: 'H',\n            args: [x + width]\n          }, {\n            command: 'V',\n            args: [y + height]\n          }, {\n            command: 'H',\n            args: [x]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        } // convert line to path\n\n\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const pathData = [{\n            command: 'M',\n            args: [x1, y1]\n          }, {\n            command: 'L',\n            args: [x2, y2]\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        } // convert polyline and polygon to path\n\n\n        if ((node.name === 'polyline' || node.name === 'polygon') && node.attributes.points != null) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(Number);\n\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [];\n\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2)\n            });\n          }\n\n          if (node.name === 'polygon') {\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.points;\n        } //  optionally convert circle\n\n\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [{\n            command: 'M',\n            args: [cx, cy - r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy + r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy - r]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        } // optionally covert ellipse\n\n\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n\n          const pathData = [{\n            command: 'M',\n            args: [ecx, ecy - ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy + ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy - ry]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/convertShapeToPath.js"],"names":["stringifyPathData","require","detachNodeFromParent","exports","name","type","active","description","regNumber","fn","root","params","convertArcs","floatPrecision","precision","element","enter","node","parentNode","attributes","width","height","rx","ry","x","Number","y","isNaN","pathData","command","args","d","x1","y1","x2","y2","points","coords","match","map","length","i","push","slice","cx","cy","r","ecx","ecy"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { stringifyPathData } = require('../lib/path.js');\nconst { detachNodeFromParent } = require('../lib/xast.js');\n\nexports.name = 'convertShapeToPath';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'converts basic shapes to more compact path form';\n\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   convertArcs?: boolean,\n *   floatPrecision?: number\n * }>}\n */\nexports.fn = (root, params) => {\n  const { convertArcs = false, floatPrecision: precision } = params;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (\n          node.name === 'rect' &&\n          node.attributes.width != null &&\n          node.attributes.height != null &&\n          node.attributes.rx == null &&\n          node.attributes.ry == null\n        ) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x, y] },\n            { command: 'H', args: [x + width] },\n            { command: 'V', args: [y + height] },\n            { command: 'H', args: [x] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [x1, y1] },\n            { command: 'L', args: [x2, y2] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if (\n          (node.name === 'polyline' || node.name === 'polygon') &&\n          node.attributes.points != null\n        ) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(\n            Number\n          );\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2),\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({ command: 'z', args: [] });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [cx, cy - r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },\n            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally covert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const pathData = [\n            { command: 'M', args: [ecx, ecy - ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },\n            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },\n            { command: 'z', args: [] },\n          ];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({ pathData, precision });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}