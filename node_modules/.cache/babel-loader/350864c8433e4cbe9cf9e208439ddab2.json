{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst fsReadFileAsync = fs.promises.readFile;\n\nfunction getDefaultSearchPlaces(name) {\n  return ['package.json', `.${name}rc.json`, `.${name}rc.js`, `${name}.config.js`, `.${name}rc.cjs`, `${name}.config.cjs`];\n}\n\nfunction getSearchPaths(startDir, stopDir) {\n  return startDir.split(path.sep).reduceRight((acc, _, ind, arr) => {\n    const currentPath = arr.slice(0, ind + 1).join(path.sep);\n    if (!acc.passedStopDir) acc.searchPlaces.push(currentPath || path.sep);\n    if (currentPath === stopDir) acc.passedStopDir = true;\n    return acc;\n  }, {\n    searchPlaces: [],\n    passedStopDir: false\n  }).searchPlaces;\n}\n\nexports.defaultLoaders = Object.freeze({\n  '.js': require,\n  '.json': require,\n  '.cjs': require,\n\n  noExt(_, content) {\n    return JSON.parse(content);\n  }\n\n});\n\nfunction getExtDesc(ext) {\n  return ext === 'noExt' ? 'files without extensions' : `extension \"${ext}\"`;\n}\n\nfunction getOptions(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const conf = {\n    stopDir: os.homedir(),\n    searchPlaces: getDefaultSearchPlaces(name),\n    ignoreEmptySearchPlaces: true,\n    transform: x => x,\n    packageProp: [name],\n    ...options,\n    loaders: { ...exports.defaultLoaders,\n      ...options.loaders\n    }\n  };\n  conf.searchPlaces.forEach(place => {\n    const key = path.extname(place) || 'noExt';\n    const loader = conf.loaders[key];\n\n    if (!loader) {\n      throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item \"${place}\" is invalid`);\n    }\n\n    if (typeof loader !== 'function') {\n      throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n    }\n  });\n  return conf;\n}\n\nfunction getPackageProp(props, obj) {\n  if (typeof props === 'string' && props in obj) return obj[props];\n  return (Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => acc === undefined ? acc : acc[prop], obj) || null;\n}\n\nfunction getSearchItems(searchPlaces, searchPaths) {\n  return searchPaths.reduce((acc, searchPath) => {\n    searchPlaces.forEach(fileName => acc.push({\n      fileName,\n      filepath: path.join(searchPath, fileName),\n      loaderKey: path.extname(fileName) || 'noExt'\n    }));\n    return acc;\n  }, []);\n}\n\nfunction validateFilePath(filepath) {\n  if (!filepath) throw new Error('load must pass a non-empty string');\n}\n\nfunction validateLoader(loader, ext) {\n  if (!loader) throw new Error(`No loader specified for extension \"${ext}\"`);\n  if (typeof loader !== 'function') throw new Error('loader is not a function');\n}\n\nfunction lilconfig(name, options) {\n  const {\n    ignoreEmptySearchPlaces,\n    loaders,\n    packageProp,\n    searchPlaces,\n    stopDir,\n    transform\n  } = getOptions(name, options);\n  return {\n    async search() {\n      let searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n      const searchPaths = getSearchPaths(searchFrom, stopDir);\n      const result = {\n        config: null,\n        filepath: ''\n      };\n      const searchItems = getSearchItems(searchPlaces, searchPaths);\n\n      for (const {\n        fileName,\n        filepath,\n        loaderKey\n      } of searchItems) {\n        try {\n          await fs.promises.access(filepath);\n        } catch (_a) {\n          continue;\n        }\n\n        const content = String(await fsReadFileAsync(filepath));\n        const loader = loaders[loaderKey];\n\n        if (fileName === 'package.json') {\n          const pkg = loader(filepath, content);\n          const maybeConfig = getPackageProp(packageProp, pkg);\n\n          if (maybeConfig != null) {\n            result.config = maybeConfig;\n            result.filepath = filepath;\n            break;\n          }\n\n          continue;\n        }\n\n        const isEmpty = content.trim() === '';\n        if (isEmpty && ignoreEmptySearchPlaces) continue;\n\n        if (isEmpty) {\n          result.isEmpty = true;\n          result.config = undefined;\n        } else {\n          validateLoader(loader, loaderKey);\n          result.config = loader(filepath, content);\n        }\n\n        result.filepath = filepath;\n        break;\n      }\n\n      if (result.filepath === '' && result.config === null) return transform(null);\n      return transform(result);\n    },\n\n    async load(filepath) {\n      validateFilePath(filepath);\n      const absPath = path.resolve(process.cwd(), filepath);\n      const {\n        base,\n        ext\n      } = path.parse(absPath);\n      const loaderKey = ext || 'noExt';\n      const loader = loaders[loaderKey];\n      validateLoader(loader, loaderKey);\n      const content = String(await fsReadFileAsync(absPath));\n\n      if (base === 'package.json') {\n        const pkg = await loader(absPath, content);\n        return transform({\n          config: getPackageProp(packageProp, pkg),\n          filepath: absPath\n        });\n      }\n\n      const result = {\n        config: null,\n        filepath: absPath\n      };\n      const isEmpty = content.trim() === '';\n      if (isEmpty && ignoreEmptySearchPlaces) return transform({\n        config: undefined,\n        filepath: absPath,\n        isEmpty: true\n      });\n      result.config = isEmpty ? undefined : await loader(absPath, content);\n      return transform(isEmpty ? { ...result,\n        isEmpty,\n        config: undefined\n      } : result);\n    }\n\n  };\n}\n\nexports.lilconfig = lilconfig;\n\nfunction lilconfigSync(name, options) {\n  const {\n    ignoreEmptySearchPlaces,\n    loaders,\n    packageProp,\n    searchPlaces,\n    stopDir,\n    transform\n  } = getOptions(name, options);\n  return {\n    search() {\n      let searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n      const searchPaths = getSearchPaths(searchFrom, stopDir);\n      const result = {\n        config: null,\n        filepath: ''\n      };\n      const searchItems = getSearchItems(searchPlaces, searchPaths);\n\n      for (const {\n        fileName,\n        filepath,\n        loaderKey\n      } of searchItems) {\n        try {\n          fs.accessSync(filepath);\n        } catch (_a) {\n          continue;\n        }\n\n        const loader = loaders[loaderKey];\n        const content = String(fs.readFileSync(filepath));\n\n        if (fileName === 'package.json') {\n          const pkg = loader(filepath, content);\n          const maybeConfig = getPackageProp(packageProp, pkg);\n\n          if (maybeConfig != null) {\n            result.config = maybeConfig;\n            result.filepath = filepath;\n            break;\n          }\n\n          continue;\n        }\n\n        const isEmpty = content.trim() === '';\n        if (isEmpty && ignoreEmptySearchPlaces) continue;\n\n        if (isEmpty) {\n          result.isEmpty = true;\n          result.config = undefined;\n        } else {\n          validateLoader(loader, loaderKey);\n          result.config = loader(filepath, content);\n        }\n\n        result.filepath = filepath;\n        break;\n      }\n\n      if (result.filepath === '' && result.config === null) return transform(null);\n      return transform(result);\n    },\n\n    load(filepath) {\n      validateFilePath(filepath);\n      const absPath = path.resolve(process.cwd(), filepath);\n      const {\n        base,\n        ext\n      } = path.parse(absPath);\n      const loaderKey = ext || 'noExt';\n      const loader = loaders[loaderKey];\n      validateLoader(loader, loaderKey);\n      const content = String(fs.readFileSync(absPath));\n\n      if (base === 'package.json') {\n        const pkg = loader(absPath, content);\n        return transform({\n          config: getPackageProp(packageProp, pkg),\n          filepath: absPath\n        });\n      }\n\n      const result = {\n        config: null,\n        filepath: absPath\n      };\n      const isEmpty = content.trim() === '';\n      if (isEmpty && ignoreEmptySearchPlaces) return transform({\n        filepath: absPath,\n        config: undefined,\n        isEmpty: true\n      });\n      result.config = isEmpty ? undefined : loader(absPath, content);\n      return transform(isEmpty ? { ...result,\n        isEmpty,\n        config: undefined\n      } : result);\n    }\n\n  };\n}\n\nexports.lilconfigSync = lilconfigSync;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/lilconfig/dist/index.js"],"names":["Object","defineProperty","exports","value","lilconfigSync","lilconfig","defaultLoaders","path","require","fs","os","fsReadFileAsync","promises","readFile","getDefaultSearchPlaces","name","getSearchPaths","startDir","stopDir","split","sep","reduceRight","acc","_","ind","arr","currentPath","slice","join","passedStopDir","searchPlaces","push","freeze","noExt","content","JSON","parse","getExtDesc","ext","getOptions","options","conf","homedir","ignoreEmptySearchPlaces","transform","x","packageProp","loaders","forEach","place","key","extname","loader","Error","getPackageProp","props","obj","Array","isArray","reduce","prop","undefined","getSearchItems","searchPaths","searchPath","fileName","filepath","loaderKey","validateFilePath","validateLoader","search","searchFrom","process","cwd","result","config","searchItems","access","_a","String","pkg","maybeConfig","isEmpty","trim","load","absPath","resolve","base","accessSync","readFileSync"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst fsReadFileAsync = fs.promises.readFile;\nfunction getDefaultSearchPlaces(name) {\n    return [\n        'package.json',\n        `.${name}rc.json`,\n        `.${name}rc.js`,\n        `${name}.config.js`,\n        `.${name}rc.cjs`,\n        `${name}.config.cjs`,\n    ];\n}\nfunction getSearchPaths(startDir, stopDir) {\n    return startDir\n        .split(path.sep)\n        .reduceRight((acc, _, ind, arr) => {\n        const currentPath = arr.slice(0, ind + 1).join(path.sep);\n        if (!acc.passedStopDir)\n            acc.searchPlaces.push(currentPath || path.sep);\n        if (currentPath === stopDir)\n            acc.passedStopDir = true;\n        return acc;\n    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;\n}\nexports.defaultLoaders = Object.freeze({\n    '.js': require,\n    '.json': require,\n    '.cjs': require,\n    noExt(_, content) {\n        return JSON.parse(content);\n    },\n});\nfunction getExtDesc(ext) {\n    return ext === 'noExt' ? 'files without extensions' : `extension \"${ext}\"`;\n}\nfunction getOptions(name, options = {}) {\n    const conf = {\n        stopDir: os.homedir(),\n        searchPlaces: getDefaultSearchPlaces(name),\n        ignoreEmptySearchPlaces: true,\n        transform: (x) => x,\n        packageProp: [name],\n        ...options,\n        loaders: { ...exports.defaultLoaders, ...options.loaders },\n    };\n    conf.searchPlaces.forEach(place => {\n        const key = path.extname(place) || 'noExt';\n        const loader = conf.loaders[key];\n        if (!loader) {\n            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item \"${place}\" is invalid`);\n        }\n        if (typeof loader !== 'function') {\n            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n        }\n    });\n    return conf;\n}\nfunction getPackageProp(props, obj) {\n    if (typeof props === 'string' && props in obj)\n        return obj[props];\n    return ((Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => (acc === undefined ? acc : acc[prop]), obj) || null);\n}\nfunction getSearchItems(searchPlaces, searchPaths) {\n    return searchPaths.reduce((acc, searchPath) => {\n        searchPlaces.forEach(fileName => acc.push({\n            fileName,\n            filepath: path.join(searchPath, fileName),\n            loaderKey: path.extname(fileName) || 'noExt',\n        }));\n        return acc;\n    }, []);\n}\nfunction validateFilePath(filepath) {\n    if (!filepath)\n        throw new Error('load must pass a non-empty string');\n}\nfunction validateLoader(loader, ext) {\n    if (!loader)\n        throw new Error(`No loader specified for extension \"${ext}\"`);\n    if (typeof loader !== 'function')\n        throw new Error('loader is not a function');\n}\nfunction lilconfig(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        async search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { fileName, filepath, loaderKey } of searchItems) {\n                try {\n                    await fs.promises.access(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const content = String(await fsReadFileAsync(filepath));\n                const loader = loaders[loaderKey];\n                if (fileName === 'package.json') {\n                    const pkg = loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        async load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(await fsReadFileAsync(absPath));\n            if (base === 'package.json') {\n                const pkg = await loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    config: undefined,\n                    filepath: absPath,\n                    isEmpty: true,\n                });\n            result.config = isEmpty\n                ? undefined\n                : await loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfig = lilconfig;\nfunction lilconfigSync(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { fileName, filepath, loaderKey } of searchItems) {\n                try {\n                    fs.accessSync(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const loader = loaders[loaderKey];\n                const content = String(fs.readFileSync(filepath));\n                if (fileName === 'package.json') {\n                    const pkg = loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(fs.readFileSync(absPath));\n            if (base === 'package.json') {\n                const pkg = loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    filepath: absPath,\n                    config: undefined,\n                    isEmpty: true,\n                });\n            result.config = isEmpty ? undefined : loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfigSync = lilconfigSync;\n"]},"metadata":{},"sourceType":"script"}