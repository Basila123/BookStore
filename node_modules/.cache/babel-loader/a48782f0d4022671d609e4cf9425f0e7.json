{"ast":null,"code":"'use strict';\n\nconst {\n  list\n} = require('postcss');\n\nconst stylehacks = require('stylehacks');\n\nconst insertCloned = require('../insertCloned');\n\nconst parseTrbl = require('../parseTrbl');\n\nconst hasAllProps = require('../hasAllProps');\n\nconst getDecls = require('../getDecls');\n\nconst getRules = require('../getRules');\n\nconst getValue = require('../getValue');\n\nconst mergeRules = require('../mergeRules');\n\nconst minifyTrbl = require('../minifyTrbl');\n\nconst minifyWsc = require('../minifyWsc');\n\nconst canMerge = require('../canMerge');\n\nconst remove = require('../remove');\n\nconst trbl = require('../trbl');\n\nconst isCustomProp = require('../isCustomProp');\n\nconst canExplode = require('../canExplode');\n\nconst getLastNode = require('../getLastNode');\n\nconst parseWsc = require('../parseWsc');\n\nconst {\n  isValidWsc\n} = require('../validateWsc');\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nfunction borderProperty() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n\n  return `border-${parts.join('-')}`;\n}\n\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = trbl.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\nconst directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);\nconst precedence = [['border'], directions.concat(properties), directionalProperties];\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (precedence[i].includes(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n\nconst isValueCustomProp = value => value && !!~value.search(/var\\s*\\(\\s*--/i);\n\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp);\n}\n\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return parseWsc(decl.value)[2] || defaults[2];\n}\n\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  }, []);\n}\n\nfunction mergeRedundant(_ref) {\n  let {\n    values,\n    nextValues,\n    decl,\n    nextDecl,\n    index\n  } = _ref;\n\n  if (!canMerge([decl, nextDecl])) {\n    return;\n  }\n\n  if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length !== 1) {\n    return;\n  }\n\n  const prop = diff.pop();\n  const position = wsc.indexOf(prop);\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n  let props = parseTrbl(values[position]);\n  props[index] = nextValues[position];\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = minifyTrbl(props);\n  const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value).length;\n  const newLength1 = decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n\nfunction isCloseEnough(mapped) {\n  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];\n}\n\nfunction getDistinctShorthands(mapped) {\n  return mapped.reduce((a, b) => {\n    a = Array.isArray(a) ? a : [a];\n\n    if (!a.includes(b)) {\n      a.push(b);\n    }\n\n    return a;\n  });\n}\n\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, decl => {\n    if (!canExplode(decl, false)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase(); // border -> border-trbl\n\n    if (prop === 'border') {\n      if (isValidWsc(parseWsc(decl.value))) {\n        directions.forEach(direction => {\n          insertCloned(decl.parent, decl, {\n            prop: direction\n          });\n        });\n        return decl.remove();\n      }\n    } // border-trbl -> border-trbl-wsc\n\n\n    if (directions.some(direction => prop === direction)) {\n      let values = parseWsc(decl.value);\n\n      if (isValidWsc(values)) {\n        wsc.forEach((d, i) => {\n          insertCloned(decl.parent, decl, {\n            prop: `${prop}-${d}`,\n            value: values[i] || defaults[i]\n          });\n        });\n        return decl.remove();\n      }\n    } // border-wsc -> border-trbl-wsc\n\n\n    wsc.some(style => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      parseTrbl(decl.value).forEach((value, i) => {\n        insertCloned(decl.parent, decl, {\n          prop: borderProperty(trbl[i], style),\n          value\n        });\n      });\n      return decl.remove();\n    });\n  });\n}\n\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  trbl.forEach(direction => {\n    const prop = borderProperty(direction);\n    mergeRules(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop,\n          value: rules.map(getValue).join(' ')\n        });\n        rules.forEach(remove);\n        return true;\n      }\n    });\n  }); // border-trbl-wsc -> border-wsc\n\n  wsc.forEach(style => {\n    const prop = borderProperty(style);\n    mergeRules(rule, trbl.map(direction => borderProperty(direction, style)), (rules, lastNode) => {\n      if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop,\n          value: minifyTrbl(rules.map(getValue).join(' '))\n        });\n        rules.forEach(remove);\n        return true;\n      }\n    });\n  }); // border-trbl -> border-wsc\n\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(_ref2 => {\n      let {\n        value\n      } = _ref2;\n      return value;\n    });\n\n    if (!canMergeValues(values)) {\n      return;\n    }\n\n    const parsed = values.map(value => parseWsc(value));\n\n    if (!parsed.every(isValidWsc)) {\n      return;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map(v => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop: borderProperty(d),\n          value: minifyTrbl(value)\n        });\n      } else {\n        insertCloned(lastNode.parent, lastNode);\n      }\n    });\n    rules.forEach(remove);\n    return true;\n  }); // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n\n    if (!canMergeValues(mapped)) {\n      return;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && canMerge(rules, false)) {\n      const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n      const border = insertCloned(lastNode.parent, lastNode, {\n        prop: 'border',\n        value: first ? reduced[0] : reduced[1]\n      });\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(trbl[mapped.indexOf(value)]);\n        rule.insertAfter(border, Object.assign(lastNode.clone(), {\n          prop,\n          value\n        }));\n      }\n\n      rules.forEach(remove);\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(color, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: [width, style].map(getValue).join(' ')\n      }));\n      rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(remove);\n      return true;\n    }\n  }); // border-wsc -> border + border-trbl\n\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter(p => p !== none);\n      const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: borderValue\n      }));\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n            prop: dir,\n            value: mapped[i]\n          }));\n        }\n      });\n      rules.forEach(remove);\n      return true;\n    }\n  }); // border-trbl -> border\n  // border-trbl -> border + border-trbl\n\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(node => {\n      const wscValue = parseWsc(node.value);\n\n      if (!isValidWsc(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: minifyWsc(first ? values[0] : values[1])\n      }));\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n          prop: prop,\n          value: minifyWsc(value)\n        }));\n      }\n\n      rules.forEach(remove);\n      return true;\n    }\n  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n\n  directions.forEach(direction => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n      mergeRules(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return;\n        }\n\n        const values = parseWsc(lastNode.value);\n\n        if (!isValidWsc(values)) {\n          return;\n        }\n\n        const wscProp = rules.filter(r => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n          return;\n        }\n\n        const wscValue = values[i];\n        values[i] = wscProp.value;\n\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: wscValue\n          });\n          lastNode.value = minifyWsc(values);\n          wscProp.remove();\n          return true;\n        }\n      });\n    });\n  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    mergeRules(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return;\n      }\n\n      const values = parseWsc(lastNode.value);\n\n      if (!isValidWsc(values)) {\n        return;\n      }\n\n      const wscProp = rules.filter(r => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n        return;\n      }\n\n      const wscValue = values[i];\n      values[i] = wscProp.value;\n\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop,\n          value: wscValue\n        });\n        lastNode.value = minifyWsc(values);\n        wscProp.remove();\n        return true;\n      }\n    });\n  }); // optimize border-trbl\n\n  let decls = getDecls(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    wsc.forEach((d, i) => {\n      const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n      const border = getLastNode(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(node => node.prop && names.includes(node.prop) && node.important === lastNode.important);\n      const rules = getRules(props, names);\n\n      if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {\n        const values = rules.map(node => node ? node.value : null);\n        const filteredValues = values.filter(Boolean);\n        const lastNodeValue = list.space(lastNode.value)[i];\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n        let value = minifyTrbl(values.join(' '));\n\n        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {\n          value = filteredValues[0];\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n          let valueArray = list.space(lastNode.value);\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        insertCloned(refNode.parent, refNode, {\n          prop: borderProperty(d),\n          value\n        });\n        decls = decls.filter(node => !rules.includes(node));\n        rules.forEach(remove);\n      }\n    });\n    decls = decls.filter(node => node !== lastNode);\n  }\n\n  rule.walkDecls('border', decl => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (!~index) {\n      return;\n    }\n\n    const values = parseWsc(decl.value);\n    const nextValues = parseWsc(nextDecl.value);\n\n    if (!isValidWsc(values) || !isValidWsc(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index\n    };\n    return mergeRedundant(config);\n  });\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    let values = parseWsc(decl.value);\n\n    if (!isValidWsc(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map(dir => `${dir}-${d}`);\n      mergeRules(rule, [decl.prop, ...props], rules => {\n        if (!rules.includes(decl)) {\n          return;\n        }\n\n        const longhands = rules.filter(p => p !== decl);\n\n        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && values[i] !== undefined && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {\n          longhands.forEach(remove);\n          insertCloned(decl.parent, decl, {\n            prop: borderProperty(d),\n            value: values[i]\n          });\n          values[i] = null;\n        }\n      });\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  }); // clean-up values\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    decl.value = minifyWsc(decl.value);\n  }); // border-spacing-hv -> border-spacing\n\n  rule.walkDecls(/^border-spacing$/i, decl => {\n    const value = list.space(decl.value); // merge vertical and horizontal dups\n\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  }); // clean-up rules\n\n  decls = getDecls(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence\n\n    const lesser = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && !isCustomProp(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (node.prop.toLowerCase().includes(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));\n    lesser.forEach(remove);\n    decls = decls.filter(node => !lesser.includes(node)); // get duplicate properties\n\n    let duplicates = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode)));\n\n    if (duplicates.length) {\n      if (/hsla\\(|rgba\\(/i.test(getColorValue(lastNode))) {\n        const preserve = duplicates.filter(node => !/hsla\\(|rgba\\(/i.test(getColorValue(node))).pop();\n        duplicates = duplicates.filter(node => node !== preserve);\n      }\n\n      duplicates.forEach(remove);\n    }\n\n    decls = decls.filter(node => node !== lastNode && !duplicates.includes(node));\n  }\n}\n\nmodule.exports = {\n  explode,\n  merge\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-merge-longhand/src/lib/decl/borders.js"],"names":["list","require","stylehacks","insertCloned","parseTrbl","hasAllProps","getDecls","getRules","getValue","mergeRules","minifyTrbl","minifyWsc","canMerge","remove","trbl","isCustomProp","canExplode","getLastNode","parseWsc","isValidWsc","wsc","defaults","borderProperty","parts","join","mapBorderProperty","value","directions","map","properties","directionalProperties","reduce","prev","curr","concat","prop","precedence","allProperties","a","b","getLevel","i","length","includes","toLowerCase","isValueCustomProp","search","canMergeValues","values","some","getColorValue","decl","substr","diffingProps","nextValues","mergeRedundant","nextDecl","index","detect","diff","pop","position","indexOf","prop1","prop2","props","borderValue2","filter","e","propValue2","origLength","newLength1","newLength2","isCloseEnough","mapped","getDistinctShorthands","Array","isArray","push","explode","rule","walkDecls","forEach","direction","parent","d","style","merge","rules","lastNode","parsed","every","v","node","width","color","reduced","first","lastIndexOf","border","insertAfter","Object","assign","clone","insertBefore","none","filtered","p","mostCommon","sort","borderValue","dir","wscValue","wscProp","r","decls","names","name","nodes","slice","important","filteredValues","Boolean","lastNodeValue","space","refNode","valueArray","splice","next","type","config","dirs","longhands","undefined","newValue","lastPart","split","lesser","endsWith","duplicates","test","preserve","module","exports"],"mappings":"AAAA;;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMM,QAAQ,GAAGN,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMS,UAAU,GAAGT,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMU,SAAS,GAAGV,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMW,QAAQ,GAAGX,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMY,MAAM,GAAGZ,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMa,IAAI,GAAGb,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMc,YAAY,GAAGd,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMe,UAAU,GAAGf,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMgB,WAAW,GAAGhB,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMiB,QAAQ,GAAGjB,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAM;AAAEkB,EAAAA;AAAF,IAAiBlB,OAAO,CAAC,gBAAD,CAA9B;;AAEA,MAAMmB,GAAG,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,CAAZ;AACA,MAAMC,QAAQ,GAAG,CAAC,QAAD,EAAW,MAAX,EAAmB,cAAnB,CAAjB;;AAEA,SAASC,cAAT,GAAkC;AAAA,oCAAPC,KAAO;AAAPA,IAAAA,KAAO;AAAA;;AAChC,SAAQ,UAASA,KAAK,CAACC,IAAN,CAAW,GAAX,CAAgB,EAAjC;AACD;;AAED,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAChC,SAAOJ,cAAc,CAACI,KAAD,CAArB;AACD;;AAED,MAAMC,UAAU,GAAGb,IAAI,CAACc,GAAL,CAASH,iBAAT,CAAnB;AACA,MAAMI,UAAU,GAAGT,GAAG,CAACQ,GAAJ,CAAQH,iBAAR,CAAnB;AACA,MAAMK,qBAAqB,GAAGH,UAAU,CAACI,MAAX,CAC5B,CAACC,IAAD,EAAOC,IAAP,KAAgBD,IAAI,CAACE,MAAL,CAAYd,GAAG,CAACQ,GAAJ,CAASO,IAAD,IAAW,GAAEF,IAAK,IAAGE,IAAK,EAAlC,CAAZ,CADY,EAE5B,EAF4B,CAA9B;AAKA,MAAMC,UAAU,GAAG,CACjB,CAAC,QAAD,CADiB,EAEjBT,UAAU,CAACO,MAAX,CAAkBL,UAAlB,CAFiB,EAGjBC,qBAHiB,CAAnB;AAMA,MAAMO,aAAa,GAAGD,UAAU,CAACL,MAAX,CAAkB,CAACO,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACJ,MAAF,CAASK,CAAT,CAA5B,CAAtB;;AAEA,SAASC,QAAT,CAAkBL,IAAlB,EAAwB;AACtB,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,UAAU,CAACM,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QAAIL,UAAU,CAACK,CAAD,CAAV,CAAcE,QAAd,CAAuBR,IAAI,CAACS,WAAL,EAAvB,CAAJ,EAAgD;AAC9C,aAAOH,CAAP;AACD;AACF;AACF;;AAED,MAAMI,iBAAiB,GAAInB,KAAD,IAAWA,KAAK,IAAI,CAAC,CAAC,CAACA,KAAK,CAACoB,MAAN,CAAa,gBAAb,CAAjD;;AAEA,SAASC,cAAT,CAAwBC,MAAxB,EAAgC;AAC9B,SAAO,CAACA,MAAM,CAACC,IAAP,CAAYJ,iBAAZ,CAAR;AACD;;AAED,SAASK,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,MAAIA,IAAI,CAAChB,IAAL,CAAUiB,MAAV,CAAiB,CAAC,CAAlB,MAAyB,OAA7B,EAAsC;AACpC,WAAOD,IAAI,CAACzB,KAAZ;AACD;;AAED,SAAOR,QAAQ,CAACiC,IAAI,CAACzB,KAAN,CAAR,CAAqB,CAArB,KAA2BL,QAAQ,CAAC,CAAD,CAA1C;AACD;;AAED,SAASgC,YAAT,CAAsBL,MAAtB,EAA8BM,UAA9B,EAA0C;AACxC,SAAOlC,GAAG,CAACW,MAAJ,CAAW,CAACC,IAAD,EAAOC,IAAP,EAAaQ,CAAb,KAAmB;AACnC,QAAIO,MAAM,CAACP,CAAD,CAAN,KAAca,UAAU,CAACb,CAAD,CAA5B,EAAiC;AAC/B,aAAOT,IAAP;AACD;;AAED,WAAO,CAAC,GAAGA,IAAJ,EAAUC,IAAV,CAAP;AACD,GANM,EAMJ,EANI,CAAP;AAOD;;AAED,SAASsB,cAAT,OAAuE;AAAA,MAA/C;AAAEP,IAAAA,MAAF;AAAUM,IAAAA,UAAV;AAAsBH,IAAAA,IAAtB;AAA4BK,IAAAA,QAA5B;AAAsCC,IAAAA;AAAtC,GAA+C;;AACrE,MAAI,CAAC7C,QAAQ,CAAC,CAACuC,IAAD,EAAOK,QAAP,CAAD,CAAb,EAAiC;AAC/B;AACD;;AAED,MAAItD,UAAU,CAACwD,MAAX,CAAkBP,IAAlB,KAA2BjD,UAAU,CAACwD,MAAX,CAAkBF,QAAlB,CAA/B,EAA4D;AAC1D;AACD;;AAED,QAAMG,IAAI,GAAGN,YAAY,CAACL,MAAD,EAASM,UAAT,CAAzB;;AAEA,MAAIK,IAAI,CAACjB,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACD;;AAED,QAAMP,IAAI,GAAGwB,IAAI,CAACC,GAAL,EAAb;AACA,QAAMC,QAAQ,GAAGzC,GAAG,CAAC0C,OAAJ,CAAY3B,IAAZ,CAAjB;AAEA,QAAM4B,KAAK,GAAI,GAAEP,QAAQ,CAACrB,IAAK,IAAGA,IAAK,EAAvC;AACA,QAAM6B,KAAK,GAAI,UAAS7B,IAAK,EAA7B;AAEA,MAAI8B,KAAK,GAAG7D,SAAS,CAAC4C,MAAM,CAACa,QAAD,CAAP,CAArB;AAEAI,EAAAA,KAAK,CAACR,KAAD,CAAL,GAAeH,UAAU,CAACO,QAAD,CAAzB;AAEA,QAAMK,YAAY,GAAGlB,MAAM,CAACmB,MAAP,CAAc,CAACC,CAAD,EAAI3B,CAAJ,KAAUA,CAAC,KAAKoB,QAA9B,EAAwCrC,IAAxC,CAA6C,GAA7C,CAArB;AACA,QAAM6C,UAAU,GAAG3D,UAAU,CAACuD,KAAD,CAA7B;AAEA,QAAMK,UAAU,GAAG,CAAC3D,SAAS,CAACwC,IAAI,CAACzB,KAAN,CAAT,GAAwB8B,QAAQ,CAACrB,IAAjC,GAAwCqB,QAAQ,CAAC9B,KAAlD,EAChBgB,MADH;AAEA,QAAM6B,UAAU,GACdpB,IAAI,CAACzB,KAAL,CAAWgB,MAAX,GAAoBqB,KAAK,CAACrB,MAA1B,GAAmC/B,SAAS,CAAC2C,UAAU,CAACO,QAAD,CAAX,CAAT,CAAgCnB,MADrE;AAEA,QAAM8B,UAAU,GAAGN,YAAY,CAACxB,MAAb,GAAsBsB,KAAK,CAACtB,MAA5B,GAAqC2B,UAAU,CAAC3B,MAAnE;;AAEA,MAAI6B,UAAU,GAAGC,UAAb,IAA2BD,UAAU,GAAGD,UAA5C,EAAwD;AACtDd,IAAAA,QAAQ,CAACrB,IAAT,GAAgB4B,KAAhB;AACAP,IAAAA,QAAQ,CAAC9B,KAAT,GAAiB4B,UAAU,CAACO,QAAD,CAA3B;AACD;;AAED,MAAIW,UAAU,GAAGD,UAAb,IAA2BC,UAAU,GAAGF,UAA5C,EAAwD;AACtDnB,IAAAA,IAAI,CAACzB,KAAL,GAAawC,YAAb;AACAV,IAAAA,QAAQ,CAACrB,IAAT,GAAgB6B,KAAhB;AACAR,IAAAA,QAAQ,CAAC9B,KAAT,GAAiB2C,UAAjB;AACD;AACF;;AAED,SAASI,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,SACGA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAApB,IAA2BA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAAhD,IACCA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAApB,IAA2BA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CADhD,IAECA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAApB,IAA2BA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAFhD,IAGCA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAApB,IAA2BA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAJlD;AAMD;;AAED,SAASC,qBAAT,CAA+BD,MAA/B,EAAuC;AACrC,SAAOA,MAAM,CAAC3C,MAAP,CAAc,CAACO,CAAD,EAAIC,CAAJ,KAAU;AAC7BD,IAAAA,CAAC,GAAGsC,KAAK,CAACC,OAAN,CAAcvC,CAAd,IAAmBA,CAAnB,GAAuB,CAACA,CAAD,CAA3B;;AAEA,QAAI,CAACA,CAAC,CAACK,QAAF,CAAWJ,CAAX,CAAL,EAAoB;AAClBD,MAAAA,CAAC,CAACwC,IAAF,CAAOvC,CAAP;AACD;;AAED,WAAOD,CAAP;AACD,GARM,CAAP;AASD;;AAED,SAASyC,OAAT,CAAiBC,IAAjB,EAAuB;AACrBA,EAAAA,IAAI,CAACC,SAAL,CAAe,UAAf,EAA4B9B,IAAD,IAAU;AACnC,QAAI,CAACnC,UAAU,CAACmC,IAAD,EAAO,KAAP,CAAf,EAA8B;AAC5B;AACD;;AAED,QAAIjD,UAAU,CAACwD,MAAX,CAAkBP,IAAlB,CAAJ,EAA6B;AAC3B;AACD;;AAED,UAAMhB,IAAI,GAAGgB,IAAI,CAAChB,IAAL,CAAUS,WAAV,EAAb,CATmC,CAWnC;;AACA,QAAIT,IAAI,KAAK,QAAb,EAAuB;AACrB,UAAIhB,UAAU,CAACD,QAAQ,CAACiC,IAAI,CAACzB,KAAN,CAAT,CAAd,EAAsC;AACpCC,QAAAA,UAAU,CAACuD,OAAX,CAAoBC,SAAD,IAAe;AAChChF,UAAAA,YAAY,CAACgD,IAAI,CAACiC,MAAN,EAAcjC,IAAd,EAAoB;AAAEhB,YAAAA,IAAI,EAAEgD;AAAR,WAApB,CAAZ;AACD,SAFD;AAIA,eAAOhC,IAAI,CAACtC,MAAL,EAAP;AACD;AACF,KApBkC,CAsBnC;;;AACA,QAAIc,UAAU,CAACsB,IAAX,CAAiBkC,SAAD,IAAehD,IAAI,KAAKgD,SAAxC,CAAJ,EAAwD;AACtD,UAAInC,MAAM,GAAG9B,QAAQ,CAACiC,IAAI,CAACzB,KAAN,CAArB;;AAEA,UAAIP,UAAU,CAAC6B,MAAD,CAAd,EAAwB;AACtB5B,QAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACG,CAAD,EAAI5C,CAAJ,KAAU;AACpBtC,UAAAA,YAAY,CAACgD,IAAI,CAACiC,MAAN,EAAcjC,IAAd,EAAoB;AAC9BhB,YAAAA,IAAI,EAAG,GAAEA,IAAK,IAAGkD,CAAE,EADW;AAE9B3D,YAAAA,KAAK,EAAEsB,MAAM,CAACP,CAAD,CAAN,IAAapB,QAAQ,CAACoB,CAAD;AAFE,WAApB,CAAZ;AAID,SALD;AAOA,eAAOU,IAAI,CAACtC,MAAL,EAAP;AACD;AACF,KApCkC,CAsCnC;;;AACAO,IAAAA,GAAG,CAAC6B,IAAJ,CAAUqC,KAAD,IAAW;AAClB,UAAInD,IAAI,KAAKb,cAAc,CAACgE,KAAD,CAA3B,EAAoC;AAClC,eAAO,KAAP;AACD;;AAEDlF,MAAAA,SAAS,CAAC+C,IAAI,CAACzB,KAAN,CAAT,CAAsBwD,OAAtB,CAA8B,CAACxD,KAAD,EAAQe,CAAR,KAAc;AAC1CtC,QAAAA,YAAY,CAACgD,IAAI,CAACiC,MAAN,EAAcjC,IAAd,EAAoB;AAC9BhB,UAAAA,IAAI,EAAEb,cAAc,CAACR,IAAI,CAAC2B,CAAD,CAAL,EAAU6C,KAAV,CADU;AAE9B5D,UAAAA;AAF8B,SAApB,CAAZ;AAID,OALD;AAOA,aAAOyB,IAAI,CAACtC,MAAL,EAAP;AACD,KAbD;AAcD,GArDD;AAsDD;;AAED,SAAS0E,KAAT,CAAeP,IAAf,EAAqB;AACnB;AACAlE,EAAAA,IAAI,CAACoE,OAAL,CAAcC,SAAD,IAAe;AAC1B,UAAMhD,IAAI,GAAGb,cAAc,CAAC6D,SAAD,CAA3B;AAEA1E,IAAAA,UAAU,CACRuE,IADQ,EAER5D,GAAG,CAACQ,GAAJ,CAAS0D,KAAD,IAAWhE,cAAc,CAAC6D,SAAD,EAAYG,KAAZ,CAAjC,CAFQ,EAGR,CAACE,KAAD,EAAQC,QAAR,KAAqB;AACnB,UAAI7E,QAAQ,CAAC4E,KAAD,EAAQ,KAAR,CAAR,IAA0B,CAACA,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAA/B,EAA8D;AAC5DvD,QAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACtCtD,UAAAA,IADsC;AAEtCT,UAAAA,KAAK,EAAE8D,KAAK,CAAC5D,GAAN,CAAUpB,QAAV,EAAoBgB,IAApB,CAAyB,GAAzB;AAF+B,SAA5B,CAAZ;AAKAgE,QAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,eAAO,IAAP;AACD;AACF,KAdO,CAAV;AAgBD,GAnBD,EAFmB,CAuBnB;;AACAO,EAAAA,GAAG,CAAC8D,OAAJ,CAAaI,KAAD,IAAW;AACrB,UAAMnD,IAAI,GAAGb,cAAc,CAACgE,KAAD,CAA3B;AAEA7E,IAAAA,UAAU,CACRuE,IADQ,EAERlE,IAAI,CAACc,GAAL,CAAUuD,SAAD,IAAe7D,cAAc,CAAC6D,SAAD,EAAYG,KAAZ,CAAtC,CAFQ,EAGR,CAACE,KAAD,EAAQC,QAAR,KAAqB;AACnB,UAAI7E,QAAQ,CAAC4E,KAAD,CAAR,IAAmB,CAACA,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAAxB,EAAuD;AACrDvD,QAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACtCtD,UAAAA,IADsC;AAEtCT,UAAAA,KAAK,EAAEhB,UAAU,CAAC8E,KAAK,CAAC5D,GAAN,CAAUpB,QAAV,EAAoBgB,IAApB,CAAyB,GAAzB,CAAD;AAFqB,SAA5B,CAAZ;AAKAgE,QAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,eAAO,IAAP;AACD;AACF,KAdO,CAAV;AAgBD,GAnBD,EAxBmB,CA6CnB;;AACAJ,EAAAA,UAAU,CAACuE,IAAD,EAAOrD,UAAP,EAAmB,CAAC6D,KAAD,EAAQC,QAAR,KAAqB;AAChD,QAAID,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAAJ,EAAmC;AACjC;AACD;;AAED,UAAMV,MAAM,GAAGwC,KAAK,CAAC5D,GAAN,CAAU;AAAA,UAAC;AAAEF,QAAAA;AAAF,OAAD;AAAA,aAAeA,KAAf;AAAA,KAAV,CAAf;;AAEA,QAAI,CAACqB,cAAc,CAACC,MAAD,CAAnB,EAA6B;AAC3B;AACD;;AAED,UAAM0C,MAAM,GAAG1C,MAAM,CAACpB,GAAP,CAAYF,KAAD,IAAWR,QAAQ,CAACQ,KAAD,CAA9B,CAAf;;AAEA,QAAI,CAACgE,MAAM,CAACC,KAAP,CAAaxE,UAAb,CAAL,EAA+B;AAC7B;AACD;;AAEDC,IAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACG,CAAD,EAAI5C,CAAJ,KAAU;AACpB,YAAMf,KAAK,GAAGgE,MAAM,CAAC9D,GAAP,CAAYgE,CAAD,IAAOA,CAAC,CAACnD,CAAD,CAAD,IAAQpB,QAAQ,CAACoB,CAAD,CAAlC,CAAd;;AAEA,UAAIM,cAAc,CAACrB,KAAD,CAAlB,EAA2B;AACzBvB,QAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACtCtD,UAAAA,IAAI,EAAEb,cAAc,CAAC+D,CAAD,CADkB;AAEtC3D,UAAAA,KAAK,EAAEhB,UAAU,CAACgB,KAAD;AAFqB,SAA5B,CAAZ;AAID,OALD,MAKO;AACLvB,QAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,CAAZ;AACD;AACF,KAXD;AAaAD,IAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,WAAO,IAAP;AACD,GAjCS,CAAV,CA9CmB,CAiFnB;AACA;AACA;;AACAJ,EAAAA,UAAU,CAACuE,IAAD,EAAOnD,UAAP,EAAmB,CAAC2D,KAAD,EAAQC,QAAR,KAAqB;AAChD,QAAID,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAAJ,EAAmC;AACjC;AACD;;AAED,UAAMV,MAAM,GAAGwC,KAAK,CAAC5D,GAAN,CAAWiE,IAAD,IAAUzF,SAAS,CAACyF,IAAI,CAACnE,KAAN,CAA7B,CAAf;AACA,UAAMgD,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa9C,GAAb,CAAkBa,CAAD,IAC9B,CAACO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAAD,EAAeO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAAf,EAA6BO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAA7B,EAA2CjB,IAA3C,CAAgD,GAAhD,CADa,CAAf;;AAIA,QAAI,CAACuB,cAAc,CAAC2B,MAAD,CAAnB,EAA6B;AAC3B;AACD;;AAED,UAAM,CAACoB,KAAD,EAAQR,KAAR,EAAeS,KAAf,IAAwBP,KAA9B;AACA,UAAMQ,OAAO,GAAGrB,qBAAqB,CAACD,MAAD,CAArC;;AAEA,QAAID,aAAa,CAACC,MAAD,CAAb,IAAyB9D,QAAQ,CAAC4E,KAAD,EAAQ,KAAR,CAArC,EAAqD;AACnD,YAAMS,KAAK,GACTvB,MAAM,CAACZ,OAAP,CAAekC,OAAO,CAAC,CAAD,CAAtB,MAA+BtB,MAAM,CAACwB,WAAP,CAAmBF,OAAO,CAAC,CAAD,CAA1B,CADjC;AAGA,YAAMG,MAAM,GAAGhG,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACrDtD,QAAAA,IAAI,EAAE,QAD+C;AAErDT,QAAAA,KAAK,EAAEuE,KAAK,GAAGD,OAAO,CAAC,CAAD,CAAV,GAAgBA,OAAO,CAAC,CAAD;AAFkB,OAA5B,CAA3B;;AAKA,UAAIA,OAAO,CAAC,CAAD,CAAX,EAAgB;AACd,cAAMtE,KAAK,GAAGuE,KAAK,GAAGD,OAAO,CAAC,CAAD,CAAV,GAAgBA,OAAO,CAAC,CAAD,CAA1C;AACA,cAAM7D,IAAI,GAAGb,cAAc,CAACR,IAAI,CAAC4D,MAAM,CAACZ,OAAP,CAAepC,KAAf,CAAD,CAAL,CAA3B;AAEAsD,QAAAA,IAAI,CAACoB,WAAL,CACED,MADF,EAEEE,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,UAAAA,IAD8B;AAE9BT,UAAAA;AAF8B,SAAhC,CAFF;AAOD;;AACD8D,MAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,aAAO,IAAP;AACD,KAxBD,MAwBO,IAAImF,OAAO,CAACtD,MAAR,KAAmB,CAAvB,EAA0B;AAC/BsC,MAAAA,IAAI,CAACwB,YAAL,CACET,KADF,EAEEM,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,QAAAA,IAAI,EAAE,QADwB;AAE9BT,QAAAA,KAAK,EAAE,CAACoE,KAAD,EAAQR,KAAR,EAAe1D,GAAf,CAAmBpB,QAAnB,EAA6BgB,IAA7B,CAAkC,GAAlC;AAFuB,OAAhC,CAFF;AAOAgE,MAAAA,KAAK,CACFrB,MADH,CACW0B,IAAD,IAAUA,IAAI,CAAC1D,IAAL,CAAUS,WAAV,OAA4Bf,UAAU,CAAC,CAAD,CAD1D,EAEGqD,OAFH,CAEWrE,MAFX;AAIA,aAAO,IAAP;AACD;AACF,GAvDS,CAAV,CApFmB,CA6InB;;AACAJ,EAAAA,UAAU,CAACuE,IAAD,EAAOnD,UAAP,EAAmB,CAAC2D,KAAD,EAAQC,QAAR,KAAqB;AAChD,QAAID,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAAJ,EAAmC;AACjC;AACD;;AAED,UAAMV,MAAM,GAAGwC,KAAK,CAAC5D,GAAN,CAAWiE,IAAD,IAAUzF,SAAS,CAACyF,IAAI,CAACnE,KAAN,CAA7B,CAAf;AACA,UAAMgD,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa9C,GAAb,CAAkBa,CAAD,IAC9B,CAACO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAAD,EAAeO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAAf,EAA6BO,MAAM,CAAC,CAAD,CAAN,CAAUP,CAAV,CAA7B,EAA2CjB,IAA3C,CAAgD,GAAhD,CADa,CAAf;AAGA,UAAMwE,OAAO,GAAGrB,qBAAqB,CAACD,MAAD,CAArC;AACA,UAAM+B,IAAI,GAAG,0BAAb;;AAEA,QAAIT,OAAO,CAACtD,MAAR,GAAiB,CAAjB,IAAsBsD,OAAO,CAACtD,MAAR,GAAiB,CAAvC,IAA4CsD,OAAO,CAACrD,QAAR,CAAiB8D,IAAjB,CAAhD,EAAwE;AACtE,YAAMC,QAAQ,GAAGhC,MAAM,CAACP,MAAP,CAAewC,CAAD,IAAOA,CAAC,KAAKF,IAA3B,CAAjB;AACA,YAAMG,UAAU,GAAGZ,OAAO,CAACa,IAAR,CACjB,CAACvE,CAAD,EAAIC,CAAJ,KACEmC,MAAM,CAACP,MAAP,CAAeyB,CAAD,IAAOA,CAAC,KAAKrD,CAA3B,EAA8BG,MAA9B,GACAgC,MAAM,CAACP,MAAP,CAAeyB,CAAD,IAAOA,CAAC,KAAKtD,CAA3B,EAA8BI,MAHf,EAIjB,CAJiB,CAAnB;AAKA,YAAMoE,WAAW,GAAGd,OAAO,CAACtD,MAAR,KAAmB,CAAnB,GAAuBgE,QAAQ,CAAC,CAAD,CAA/B,GAAqCE,UAAzD;AAEA5B,MAAAA,IAAI,CAACwB,YAAL,CACEf,QADF,EAEEY,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,QAAAA,IAAI,EAAE,QADwB;AAE9BT,QAAAA,KAAK,EAAEoF;AAFuB,OAAhC,CAFF;AAQAnF,MAAAA,UAAU,CAACuD,OAAX,CAAmB,CAAC6B,GAAD,EAAMtE,CAAN,KAAY;AAC7B,YAAIiC,MAAM,CAACjC,CAAD,CAAN,KAAcqE,WAAlB,EAA+B;AAC7B9B,UAAAA,IAAI,CAACwB,YAAL,CACEf,QADF,EAEEY,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,YAAAA,IAAI,EAAE4E,GADwB;AAE9BrF,YAAAA,KAAK,EAAEgD,MAAM,CAACjC,CAAD;AAFiB,WAAhC,CAFF;AAOD;AACF,OAVD;AAYA+C,MAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,aAAO,IAAP;AACD;AACF,GA7CS,CAAV,CA9ImB,CA6LnB;AACA;;AACAJ,EAAAA,UAAU,CAACuE,IAAD,EAAOrD,UAAP,EAAmB,CAAC6D,KAAD,EAAQC,QAAR,KAAqB;AAChD,QAAID,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAAJ,EAAmC;AACjC;AACD;;AAED,UAAMV,MAAM,GAAGwC,KAAK,CAAC5D,GAAN,CAAWiE,IAAD,IAAU;AACjC,YAAMmB,QAAQ,GAAG9F,QAAQ,CAAC2E,IAAI,CAACnE,KAAN,CAAzB;;AAEA,UAAI,CAACP,UAAU,CAAC6F,QAAD,CAAf,EAA2B;AACzB,eAAOnB,IAAI,CAACnE,KAAZ;AACD;;AAED,aAAOsF,QAAQ,CAACpF,GAAT,CAAa,CAACF,KAAD,EAAQe,CAAR,KAAcf,KAAK,IAAIL,QAAQ,CAACoB,CAAD,CAA5C,EAAiDjB,IAAjD,CAAsD,GAAtD,CAAP;AACD,KARc,CAAf;AAUA,UAAMwE,OAAO,GAAGrB,qBAAqB,CAAC3B,MAAD,CAArC;;AAEA,QAAIyB,aAAa,CAACzB,MAAD,CAAjB,EAA2B;AACzB,YAAMiD,KAAK,GACTjD,MAAM,CAACc,OAAP,CAAekC,OAAO,CAAC,CAAD,CAAtB,MAA+BhD,MAAM,CAACkD,WAAP,CAAmBF,OAAO,CAAC,CAAD,CAA1B,CADjC;AAGAhB,MAAAA,IAAI,CAACwB,YAAL,CACEf,QADF,EAEEY,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,QAAAA,IAAI,EAAE,QADwB;AAE9BT,QAAAA,KAAK,EAAEf,SAAS,CAACsF,KAAK,GAAGjD,MAAM,CAAC,CAAD,CAAT,GAAeA,MAAM,CAAC,CAAD,CAA3B;AAFc,OAAhC,CAFF;;AAQA,UAAIgD,OAAO,CAAC,CAAD,CAAX,EAAgB;AACd,cAAMtE,KAAK,GAAGuE,KAAK,GAAGD,OAAO,CAAC,CAAD,CAAV,GAAgBA,OAAO,CAAC,CAAD,CAA1C;AACA,cAAM7D,IAAI,GAAGR,UAAU,CAACqB,MAAM,CAACc,OAAP,CAAepC,KAAf,CAAD,CAAvB;AACAsD,QAAAA,IAAI,CAACwB,YAAL,CACEf,QADF,EAEEY,MAAM,CAACC,MAAP,CAAcb,QAAQ,CAACc,KAAT,EAAd,EAAgC;AAC9BpE,UAAAA,IAAI,EAAEA,IADwB;AAE9BT,UAAAA,KAAK,EAAEf,SAAS,CAACe,KAAD;AAFc,SAAhC,CAFF;AAOD;;AAED8D,MAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AAEA,aAAO,IAAP;AACD;AACF,GA7CS,CAAV,CA/LmB,CA8OnB;;AACAc,EAAAA,UAAU,CAACuD,OAAX,CAAoBC,SAAD,IAAe;AAChC/D,IAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACI,KAAD,EAAQ7C,CAAR,KAAc;AACxB,YAAMN,IAAI,GAAI,GAAEgD,SAAU,IAAGG,KAAM,EAAnC;AAEA7E,MAAAA,UAAU,CAACuE,IAAD,EAAO,CAACG,SAAD,EAAYhD,IAAZ,CAAP,EAA0B,CAACqD,KAAD,EAAQC,QAAR,KAAqB;AACvD,YAAIA,QAAQ,CAACtD,IAAT,KAAkBgD,SAAtB,EAAiC;AAC/B;AACD;;AAED,cAAMnC,MAAM,GAAG9B,QAAQ,CAACuE,QAAQ,CAAC/D,KAAV,CAAvB;;AAEA,YAAI,CAACP,UAAU,CAAC6B,MAAD,CAAf,EAAyB;AACvB;AACD;;AAED,cAAMiE,OAAO,GAAGzB,KAAK,CAACrB,MAAN,CAAc+C,CAAD,IAAOA,CAAC,KAAKzB,QAA1B,EAAoC,CAApC,CAAhB;;AAEA,YAAI,CAAC5C,iBAAiB,CAACG,MAAM,CAACP,CAAD,CAAP,CAAlB,IAAiC1B,YAAY,CAACkG,OAAD,CAAjD,EAA4D;AAC1D;AACD;;AAED,cAAMD,QAAQ,GAAGhE,MAAM,CAACP,CAAD,CAAvB;AAEAO,QAAAA,MAAM,CAACP,CAAD,CAAN,GAAYwE,OAAO,CAACvF,KAApB;;AAEA,YAAId,QAAQ,CAAC4E,KAAD,EAAQ,KAAR,CAAR,IAA0B,CAACA,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAA/B,EAA8D;AAC5DvD,UAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACtCtD,YAAAA,IADsC;AAEtCT,YAAAA,KAAK,EAAEsF;AAF+B,WAA5B,CAAZ;AAIAvB,UAAAA,QAAQ,CAAC/D,KAAT,GAAiBf,SAAS,CAACqC,MAAD,CAA1B;AAEAiE,UAAAA,OAAO,CAACpG,MAAR;AAEA,iBAAO,IAAP;AACD;AACF,OAhCS,CAAV;AAiCD,KApCD;AAqCD,GAtCD,EA/OmB,CAuRnB;;AACAO,EAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACI,KAAD,EAAQ7C,CAAR,KAAc;AACxB,UAAMN,IAAI,GAAGb,cAAc,CAACgE,KAAD,CAA3B;AACA7E,IAAAA,UAAU,CAACuE,IAAD,EAAO,CAAC,QAAD,EAAW7C,IAAX,CAAP,EAAyB,CAACqD,KAAD,EAAQC,QAAR,KAAqB;AACtD,UAAIA,QAAQ,CAACtD,IAAT,KAAkB,QAAtB,EAAgC;AAC9B;AACD;;AAED,YAAMa,MAAM,GAAG9B,QAAQ,CAACuE,QAAQ,CAAC/D,KAAV,CAAvB;;AAEA,UAAI,CAACP,UAAU,CAAC6B,MAAD,CAAf,EAAyB;AACvB;AACD;;AAED,YAAMiE,OAAO,GAAGzB,KAAK,CAACrB,MAAN,CAAc+C,CAAD,IAAOA,CAAC,KAAKzB,QAA1B,EAAoC,CAApC,CAAhB;;AAEA,UAAI,CAAC5C,iBAAiB,CAACG,MAAM,CAACP,CAAD,CAAP,CAAlB,IAAiC1B,YAAY,CAACkG,OAAD,CAAjD,EAA4D;AAC1D;AACD;;AAED,YAAMD,QAAQ,GAAGhE,MAAM,CAACP,CAAD,CAAvB;AAEAO,MAAAA,MAAM,CAACP,CAAD,CAAN,GAAYwE,OAAO,CAACvF,KAApB;;AAEA,UAAId,QAAQ,CAAC4E,KAAD,EAAQ,KAAR,CAAR,IAA0B,CAACA,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAA/B,EAA8D;AAC5DvD,QAAAA,YAAY,CAACsF,QAAQ,CAACL,MAAV,EAAkBK,QAAlB,EAA4B;AACtCtD,UAAAA,IADsC;AAEtCT,UAAAA,KAAK,EAAEsF;AAF+B,SAA5B,CAAZ;AAIAvB,QAAAA,QAAQ,CAAC/D,KAAT,GAAiBf,SAAS,CAACqC,MAAD,CAA1B;AACAiE,QAAAA,OAAO,CAACpG,MAAR;AAEA,eAAO,IAAP;AACD;AACF,KA/BS,CAAV;AAgCD,GAlCD,EAxRmB,CA4TnB;;AACA,MAAIsG,KAAK,GAAG7G,QAAQ,CAAC0E,IAAD,EAAOrD,UAAP,CAApB;;AAEA,SAAOwF,KAAK,CAACzE,MAAb,EAAqB;AACnB,UAAM+C,QAAQ,GAAG0B,KAAK,CAACA,KAAK,CAACzE,MAAN,GAAe,CAAhB,CAAtB;AAEAtB,IAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACG,CAAD,EAAI5C,CAAJ,KAAU;AACpB,YAAM2E,KAAK,GAAGzF,UAAU,CACrBwC,MADW,CACHkD,IAAD,IAAUA,IAAI,KAAK5B,QAAQ,CAACtD,IADxB,EAEXP,GAFW,CAENyF,IAAD,IAAW,GAAEA,IAAK,IAAGhC,CAAE,EAFhB,CAAd;AAIA,UAAIiC,KAAK,GAAGtC,IAAI,CAACsC,KAAL,CAAWC,KAAX,CAAiB,CAAjB,EAAoBvC,IAAI,CAACsC,KAAL,CAAWxD,OAAX,CAAmB2B,QAAnB,CAApB,CAAZ;AAEA,YAAMU,MAAM,GAAGlF,WAAW,CAACqG,KAAD,EAAQ,QAAR,CAA1B;;AAEA,UAAInB,MAAJ,EAAY;AACVmB,QAAAA,KAAK,GAAGA,KAAK,CAACC,KAAN,CAAYD,KAAK,CAACxD,OAAN,CAAcqC,MAAd,CAAZ,CAAR;AACD;;AAED,YAAMlC,KAAK,GAAGqD,KAAK,CAACnD,MAAN,CACX0B,IAAD,IACEA,IAAI,CAAC1D,IAAL,IACAiF,KAAK,CAACzE,QAAN,CAAekD,IAAI,CAAC1D,IAApB,CADA,IAEA0D,IAAI,CAAC2B,SAAL,KAAmB/B,QAAQ,CAAC+B,SAJlB,CAAd;AAMA,YAAMhC,KAAK,GAAGjF,QAAQ,CAAC0D,KAAD,EAAQmD,KAAR,CAAtB;;AAEA,UAAI/G,WAAW,CAACmF,KAAD,EAAQ,GAAG4B,KAAX,CAAX,IAAgC,CAAC5B,KAAK,CAACvC,IAAN,CAAW/C,UAAU,CAACwD,MAAtB,CAArC,EAAoE;AAClE,cAAMV,MAAM,GAAGwC,KAAK,CAAC5D,GAAN,CAAWiE,IAAD,IAAWA,IAAI,GAAGA,IAAI,CAACnE,KAAR,GAAgB,IAAzC,CAAf;AACA,cAAM+F,cAAc,GAAGzE,MAAM,CAACmB,MAAP,CAAcuD,OAAd,CAAvB;AACA,cAAMC,aAAa,GAAG3H,IAAI,CAAC4H,KAAL,CAAWnC,QAAQ,CAAC/D,KAApB,EAA2Be,CAA3B,CAAtB;AAEAO,QAAAA,MAAM,CAACrB,UAAU,CAACmC,OAAX,CAAmB2B,QAAQ,CAACtD,IAA5B,CAAD,CAAN,GAA4CwF,aAA5C;AAEA,YAAIjG,KAAK,GAAGhB,UAAU,CAACsC,MAAM,CAACxB,IAAP,CAAY,GAAZ,CAAD,CAAtB;;AAEA,YACEiG,cAAc,CAAC,CAAD,CAAd,KAAsBA,cAAc,CAAC,CAAD,CAApC,IACAA,cAAc,CAAC,CAAD,CAAd,KAAsBA,cAAc,CAAC,CAAD,CAFtC,EAGE;AACA/F,UAAAA,KAAK,GAAG+F,cAAc,CAAC,CAAD,CAAtB;AACD;;AAED,YAAII,OAAO,GAAG5D,KAAK,CAACA,KAAK,CAACvB,MAAN,GAAe,CAAhB,CAAnB;;AAEA,YAAIhB,KAAK,KAAKiG,aAAd,EAA6B;AAC3BE,UAAAA,OAAO,GAAGpC,QAAV;AACA,cAAIqC,UAAU,GAAG9H,IAAI,CAAC4H,KAAL,CAAWnC,QAAQ,CAAC/D,KAApB,CAAjB;AACAoG,UAAAA,UAAU,CAACC,MAAX,CAAkBtF,CAAlB,EAAqB,CAArB;AACAgD,UAAAA,QAAQ,CAAC/D,KAAT,GAAiBoG,UAAU,CAACtG,IAAX,CAAgB,GAAhB,CAAjB;AACD;;AAEDrB,QAAAA,YAAY,CAAC0H,OAAO,CAACzC,MAAT,EAAiByC,OAAjB,EAA0B;AACpC1F,UAAAA,IAAI,EAAEb,cAAc,CAAC+D,CAAD,CADgB;AAEpC3D,UAAAA;AAFoC,SAA1B,CAAZ;AAKAyF,QAAAA,KAAK,GAAGA,KAAK,CAAChD,MAAN,CAAc0B,IAAD,IAAU,CAACL,KAAK,CAAC7C,QAAN,CAAekD,IAAf,CAAxB,CAAR;AACAL,QAAAA,KAAK,CAACN,OAAN,CAAcrE,MAAd;AACD;AACF,KAtDD;AAwDAsG,IAAAA,KAAK,GAAGA,KAAK,CAAChD,MAAN,CAAc0B,IAAD,IAAUA,IAAI,KAAKJ,QAAhC,CAAR;AACD;;AAEDT,EAAAA,IAAI,CAACC,SAAL,CAAe,QAAf,EAA0B9B,IAAD,IAAU;AACjC,UAAMK,QAAQ,GAAGL,IAAI,CAAC6E,IAAL,EAAjB;;AAEA,QAAI,CAACxE,QAAD,IAAaA,QAAQ,CAACyE,IAAT,KAAkB,MAAnC,EAA2C;AACzC;AACD;;AAED,UAAMxE,KAAK,GAAG9B,UAAU,CAACmC,OAAX,CAAmBN,QAAQ,CAACrB,IAA5B,CAAd;;AAEA,QAAI,CAAC,CAACsB,KAAN,EAAa;AACX;AACD;;AAED,UAAMT,MAAM,GAAG9B,QAAQ,CAACiC,IAAI,CAACzB,KAAN,CAAvB;AACA,UAAM4B,UAAU,GAAGpC,QAAQ,CAACsC,QAAQ,CAAC9B,KAAV,CAA3B;;AAEA,QAAI,CAACP,UAAU,CAAC6B,MAAD,CAAX,IAAuB,CAAC7B,UAAU,CAACmC,UAAD,CAAtC,EAAoD;AAClD;AACD;;AAED,UAAM4E,MAAM,GAAG;AACblF,MAAAA,MADa;AAEbM,MAAAA,UAFa;AAGbH,MAAAA,IAHa;AAIbK,MAAAA,QAJa;AAKbC,MAAAA;AALa,KAAf;AAQA,WAAOF,cAAc,CAAC2E,MAAD,CAArB;AACD,GA7BD;AA+BAlD,EAAAA,IAAI,CAACC,SAAL,CAAe,uCAAf,EAAyD9B,IAAD,IAAU;AAChE,QAAIH,MAAM,GAAG9B,QAAQ,CAACiC,IAAI,CAACzB,KAAN,CAArB;;AAEA,QAAI,CAACP,UAAU,CAAC6B,MAAD,CAAf,EAAyB;AACvB;AACD;;AAED,UAAMa,QAAQ,GAAGlC,UAAU,CAACmC,OAAX,CAAmBX,IAAI,CAAChB,IAAxB,CAAjB;AACA,QAAIgG,IAAI,GAAG,CAAC,GAAGxG,UAAJ,CAAX;AAEAwG,IAAAA,IAAI,CAACJ,MAAL,CAAYlE,QAAZ,EAAsB,CAAtB;AACAzC,IAAAA,GAAG,CAAC8D,OAAJ,CAAY,CAACG,CAAD,EAAI5C,CAAJ,KAAU;AACpB,YAAMwB,KAAK,GAAGkE,IAAI,CAACvG,GAAL,CAAUmF,GAAD,IAAU,GAAEA,GAAI,IAAG1B,CAAE,EAA9B,CAAd;AAEA5E,MAAAA,UAAU,CAACuE,IAAD,EAAO,CAAC7B,IAAI,CAAChB,IAAN,EAAY,GAAG8B,KAAf,CAAP,EAA+BuB,KAAD,IAAW;AACjD,YAAI,CAACA,KAAK,CAAC7C,QAAN,CAAeQ,IAAf,CAAL,EAA2B;AACzB;AACD;;AAED,cAAMiF,SAAS,GAAG5C,KAAK,CAACrB,MAAN,CAAcwC,CAAD,IAAOA,CAAC,KAAKxD,IAA1B,CAAlB;;AAEA,YACEiF,SAAS,CAAC,CAAD,CAAT,CAAa1G,KAAb,CAAmBkB,WAAnB,OACEwF,SAAS,CAAC,CAAD,CAAT,CAAa1G,KAAb,CAAmBkB,WAAnB,EADF,IAEAwF,SAAS,CAAC,CAAD,CAAT,CAAa1G,KAAb,CAAmBkB,WAAnB,OACEwF,SAAS,CAAC,CAAD,CAAT,CAAa1G,KAAb,CAAmBkB,WAAnB,EAHF,IAIAI,MAAM,CAACP,CAAD,CAAN,KAAc4F,SAJd,IAKAD,SAAS,CAAC,CAAD,CAAT,CAAa1G,KAAb,CAAmBkB,WAAnB,OAAqCI,MAAM,CAACP,CAAD,CAAN,CAAUG,WAAV,EANvC,EAOE;AACAwF,UAAAA,SAAS,CAAClD,OAAV,CAAkBrE,MAAlB;AAEAV,UAAAA,YAAY,CAACgD,IAAI,CAACiC,MAAN,EAAcjC,IAAd,EAAoB;AAC9BhB,YAAAA,IAAI,EAAEb,cAAc,CAAC+D,CAAD,CADU;AAE9B3D,YAAAA,KAAK,EAAEsB,MAAM,CAACP,CAAD;AAFiB,WAApB,CAAZ;AAKAO,UAAAA,MAAM,CAACP,CAAD,CAAN,GAAY,IAAZ;AACD;AACF,OAxBS,CAAV;AA0BA,YAAM6F,QAAQ,GAAGtF,MAAM,CAACxB,IAAP,CAAY,GAAZ,CAAjB;;AAEA,UAAI8G,QAAJ,EAAc;AACZnF,QAAAA,IAAI,CAACzB,KAAL,GAAa4G,QAAb;AACD,OAFD,MAEO;AACLnF,QAAAA,IAAI,CAACtC,MAAL;AACD;AACF,KApCD;AAqCD,GAhDD,EA5ZmB,CA8cnB;;AACAmE,EAAAA,IAAI,CAACC,SAAL,CAAe,uCAAf,EAAyD9B,IAAD,IAAU;AAChEA,IAAAA,IAAI,CAACzB,KAAL,GAAaf,SAAS,CAACwC,IAAI,CAACzB,KAAN,CAAtB;AACD,GAFD,EA/cmB,CAmdnB;;AACAsD,EAAAA,IAAI,CAACC,SAAL,CAAe,mBAAf,EAAqC9B,IAAD,IAAU;AAC5C,UAAMzB,KAAK,GAAG1B,IAAI,CAAC4H,KAAL,CAAWzE,IAAI,CAACzB,KAAhB,CAAd,CAD4C,CAG5C;;AACA,QAAIA,KAAK,CAACgB,MAAN,GAAe,CAAf,IAAoBhB,KAAK,CAAC,CAAD,CAAL,KAAaA,KAAK,CAAC,CAAD,CAA1C,EAA+C;AAC7CyB,MAAAA,IAAI,CAACzB,KAAL,GAAaA,KAAK,CAAC6F,KAAN,CAAY,CAAZ,EAAe/F,IAAf,CAAoB,GAApB,CAAb;AACD;AACF,GAPD,EApdmB,CA6dnB;;AACA2F,EAAAA,KAAK,GAAG7G,QAAQ,CAAC0E,IAAD,EAAO3C,aAAP,CAAhB;;AAEA,SAAO8E,KAAK,CAACzE,MAAb,EAAqB;AACnB,UAAM+C,QAAQ,GAAG0B,KAAK,CAACA,KAAK,CAACzE,MAAN,GAAe,CAAhB,CAAtB;AACA,UAAM6F,QAAQ,GAAG9C,QAAQ,CAACtD,IAAT,CAAcqG,KAAd,CAAoB,GAApB,EAAyB5E,GAAzB,EAAjB,CAFmB,CAInB;;AACA,UAAM6E,MAAM,GAAGtB,KAAK,CAAChD,MAAN,CACZ0B,IAAD,IACE,CAAC3F,UAAU,CAACwD,MAAX,CAAkB+B,QAAlB,CAAD,IACA,CAACvF,UAAU,CAACwD,MAAX,CAAkBmC,IAAlB,CADD,IAEA,CAAC9E,YAAY,CAAC0E,QAAD,CAFb,IAGAI,IAAI,KAAKJ,QAHT,IAIAI,IAAI,CAAC2B,SAAL,KAAmB/B,QAAQ,CAAC+B,SAJ5B,IAKAhF,QAAQ,CAACqD,IAAI,CAAC1D,IAAN,CAAR,GAAsBK,QAAQ,CAACiD,QAAQ,CAACtD,IAAV,CAL9B,KAMC0D,IAAI,CAAC1D,IAAL,CAAUS,WAAV,GAAwBD,QAAxB,CAAiC8C,QAAQ,CAACtD,IAA1C,KACC0D,IAAI,CAAC1D,IAAL,CAAUS,WAAV,GAAwB8F,QAAxB,CAAiCH,QAAjC,CAPF,CAFW,CAAf;AAYAE,IAAAA,MAAM,CAACvD,OAAP,CAAerE,MAAf;AACAsG,IAAAA,KAAK,GAAGA,KAAK,CAAChD,MAAN,CAAc0B,IAAD,IAAU,CAAC4C,MAAM,CAAC9F,QAAP,CAAgBkD,IAAhB,CAAxB,CAAR,CAlBmB,CAoBnB;;AACA,QAAI8C,UAAU,GAAGxB,KAAK,CAAChD,MAAN,CACd0B,IAAD,IACE,CAAC3F,UAAU,CAACwD,MAAX,CAAkB+B,QAAlB,CAAD,IACA,CAACvF,UAAU,CAACwD,MAAX,CAAkBmC,IAAlB,CADD,IAEAA,IAAI,KAAKJ,QAFT,IAGAI,IAAI,CAAC2B,SAAL,KAAmB/B,QAAQ,CAAC+B,SAH5B,IAIA3B,IAAI,CAAC1D,IAAL,KAAcsD,QAAQ,CAACtD,IAJvB,IAKA,EAAE,CAACpB,YAAY,CAAC8E,IAAD,CAAb,IAAuB9E,YAAY,CAAC0E,QAAD,CAArC,CAPa,CAAjB;;AAUA,QAAIkD,UAAU,CAACjG,MAAf,EAAuB;AACrB,UAAI,iBAAiBkG,IAAjB,CAAsB1F,aAAa,CAACuC,QAAD,CAAnC,CAAJ,EAAoD;AAClD,cAAMoD,QAAQ,GAAGF,UAAU,CACxBxE,MADc,CACN0B,IAAD,IAAU,CAAC,iBAAiB+C,IAAjB,CAAsB1F,aAAa,CAAC2C,IAAD,CAAnC,CADJ,EAEdjC,GAFc,EAAjB;AAIA+E,QAAAA,UAAU,GAAGA,UAAU,CAACxE,MAAX,CAAmB0B,IAAD,IAAUA,IAAI,KAAKgD,QAArC,CAAb;AACD;;AAEDF,MAAAA,UAAU,CAACzD,OAAX,CAAmBrE,MAAnB;AACD;;AAEDsG,IAAAA,KAAK,GAAGA,KAAK,CAAChD,MAAN,CACL0B,IAAD,IAAUA,IAAI,KAAKJ,QAAT,IAAqB,CAACkD,UAAU,CAAChG,QAAX,CAAoBkD,IAApB,CAD1B,CAAR;AAGD;AACF;;AAEDiD,MAAM,CAACC,OAAP,GAAiB;AACfhE,EAAAA,OADe;AAEfQ,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict';\nconst { list } = require('postcss');\nconst stylehacks = require('stylehacks');\nconst insertCloned = require('../insertCloned');\nconst parseTrbl = require('../parseTrbl');\nconst hasAllProps = require('../hasAllProps');\nconst getDecls = require('../getDecls');\nconst getRules = require('../getRules');\nconst getValue = require('../getValue');\nconst mergeRules = require('../mergeRules');\nconst minifyTrbl = require('../minifyTrbl');\nconst minifyWsc = require('../minifyWsc');\nconst canMerge = require('../canMerge');\nconst remove = require('../remove');\nconst trbl = require('../trbl');\nconst isCustomProp = require('../isCustomProp');\nconst canExplode = require('../canExplode');\nconst getLastNode = require('../getLastNode');\nconst parseWsc = require('../parseWsc');\nconst { isValidWsc } = require('../validateWsc');\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\n\nfunction borderProperty(...parts) {\n  return `border-${parts.join('-')}`;\n}\n\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = trbl.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\nconst directionalProperties = directions.reduce(\n  (prev, curr) => prev.concat(wsc.map((prop) => `${curr}-${prop}`)),\n  []\n);\n\nconst precedence = [\n  ['border'],\n  directions.concat(properties),\n  directionalProperties,\n];\n\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (precedence[i].includes(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n\nconst isValueCustomProp = (value) => value && !!~value.search(/var\\s*\\(\\s*--/i);\n\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp);\n}\n\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return parseWsc(decl.value)[2] || defaults[2];\n}\n\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  }, []);\n}\n\nfunction mergeRedundant({ values, nextValues, decl, nextDecl, index }) {\n  if (!canMerge([decl, nextDecl])) {\n    return;\n  }\n\n  if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length !== 1) {\n    return;\n  }\n\n  const prop = diff.pop();\n  const position = wsc.indexOf(prop);\n\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n\n  let props = parseTrbl(values[position]);\n\n  props[index] = nextValues[position];\n\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = minifyTrbl(props);\n\n  const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value)\n    .length;\n  const newLength1 =\n    decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n\nfunction isCloseEnough(mapped) {\n  return (\n    (mapped[0] === mapped[1] && mapped[1] === mapped[2]) ||\n    (mapped[1] === mapped[2] && mapped[2] === mapped[3]) ||\n    (mapped[2] === mapped[3] && mapped[3] === mapped[0]) ||\n    (mapped[3] === mapped[0] && mapped[0] === mapped[1])\n  );\n}\n\nfunction getDistinctShorthands(mapped) {\n  return mapped.reduce((a, b) => {\n    a = Array.isArray(a) ? a : [a];\n\n    if (!a.includes(b)) {\n      a.push(b);\n    }\n\n    return a;\n  });\n}\n\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, (decl) => {\n    if (!canExplode(decl, false)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase();\n\n    // border -> border-trbl\n    if (prop === 'border') {\n      if (isValidWsc(parseWsc(decl.value))) {\n        directions.forEach((direction) => {\n          insertCloned(decl.parent, decl, { prop: direction });\n        });\n\n        return decl.remove();\n      }\n    }\n\n    // border-trbl -> border-trbl-wsc\n    if (directions.some((direction) => prop === direction)) {\n      let values = parseWsc(decl.value);\n\n      if (isValidWsc(values)) {\n        wsc.forEach((d, i) => {\n          insertCloned(decl.parent, decl, {\n            prop: `${prop}-${d}`,\n            value: values[i] || defaults[i],\n          });\n        });\n\n        return decl.remove();\n      }\n    }\n\n    // border-wsc -> border-trbl-wsc\n    wsc.some((style) => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      parseTrbl(decl.value).forEach((value, i) => {\n        insertCloned(decl.parent, decl, {\n          prop: borderProperty(trbl[i], style),\n          value,\n        });\n      });\n\n      return decl.remove();\n    });\n  });\n}\n\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  trbl.forEach((direction) => {\n    const prop = borderProperty(direction);\n\n    mergeRules(\n      rule,\n      wsc.map((style) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: rules.map(getValue).join(' '),\n          });\n\n          rules.forEach(remove);\n\n          return true;\n        }\n      }\n    );\n  });\n\n  // border-trbl-wsc -> border-wsc\n  wsc.forEach((style) => {\n    const prop = borderProperty(style);\n\n    mergeRules(\n      rule,\n      trbl.map((direction) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: minifyTrbl(rules.map(getValue).join(' ')),\n          });\n\n          rules.forEach(remove);\n\n          return true;\n        }\n      }\n    );\n  });\n\n  // border-trbl -> border-wsc\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map(({ value }) => value);\n\n    if (!canMergeValues(values)) {\n      return;\n    }\n\n    const parsed = values.map((value) => parseWsc(value));\n\n    if (!parsed.every(isValidWsc)) {\n      return;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map((v) => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop: borderProperty(d),\n          value: minifyTrbl(value),\n        });\n      } else {\n        insertCloned(lastNode.parent, lastNode);\n      }\n    });\n\n    rules.forEach(remove);\n\n    return true;\n  });\n\n  // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n\n    if (!canMergeValues(mapped)) {\n      return;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && canMerge(rules, false)) {\n      const first =\n        mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n\n      const border = insertCloned(lastNode.parent, lastNode, {\n        prop: 'border',\n        value: first ? reduced[0] : reduced[1],\n      });\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(trbl[mapped.indexOf(value)]);\n\n        rule.insertAfter(\n          border,\n          Object.assign(lastNode.clone(), {\n            prop,\n            value,\n          })\n        );\n      }\n      rules.forEach(remove);\n\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(\n        color,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: [width, style].map(getValue).join(' '),\n        })\n      );\n      rules\n        .filter((node) => node.prop.toLowerCase() !== properties[2])\n        .forEach(remove);\n\n      return true;\n    }\n  });\n\n  // border-wsc -> border + border-trbl\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter((p) => p !== none);\n      const mostCommon = reduced.sort(\n        (a, b) =>\n          mapped.filter((v) => v === b).length -\n          mapped.filter((v) => v === a).length\n      )[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: borderValue,\n        })\n      );\n\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(\n            lastNode,\n            Object.assign(lastNode.clone(), {\n              prop: dir,\n              value: mapped[i],\n            })\n          );\n        }\n      });\n\n      rules.forEach(remove);\n\n      return true;\n    }\n  });\n\n  // border-trbl -> border\n  // border-trbl -> border + border-trbl\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return;\n    }\n\n    const values = rules.map((node) => {\n      const wscValue = parseWsc(node.value);\n\n      if (!isValidWsc(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first =\n        values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: minifyWsc(first ? values[0] : values[1]),\n        })\n      );\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(\n          lastNode,\n          Object.assign(lastNode.clone(), {\n            prop: prop,\n            value: minifyWsc(value),\n          })\n        );\n      }\n\n      rules.forEach(remove);\n\n      return true;\n    }\n  });\n\n  // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n  directions.forEach((direction) => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n\n      mergeRules(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return;\n        }\n\n        const values = parseWsc(lastNode.value);\n\n        if (!isValidWsc(values)) {\n          return;\n        }\n\n        const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n          return;\n        }\n\n        const wscValue = values[i];\n\n        values[i] = wscProp.value;\n\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: wscValue,\n          });\n          lastNode.value = minifyWsc(values);\n\n          wscProp.remove();\n\n          return true;\n        }\n      });\n    });\n  });\n\n  // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    mergeRules(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return;\n      }\n\n      const values = parseWsc(lastNode.value);\n\n      if (!isValidWsc(values)) {\n        return;\n      }\n\n      const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n        return;\n      }\n\n      const wscValue = values[i];\n\n      values[i] = wscProp.value;\n\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(lastNode.parent, lastNode, {\n          prop,\n          value: wscValue,\n        });\n        lastNode.value = minifyWsc(values);\n        wscProp.remove();\n\n        return true;\n      }\n    });\n  });\n\n  // optimize border-trbl\n  let decls = getDecls(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n\n    wsc.forEach((d, i) => {\n      const names = directions\n        .filter((name) => name !== lastNode.prop)\n        .map((name) => `${name}-${d}`);\n\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n\n      const border = getLastNode(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(\n        (node) =>\n          node.prop &&\n          names.includes(node.prop) &&\n          node.important === lastNode.important\n      );\n      const rules = getRules(props, names);\n\n      if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {\n        const values = rules.map((node) => (node ? node.value : null));\n        const filteredValues = values.filter(Boolean);\n        const lastNodeValue = list.space(lastNode.value)[i];\n\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n\n        let value = minifyTrbl(values.join(' '));\n\n        if (\n          filteredValues[0] === filteredValues[1] &&\n          filteredValues[1] === filteredValues[2]\n        ) {\n          value = filteredValues[0];\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n          let valueArray = list.space(lastNode.value);\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        insertCloned(refNode.parent, refNode, {\n          prop: borderProperty(d),\n          value,\n        });\n\n        decls = decls.filter((node) => !rules.includes(node));\n        rules.forEach(remove);\n      }\n    });\n\n    decls = decls.filter((node) => node !== lastNode);\n  }\n\n  rule.walkDecls('border', (decl) => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (!~index) {\n      return;\n    }\n\n    const values = parseWsc(decl.value);\n    const nextValues = parseWsc(nextDecl.value);\n\n    if (!isValidWsc(values) || !isValidWsc(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index,\n    };\n\n    return mergeRedundant(config);\n  });\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    let values = parseWsc(decl.value);\n\n    if (!isValidWsc(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map((dir) => `${dir}-${d}`);\n\n      mergeRules(rule, [decl.prop, ...props], (rules) => {\n        if (!rules.includes(decl)) {\n          return;\n        }\n\n        const longhands = rules.filter((p) => p !== decl);\n\n        if (\n          longhands[0].value.toLowerCase() ===\n            longhands[1].value.toLowerCase() &&\n          longhands[1].value.toLowerCase() ===\n            longhands[2].value.toLowerCase() &&\n          values[i] !== undefined &&\n          longhands[0].value.toLowerCase() === values[i].toLowerCase()\n        ) {\n          longhands.forEach(remove);\n\n          insertCloned(decl.parent, decl, {\n            prop: borderProperty(d),\n            value: values[i],\n          });\n\n          values[i] = null;\n        }\n      });\n\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  });\n\n  // clean-up values\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    decl.value = minifyWsc(decl.value);\n  });\n\n  // border-spacing-hv -> border-spacing\n  rule.walkDecls(/^border-spacing$/i, (decl) => {\n    const value = list.space(decl.value);\n\n    // merge vertical and horizontal dups\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  });\n\n  // clean-up rules\n  decls = getDecls(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop();\n\n    // remove properties of lower precedence\n    const lesser = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        !isCustomProp(lastNode) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        getLevel(node.prop) > getLevel(lastNode.prop) &&\n        (node.prop.toLowerCase().includes(lastNode.prop) ||\n          node.prop.toLowerCase().endsWith(lastPart))\n    );\n\n    lesser.forEach(remove);\n    decls = decls.filter((node) => !lesser.includes(node));\n\n    // get duplicate properties\n    let duplicates = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        node.prop === lastNode.prop &&\n        !(!isCustomProp(node) && isCustomProp(lastNode))\n    );\n\n    if (duplicates.length) {\n      if (/hsla\\(|rgba\\(/i.test(getColorValue(lastNode))) {\n        const preserve = duplicates\n          .filter((node) => !/hsla\\(|rgba\\(/i.test(getColorValue(node)))\n          .pop();\n\n        duplicates = duplicates.filter((node) => node !== preserve);\n      }\n\n      duplicates.forEach(remove);\n    }\n\n    decls = decls.filter(\n      (node) => node !== lastNode && !duplicates.includes(node)\n    );\n  }\n}\n\nmodule.exports = {\n  explode,\n  merge,\n};\n"]},"metadata":{},"sourceType":"script"}