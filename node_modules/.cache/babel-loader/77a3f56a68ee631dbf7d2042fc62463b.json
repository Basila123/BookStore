{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"../../compile/validate\");\n\nconst code_1 = require(\"../code\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst additionalProperties_1 = require(\"./additionalProperties\");\n\nconst def = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n    }\n\n    const allProps = (0, code_1.allSchemaProperties)(schema);\n\n    for (const prop of allProps) {\n      it.definedProperties.add(prop);\n    }\n\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n    }\n\n    const properties = allProps.filter(p => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (properties.length === 0) return;\n    const valid = gen.name(\"valid\");\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop);\n      } else {\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n        applyPropertySchema(prop);\n        if (!it.allErrors) gen.else().var(valid, true);\n        gen.endIf();\n      }\n\n      cxt.it.definedProperties.add(prop);\n      cxt.ok(valid);\n    }\n\n    function hasDefault(prop) {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n    }\n\n    function applyPropertySchema(prop) {\n      cxt.subschema({\n        keyword: \"properties\",\n        schemaProp: prop,\n        dataProp: prop\n      }, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AACA;;AACA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;AACjCC,SAAO,EAAE,YADwB;AAEjCC,MAAI,EAAE,QAF2B;AAGjCC,YAAU,EAAE,QAHqB;;AAIjCC,MAAI,CAACC,GAAD,EAAgB;AAClB,UAAM;AAACC,SAAD;AAAMC,YAAN;AAAcC,kBAAd;AAA4BC,UAA5B;AAAkCC;AAAlC,QAAwCL,GAA9C;;AACA,QAAIK,EAAE,CAACC,IAAH,CAAQC,gBAAR,KAA6B,KAA7B,IAAsCJ,YAAY,CAACK,oBAAb,KAAsCC,SAAhF,EAA2F;AACzFC,qCAAMX,IAAN,CAAW,IAAIY,qBAAJ,CAAeN,EAAf,EAAmBK,8BAAnB,EAA0B,sBAA1B,CAAX;AACD;;AACD,UAAME,QAAQ,GAAG,gCAAoBV,MAApB,CAAjB;;AACA,SAAK,MAAMW,IAAX,IAAmBD,QAAnB,EAA6B;AAC3BP,QAAE,CAACS,iBAAH,CAAqBC,GAArB,CAAyBF,IAAzB;AACD;;AACD,QAAIR,EAAE,CAACC,IAAH,CAAQU,WAAR,IAAuBJ,QAAQ,CAACK,MAAhC,IAA0CZ,EAAE,CAACa,KAAH,KAAa,IAA3D,EAAiE;AAC/Db,QAAE,CAACa,KAAH,GAAWC,sBAAeD,KAAf,CAAqBjB,GAArB,EAA0B,mBAAOW,QAAP,CAA1B,EAA4CP,EAAE,CAACa,KAA/C,CAAX;AACD;;AACD,UAAME,UAAU,GAAGR,QAAQ,CAACS,MAAT,CAAiBC,CAAD,IAAO,CAAC,8BAAkBjB,EAAlB,EAAsBH,MAAM,CAACoB,CAAD,CAA5B,CAAxB,CAAnB;AACA,QAAIF,UAAU,CAACH,MAAX,KAAsB,CAA1B,EAA6B;AAC7B,UAAMM,KAAK,GAAGtB,GAAG,CAACuB,IAAJ,CAAS,OAAT,CAAd;;AAEA,SAAK,MAAMX,IAAX,IAAmBO,UAAnB,EAA+B;AAC7B,UAAIK,UAAU,CAACZ,IAAD,CAAd,EAAsB;AACpBa,2BAAmB,CAACb,IAAD,CAAnB;AACD,OAFD,MAEO;AACLZ,WAAG,CAAC0B,EAAJ,CAAO,2BAAe1B,GAAf,EAAoBG,IAApB,EAA0BS,IAA1B,EAAgCR,EAAE,CAACC,IAAH,CAAQsB,aAAxC,CAAP;AACAF,2BAAmB,CAACb,IAAD,CAAnB;AACA,YAAI,CAACR,EAAE,CAACwB,SAAR,EAAmB5B,GAAG,CAAC6B,IAAJ,GAAWC,GAAX,CAAeR,KAAf,EAAsB,IAAtB;AACnBtB,WAAG,CAAC+B,KAAJ;AACD;;AACDhC,SAAG,CAACK,EAAJ,CAAOS,iBAAP,CAAyBC,GAAzB,CAA6BF,IAA7B;AACAb,SAAG,CAACiC,EAAJ,CAAOV,KAAP;AACD;;AAED,aAASE,UAAT,CAAoBZ,IAApB,EAAgC;AAC9B,aAAOR,EAAE,CAACC,IAAH,CAAQ4B,WAAR,IAAuB,CAAC7B,EAAE,CAAC8B,aAA3B,IAA4CjC,MAAM,CAACW,IAAD,CAAN,CAAauB,OAAb,KAAyB3B,SAA5E;AACD;;AAED,aAASiB,mBAAT,CAA6Bb,IAA7B,EAAyC;AACvCb,SAAG,CAACqC,SAAJ,CACE;AACEzC,eAAO,EAAE,YADX;AAEE0C,kBAAU,EAAEzB,IAFd;AAGE0B,gBAAQ,EAAE1B;AAHZ,OADF,EAMEU,KANF;AAQD;AACF;;AA/CgC,CAAnC;AAkDAiB,kBAAe7C,GAAf","names":["def","keyword","type","schemaType","code","cxt","gen","schema","parentSchema","data","it","opts","removeAdditional","additionalProperties","undefined","additionalProperties_1","validate_1","allProps","prop","definedProperties","add","unevaluated","length","props","util_1","properties","filter","p","valid","name","hasDefault","applyPropertySchema","if","ownProperties","allErrors","else","var","endIf","ok","useDefaults","compositeRule","default","subschema","schemaProp","dataProp","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/vocabularies/applicator/properties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}