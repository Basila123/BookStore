{"ast":null,"code":"'use strict';\n\nconst browserslist = require('browserslist');\n\nconst {\n  sameParent\n} = require('cssnano-utils');\n\nconst {\n  ensureCompatibility,\n  sameVendor,\n  noVendor\n} = require('./lib/ensureCompatibility');\n/**\n * @param {postcss.Declaration} a\n * @param {postcss.Declaration} b\n * @return {boolean}\n */\n\n\nfunction declarationIsEqual(a, b) {\n  return a.important === b.important && a.prop === b.prop && a.value === b.value;\n}\n/**\n * @param {postcss.Declaration[]} array\n * @param {postcss.Declaration} decl\n * @return {number}\n */\n\n\nfunction indexOfDeclaration(array, decl) {\n  return array.findIndex(d => declarationIsEqual(d, decl));\n}\n/**\n * Returns filtered array of matched or unmatched declarations\n * @param {postcss.Declaration[]} a\n * @param {postcss.Declaration[]} b\n * @param {boolean} [not=false]\n * @return {postcss.Declaration[]}\n */\n\n\nfunction intersect(a, b, not) {\n  return a.filter(c => {\n    const index = ~indexOfDeclaration(b, c);\n    return not ? !index : index;\n  });\n}\n/**\n * @param {postcss.Declaration[]} a\n * @param {postcss.Declaration[]} b\n * @return {boolean}\n */\n\n\nfunction sameDeclarationsAndOrder(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return a.every((d, index) => declarationIsEqual(d, b[index]));\n}\n/**\n * @param {postcss.Rule} ruleA\n * @param {postcss.Rule} ruleB\n * @param {string[]=} browsers\n * @param {Map<string, boolean>=} compatibilityCache\n * @return {boolean}\n */\n\n\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n  const a = ruleA.selectors;\n  const b = ruleB.selectors;\n  const selectors = a.concat(b);\n\n  if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {\n    return false;\n  }\n\n  const parent = sameParent(ruleA, ruleB);\n  const {\n    name\n  } = ruleA.parent;\n\n  if (parent && name && name.includes('keyframes')) {\n    return false;\n  }\n\n  return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n/**\n * @param {postcss.Rule} rule\n * @return {postcss.Declaration[]}\n */\n\n\nfunction getDecls(rule) {\n  return rule.nodes.filter(node => node.type === 'decl');\n}\n\nconst joinSelectors = function () {\n  for (var _len = arguments.length, rules = new Array(_len), _key = 0; _key < _len; _key++) {\n    rules[_key] = arguments[_key];\n  }\n\n  return rules.map(s => s.selector).join();\n};\n\nfunction ruleLength() {\n  for (var _len2 = arguments.length, rules = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    rules[_key2] = arguments[_key2];\n  }\n\n  return rules.map(r => r.nodes.length ? String(r) : '').join('').length;\n}\n/**\n * @param {string} prop\n * @return {{prefix: string, base:string, rest:string[]}}\n */\n\n\nfunction splitProp(prop) {\n  // Treat vendor prefixed properties as if they were unprefixed;\n  // moving them when combined with non-prefixed properties can\n  // cause issues. e.g. moving -webkit-background-clip when there\n  // is a background shorthand definition.\n  const parts = prop.split('-');\n\n  if (prop[0] !== '-') {\n    return {\n      prefix: '',\n      base: parts[0],\n      rest: parts.slice(1)\n    };\n  } // Don't split css variables\n\n\n  if (prop[1] === '-') {\n    return {\n      prefix: null,\n      base: null,\n      rest: [prop]\n    };\n  } // Found prefix\n\n\n  return {\n    prefix: parts[1],\n    base: parts[2],\n    rest: parts.slice(3)\n  };\n}\n/**\n * @param {string} propA\n * @param {string} propB\n */\n\n\nfunction isConflictingProp(propA, propB) {\n  if (propA === propB) {\n    // Same specificity\n    return true;\n  }\n\n  const a = splitProp(propA);\n  const b = splitProp(propB); // Don't resort css variables\n\n  if (!a.base && !b.base) {\n    return true;\n  } // Different base;\n\n\n  if (a.base !== b.base) {\n    return false;\n  } // Conflict if rest-count mismatches\n\n\n  if (a.rest.length !== b.rest.length) {\n    return true;\n  } // Conflict if rest parameters are equal (same but unprefixed)\n\n\n  return a.rest.every((s, index) => b.rest[index] === s);\n}\n/**\n * @param {postcss.Rule} first\n * @param {postcss.Rule} second\n * @return {boolean} merged\n */\n\n\nfunction mergeParents(first, second) {\n  // Null check for detached rules\n  if (!first.parent || !second.parent) {\n    return false;\n  } // Check if parents share node\n\n\n  if (first.parent === second.parent) {\n    return false;\n  } // sameParent() already called by canMerge()\n\n\n  second.remove();\n  first.parent.append(second);\n  return true;\n}\n/**\n * @param {postcss.Rule} first\n * @param {postcss.Rule} second\n * @return {postcss.Rule} mergedRule\n */\n\n\nfunction partialMerge(first, second) {\n  let intersection = intersect(getDecls(first), getDecls(second));\n\n  if (!intersection.length) {\n    return second;\n  }\n\n  let nextRule = second.next();\n\n  if (!nextRule) {\n    // Grab next cousin\n    const parentSibling = second.parent.next();\n    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];\n  }\n\n  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n\n    if (nextIntersection.length > intersection.length) {\n      mergeParents(second, nextRule);\n      first = second;\n      second = nextRule;\n      intersection = nextIntersection;\n    }\n  }\n\n  const firstDecls = getDecls(first); // Filter out intersections with later conflicts in First\n\n  intersection = intersection.filter((decl, intersectIndex) => {\n    const indexOfDecl = indexOfDeclaration(firstDecls, decl);\n    const nextConflictInFirst = firstDecls.slice(indexOfDecl + 1).filter(d => isConflictingProp(d.prop, decl.prop));\n\n    if (!nextConflictInFirst.length) {\n      return true;\n    }\n\n    const nextConflictInIntersection = intersection.slice(intersectIndex + 1).filter(d => isConflictingProp(d.prop, decl.prop));\n\n    if (!nextConflictInIntersection.length) {\n      return false;\n    }\n\n    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {\n      return false;\n    }\n\n    return nextConflictInFirst.every((d, index) => declarationIsEqual(d, nextConflictInIntersection[index]));\n  }); // Filter out intersections with previous conflicts in Second\n\n  const secondDecls = getDecls(second);\n  intersection = intersection.filter(decl => {\n    const nextConflictIndex = secondDecls.findIndex(d => isConflictingProp(d.prop, decl.prop));\n\n    if (nextConflictIndex === -1) {\n      return false;\n    }\n\n    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {\n      return false;\n    }\n\n    if (decl.prop.toLowerCase() !== 'direction' && decl.prop.toLowerCase() !== 'unicode-bidi' && secondDecls.some(declaration => declaration.prop.toLowerCase() === 'all')) {\n      return false;\n    }\n\n    secondDecls.splice(nextConflictIndex, 1);\n    return true;\n  });\n\n  if (!intersection.length) {\n    // Nothing to merge\n    return second;\n  }\n\n  const receivingBlock = second.clone();\n  receivingBlock.selector = joinSelectors(first, second);\n  receivingBlock.nodes = [];\n  second.parent.insertBefore(second, receivingBlock);\n  const firstClone = first.clone();\n  const secondClone = second.clone();\n  /**\n   * @param {function(postcss.Declaration):void} callback\n   * @return {function(postcss.Declaration)}\n   */\n\n  function moveDecl(callback) {\n    return decl => {\n      if (~indexOfDeclaration(intersection, decl)) {\n        callback.call(this, decl);\n      }\n    };\n  }\n\n  firstClone.walkDecls(moveDecl(decl => {\n    decl.remove();\n    receivingBlock.append(decl);\n  }));\n  secondClone.walkDecls(moveDecl(decl => decl.remove()));\n  const merged = ruleLength(firstClone, receivingBlock, secondClone);\n  const original = ruleLength(first, second);\n\n  if (merged < original) {\n    first.replaceWith(firstClone);\n    second.replaceWith(secondClone);\n    [firstClone, receivingBlock, secondClone].forEach(r => {\n      if (!r.nodes.length) {\n        r.remove();\n      }\n    });\n\n    if (!secondClone.parent) {\n      return receivingBlock;\n    }\n\n    return secondClone;\n  } else {\n    receivingBlock.remove();\n    return second;\n  }\n}\n/**\n * @param {string[]} browsers\n * @param {Map<string, boolean>} compatibilityCache\n * @return {function(postcss.Rule)}\n */\n\n\nfunction selectorMerger(browsers, compatibilityCache) {\n  /** @type {postcss.Rule} */\n  let cache = null;\n  return function (rule) {\n    // Prime the cache with the first rule, or alternately ensure that it is\n    // safe to merge both declarations before continuing\n    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n      cache = rule;\n      return;\n    } // Ensure that we don't deduplicate the same rule; this is sometimes\n    // caused by a partial merge\n\n\n    if (cache === rule) {\n      cache = rule;\n      return;\n    } // Parents merge: check if the rules have same parents, but not same parent nodes\n\n\n    mergeParents(cache, rule); // Merge when declarations are exactly equal\n    // e.g. h1 { color: red } h2 { color: red }\n\n    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {\n      rule.selector = joinSelectors(cache, rule);\n      cache.remove();\n      cache = rule;\n      return;\n    } // Merge when both selectors are exactly equal\n    // e.g. a { color: blue } a { font-weight: bold }\n\n\n    if (cache.selector === rule.selector) {\n      const cached = getDecls(cache);\n      rule.walk(decl => {\n        if (~indexOfDeclaration(cached, decl)) {\n          return decl.remove();\n        }\n\n        cache.append(decl);\n      });\n      rule.remove();\n      return;\n    } // Partial merge: check if the rule contains a subset of the last; if\n    // so create a joined selector with the subset, if smaller.\n\n\n    cache = partialMerge(cache, rule);\n  };\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-rules',\n\n    prepare(result) {\n      const resultOpts = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOpts.stats,\n        path: __dirname,\n        env: resultOpts.env\n      });\n      const compatibilityCache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkRules(selectorMerger(browsers, compatibilityCache));\n        }\n\n      };\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-merge-rules/src/index.js"],"names":["browserslist","require","sameParent","ensureCompatibility","sameVendor","noVendor","declarationIsEqual","a","b","important","prop","value","indexOfDeclaration","array","decl","findIndex","d","intersect","not","filter","c","index","sameDeclarationsAndOrder","length","every","canMerge","ruleA","ruleB","browsers","compatibilityCache","selectors","concat","parent","name","includes","getDecls","rule","nodes","node","type","joinSelectors","rules","map","s","selector","join","ruleLength","r","String","splitProp","parts","split","prefix","base","rest","slice","isConflictingProp","propA","propB","mergeParents","first","second","remove","append","partialMerge","intersection","nextRule","next","parentSibling","nextIntersection","firstDecls","intersectIndex","indexOfDecl","nextConflictInFirst","nextConflictInIntersection","secondDecls","nextConflictIndex","toLowerCase","some","declaration","splice","receivingBlock","clone","insertBefore","firstClone","secondClone","moveDecl","callback","call","walkDecls","merged","original","replaceWith","forEach","selectorMerger","cache","cached","walk","pluginCreator","postcssPlugin","prepare","result","resultOpts","opts","stats","path","__dirname","env","Map","OnceExit","css","walkRules","postcss","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst browserslist = require('browserslist');\nconst { sameParent } = require('cssnano-utils');\nconst {\n  ensureCompatibility,\n  sameVendor,\n  noVendor,\n} = require('./lib/ensureCompatibility');\n\n/**\n * @param {postcss.Declaration} a\n * @param {postcss.Declaration} b\n * @return {boolean}\n */\nfunction declarationIsEqual(a, b) {\n  return (\n    a.important === b.important && a.prop === b.prop && a.value === b.value\n  );\n}\n\n/**\n * @param {postcss.Declaration[]} array\n * @param {postcss.Declaration} decl\n * @return {number}\n */\nfunction indexOfDeclaration(array, decl) {\n  return array.findIndex((d) => declarationIsEqual(d, decl));\n}\n\n/**\n * Returns filtered array of matched or unmatched declarations\n * @param {postcss.Declaration[]} a\n * @param {postcss.Declaration[]} b\n * @param {boolean} [not=false]\n * @return {postcss.Declaration[]}\n */\nfunction intersect(a, b, not) {\n  return a.filter((c) => {\n    const index = ~indexOfDeclaration(b, c);\n    return not ? !index : index;\n  });\n}\n\n/**\n * @param {postcss.Declaration[]} a\n * @param {postcss.Declaration[]} b\n * @return {boolean}\n */\nfunction sameDeclarationsAndOrder(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return a.every((d, index) => declarationIsEqual(d, b[index]));\n}\n\n/**\n * @param {postcss.Rule} ruleA\n * @param {postcss.Rule} ruleB\n * @param {string[]=} browsers\n * @param {Map<string, boolean>=} compatibilityCache\n * @return {boolean}\n */\nfunction canMerge(ruleA, ruleB, browsers, compatibilityCache) {\n  const a = ruleA.selectors;\n  const b = ruleB.selectors;\n\n  const selectors = a.concat(b);\n\n  if (!ensureCompatibility(selectors, browsers, compatibilityCache)) {\n    return false;\n  }\n\n  const parent = sameParent(ruleA, ruleB);\n  const { name } = ruleA.parent;\n  if (parent && name && name.includes('keyframes')) {\n    return false;\n  }\n  return parent && (selectors.every(noVendor) || sameVendor(a, b));\n}\n\n/**\n * @param {postcss.Rule} rule\n * @return {postcss.Declaration[]}\n */\nfunction getDecls(rule) {\n  return rule.nodes.filter((node) => node.type === 'decl');\n}\n\nconst joinSelectors = (...rules) => rules.map((s) => s.selector).join();\n\nfunction ruleLength(...rules) {\n  return rules.map((r) => (r.nodes.length ? String(r) : '')).join('').length;\n}\n\n/**\n * @param {string} prop\n * @return {{prefix: string, base:string, rest:string[]}}\n */\nfunction splitProp(prop) {\n  // Treat vendor prefixed properties as if they were unprefixed;\n  // moving them when combined with non-prefixed properties can\n  // cause issues. e.g. moving -webkit-background-clip when there\n  // is a background shorthand definition.\n\n  const parts = prop.split('-');\n  if (prop[0] !== '-') {\n    return {\n      prefix: '',\n      base: parts[0],\n      rest: parts.slice(1),\n    };\n  }\n  // Don't split css variables\n  if (prop[1] === '-') {\n    return {\n      prefix: null,\n      base: null,\n      rest: [prop],\n    };\n  }\n  // Found prefix\n  return {\n    prefix: parts[1],\n    base: parts[2],\n    rest: parts.slice(3),\n  };\n}\n\n/**\n * @param {string} propA\n * @param {string} propB\n */\nfunction isConflictingProp(propA, propB) {\n  if (propA === propB) {\n    // Same specificity\n    return true;\n  }\n  const a = splitProp(propA);\n  const b = splitProp(propB);\n  // Don't resort css variables\n  if (!a.base && !b.base) {\n    return true;\n  }\n  // Different base;\n  if (a.base !== b.base) {\n    return false;\n  }\n  // Conflict if rest-count mismatches\n  if (a.rest.length !== b.rest.length) {\n    return true;\n  }\n\n  // Conflict if rest parameters are equal (same but unprefixed)\n  return a.rest.every((s, index) => b.rest[index] === s);\n}\n\n/**\n * @param {postcss.Rule} first\n * @param {postcss.Rule} second\n * @return {boolean} merged\n */\nfunction mergeParents(first, second) {\n  // Null check for detached rules\n  if (!first.parent || !second.parent) {\n    return false;\n  }\n\n  // Check if parents share node\n  if (first.parent === second.parent) {\n    return false;\n  }\n\n  // sameParent() already called by canMerge()\n\n  second.remove();\n  first.parent.append(second);\n  return true;\n}\n\n/**\n * @param {postcss.Rule} first\n * @param {postcss.Rule} second\n * @return {postcss.Rule} mergedRule\n */\nfunction partialMerge(first, second) {\n  let intersection = intersect(getDecls(first), getDecls(second));\n  if (!intersection.length) {\n    return second;\n  }\n  let nextRule = second.next();\n  if (!nextRule) {\n    // Grab next cousin\n    const parentSibling = second.parent.next();\n    nextRule = parentSibling && parentSibling.nodes && parentSibling.nodes[0];\n  }\n  if (nextRule && nextRule.type === 'rule' && canMerge(second, nextRule)) {\n    let nextIntersection = intersect(getDecls(second), getDecls(nextRule));\n    if (nextIntersection.length > intersection.length) {\n      mergeParents(second, nextRule);\n      first = second;\n      second = nextRule;\n      intersection = nextIntersection;\n    }\n  }\n\n  const firstDecls = getDecls(first);\n\n  // Filter out intersections with later conflicts in First\n  intersection = intersection.filter((decl, intersectIndex) => {\n    const indexOfDecl = indexOfDeclaration(firstDecls, decl);\n    const nextConflictInFirst = firstDecls\n      .slice(indexOfDecl + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (!nextConflictInFirst.length) {\n      return true;\n    }\n    const nextConflictInIntersection = intersection\n      .slice(intersectIndex + 1)\n      .filter((d) => isConflictingProp(d.prop, decl.prop));\n    if (!nextConflictInIntersection.length) {\n      return false;\n    }\n    if (nextConflictInFirst.length !== nextConflictInIntersection.length) {\n      return false;\n    }\n    return nextConflictInFirst.every((d, index) =>\n      declarationIsEqual(d, nextConflictInIntersection[index])\n    );\n  });\n\n  // Filter out intersections with previous conflicts in Second\n  const secondDecls = getDecls(second);\n  intersection = intersection.filter((decl) => {\n    const nextConflictIndex = secondDecls.findIndex((d) =>\n      isConflictingProp(d.prop, decl.prop)\n    );\n    if (nextConflictIndex === -1) {\n      return false;\n    }\n    if (!declarationIsEqual(secondDecls[nextConflictIndex], decl)) {\n      return false;\n    }\n    if (\n      decl.prop.toLowerCase() !== 'direction' &&\n      decl.prop.toLowerCase() !== 'unicode-bidi' &&\n      secondDecls.some(\n        (declaration) => declaration.prop.toLowerCase() === 'all'\n      )\n    ) {\n      return false;\n    }\n    secondDecls.splice(nextConflictIndex, 1);\n    return true;\n  });\n\n  if (!intersection.length) {\n    // Nothing to merge\n    return second;\n  }\n\n  const receivingBlock = second.clone();\n  receivingBlock.selector = joinSelectors(first, second);\n  receivingBlock.nodes = [];\n\n  second.parent.insertBefore(second, receivingBlock);\n\n  const firstClone = first.clone();\n  const secondClone = second.clone();\n\n  /**\n   * @param {function(postcss.Declaration):void} callback\n   * @return {function(postcss.Declaration)}\n   */\n  function moveDecl(callback) {\n    return (decl) => {\n      if (~indexOfDeclaration(intersection, decl)) {\n        callback.call(this, decl);\n      }\n    };\n  }\n  firstClone.walkDecls(\n    moveDecl((decl) => {\n      decl.remove();\n      receivingBlock.append(decl);\n    })\n  );\n  secondClone.walkDecls(moveDecl((decl) => decl.remove()));\n  const merged = ruleLength(firstClone, receivingBlock, secondClone);\n  const original = ruleLength(first, second);\n  if (merged < original) {\n    first.replaceWith(firstClone);\n    second.replaceWith(secondClone);\n    [firstClone, receivingBlock, secondClone].forEach((r) => {\n      if (!r.nodes.length) {\n        r.remove();\n      }\n    });\n    if (!secondClone.parent) {\n      return receivingBlock;\n    }\n    return secondClone;\n  } else {\n    receivingBlock.remove();\n    return second;\n  }\n}\n\n/**\n * @param {string[]} browsers\n * @param {Map<string, boolean>} compatibilityCache\n * @return {function(postcss.Rule)}\n */\nfunction selectorMerger(browsers, compatibilityCache) {\n  /** @type {postcss.Rule} */\n  let cache = null;\n  return function (rule) {\n    // Prime the cache with the first rule, or alternately ensure that it is\n    // safe to merge both declarations before continuing\n    if (!cache || !canMerge(rule, cache, browsers, compatibilityCache)) {\n      cache = rule;\n      return;\n    }\n    // Ensure that we don't deduplicate the same rule; this is sometimes\n    // caused by a partial merge\n    if (cache === rule) {\n      cache = rule;\n      return;\n    }\n\n    // Parents merge: check if the rules have same parents, but not same parent nodes\n    mergeParents(cache, rule);\n\n    // Merge when declarations are exactly equal\n    // e.g. h1 { color: red } h2 { color: red }\n    if (sameDeclarationsAndOrder(getDecls(rule), getDecls(cache))) {\n      rule.selector = joinSelectors(cache, rule);\n      cache.remove();\n      cache = rule;\n      return;\n    }\n    // Merge when both selectors are exactly equal\n    // e.g. a { color: blue } a { font-weight: bold }\n    if (cache.selector === rule.selector) {\n      const cached = getDecls(cache);\n      rule.walk((decl) => {\n        if (~indexOfDeclaration(cached, decl)) {\n          return decl.remove();\n        }\n        cache.append(decl);\n      });\n      rule.remove();\n      return;\n    }\n    // Partial merge: check if the rule contains a subset of the last; if\n    // so create a joined selector with the subset, if smaller.\n    cache = partialMerge(cache, rule);\n  };\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-merge-rules',\n\n    prepare(result) {\n      const resultOpts = result.opts || {};\n      const browsers = browserslist(null, {\n        stats: resultOpts.stats,\n        path: __dirname,\n        env: resultOpts.env,\n      });\n\n      const compatibilityCache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkRules(selectorMerger(browsers, compatibilityCache));\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]},"metadata":{},"sourceType":"script"}