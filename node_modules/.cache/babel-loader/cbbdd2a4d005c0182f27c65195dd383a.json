{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nconst boolSchema_1 = require(\"./boolSchema\");\n\nconst dataType_1 = require(\"./dataType\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst dataType_2 = require(\"./dataType\");\n\nconst defaults_1 = require(\"./defaults\");\n\nconst keyword_1 = require(\"./keyword\");\n\nconst subschema_1 = require(\"./subschema\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst resolve_1 = require(\"../resolve\");\n\nconst util_1 = require(\"../util\");\n\nconst errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction(_ref, body) {\n  let {\n    gen,\n    validateName,\n    schema,\n    schemaEnv,\n    opts\n  } = _ref;\n\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n}\n\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\n\nfunction schemaCxtHasRules(_ref2) {\n  let {\n    schema,\n    self\n  } = _ref2;\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (self.RULES.all[key]) return true;\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n}\n\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\n\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword(_ref3) {\n  let {\n    gen,\n    schemaEnv,\n    schema,\n    errSchemaPath,\n    opts\n  } = _ref3;\n  const msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\n\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n  }\n}\n\nfunction assignEvaluated(_ref4) {\n  let {\n    gen,\n    evaluated,\n    props,\n    items\n  } = _ref4;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(t => includesType(types, t));\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\n\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n      return;\n    }\n\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n  }\n\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n\n      this._error(append, errorPaths);\n\n      this.setParams({});\n      return;\n    }\n\n    this._error(append, errorPaths);\n  }\n\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n\n  block$data(valid, codeBlock) {\n    let $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n\n  check$data() {\n    let valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    let $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n\n    gen.else();\n  }\n\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n\n      return codegen_1.nil;\n    }\n\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n\n        return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n      }\n\n      return codegen_1.nil;\n    }\n  }\n\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = { ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n\n}\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, _ref5) {\n  let {\n    dataLevel,\n    dataNames,\n    dataPathArr\n  } = _ref5;\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n      expr = (0, codegen_1._)`${expr} && ${data}`;\n    }\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\n\nexports.getData = getData;","map":{"version":3,"mappings":"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","names":["validateFunctionCode","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","exports","body","gen","validateName","schema","schemaEnv","opts","code","es5","func","names_1","data","valCxt","$async","funcSourceUrl","destructureValCxtES5","destructureValCxt","instancePath","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","codegen_1","if","var","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","assign","schId","schemaId","source","process","subschemaCode","valid","subSchemaObjCode","self","key","RULES","all","updateContext","checkAsyncSchema","errsCount","checkRefsAndKeywords","jtd","schemaKeywords","types","checkedTypes","errSchemaPath","$ref","ignoreKeywordsWithRef","logger","warn","default","undefined","useDefaults","strictSchema","baseId","uriResolver","Error","msg","schemaPath","rootName","scopeValue","ref","root","ValidationError","return","throw","assignEvaluated","props","items","typeErrors","allErrors","block","keywordCode","definition","checkStrictTypes","group","rules","groupKeywords","post","type","strictNumbers","iterateKeywords","length","else","endIf","rule","keyword","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","filter","ts","includes","some","hasApplicableType","schTs","kwdT","KeywordCxt","constructor","def","$data","schemaValue","schemaType","parentSchema","params","schemaCode","getData","allowUndefined","JSON","stringify","trackErrors","result","condition","successAction","failAction","failResult","error","pass","fail","fail$data","invalid$data","append","errorParams","errorPaths","setParams","_error","errors_1","$dataError","reset","ok","cond","obj","Object","block$data","codeBlock","$dataValid","check$data","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","st","Array","isArray","dataType_2","Wrong","validateSchemaRef","subschema","appl","nextContext","mergeEvaluated","schemaCxt","toName","util_1","mergeValidEvaluated","ruleType","cxt","validate","compile","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","expr","segments","split","segment","pointerType"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/compile/validate/index.ts"],"sourcesContent":["import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  it.dataTypes = it.dataTypes.filter((t) => includesType(types, t))\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n"]},"metadata":{},"sourceType":"script"}