{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst {\n  visitSkip\n} = require('../lib/xast.js');\n\nconst {\n  referencesProps\n} = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'cleanupIDs';\nexports.active = true;\nexports.description = 'removes unused IDs and minifies used';\nconst regReferencesUrl = /\\burl\\((\"|')?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\w+)\\./;\nconst generateIDchars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\nconst maxIDindex = generateIDchars.length - 1;\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\n\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentID: null | Array<number>) => Array<number>}\n */\n\n\nconst generateID = currentID => {\n  if (currentID == null) {\n    return [0];\n  }\n\n  currentID[currentID.length - 1] += 1;\n\n  for (let i = currentID.length - 1; i > 0; i--) {\n    if (currentID[i] > maxIDindex) {\n      currentID[i] = 0;\n\n      if (currentID[i - 1] !== undefined) {\n        currentID[i - 1]++;\n      }\n    }\n  }\n\n  if (currentID[0] > maxIDindex) {\n    currentID[0] = 0;\n    currentID.unshift(0);\n  }\n\n  return currentID;\n};\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>, prefix: string) => string}\n */\n\n\nconst getIDstring = (arr, prefix) => {\n  return prefix + arr.map(i => generateIDchars[i]).join('');\n};\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   remove?: boolean,\n *   minify?: boolean,\n *   prefix?: string,\n *   preserve?: Array<string>,\n *   preservePrefixes?: Array<string>,\n *   force?: boolean,\n * }>}\n */\n\n\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    prefix = '',\n    preserve = [],\n    preservePrefixes = [],\n    force = false\n  } = params;\n  const preserveIDs = new Set(Array.isArray(preserve) ? preserve : preserve ? [preserve] : []);\n  const preserveIDPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n\n  const referencesById = new Map();\n  let deoptimized = false;\n  return {\n    element: {\n      enter: node => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if ((node.name === 'style' || node.name === 'script') && node.children.length !== 0) {\n            deoptimized = true;\n            return;\n          } // avoid removing IDs if the whole SVG consists only of defs\n\n\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (id != null) {\n              let refs = referencesById.get(id);\n\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n\n              refs.push({\n                element: node,\n                name,\n                value\n              });\n            }\n          }\n        }\n      }\n    },\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n\n\n        const isIdPreserved = id => preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n\n\n        let currentID = null;\n\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIDString = null;\n\n              do {\n                currentID = generateID(currentID);\n                currentIDString = getIDstring(currentID, prefix);\n              } while (isIdPreserved(currentIDString));\n\n              node.attributes.id = currentIDString;\n\n              for (const {\n                element,\n                name,\n                value\n              } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(`#${id}`, `#${currentIDString}`);\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(`${id}.`, `${currentIDString}.`);\n                }\n              }\n            } // keep referenced node\n\n\n            nodeById.delete(id);\n          }\n        } // remove non-referenced IDs attributes from elements\n\n\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/cleanupIDs.js"],"names":["visitSkip","require","referencesProps","exports","type","name","active","description","regReferencesUrl","regReferencesHref","regReferencesBegin","generateIDchars","maxIDindex","length","hasStringPrefix","string","prefixes","prefix","startsWith","generateID","currentID","i","undefined","unshift","getIDstring","arr","map","join","fn","_root","params","remove","minify","preserve","preservePrefixes","force","preserveIDs","Set","Array","isArray","preserveIDPrefixes","nodeById","Map","referencesById","deoptimized","element","enter","node","children","hasDefsOnly","child","value","Object","entries","attributes","id","has","set","includes","match","endsWith","refs","get","push","root","exit","isIdPreserved","currentIDString","replace","delete"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { visitSkip } = require('../lib/xast.js');\nconst { referencesProps } = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'cleanupIDs';\nexports.active = true;\nexports.description = 'removes unused IDs and minifies used';\n\nconst regReferencesUrl = /\\burl\\((\"|')?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\w+)\\./;\nconst generateIDchars = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n];\nconst maxIDindex = generateIDchars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentID: null | Array<number>) => Array<number>}\n */\nconst generateID = (currentID) => {\n  if (currentID == null) {\n    return [0];\n  }\n  currentID[currentID.length - 1] += 1;\n  for (let i = currentID.length - 1; i > 0; i--) {\n    if (currentID[i] > maxIDindex) {\n      currentID[i] = 0;\n      if (currentID[i - 1] !== undefined) {\n        currentID[i - 1]++;\n      }\n    }\n  }\n  if (currentID[0] > maxIDindex) {\n    currentID[0] = 0;\n    currentID.unshift(0);\n  }\n  return currentID;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>, prefix: string) => string}\n */\nconst getIDstring = (arr, prefix) => {\n  return prefix + arr.map((i) => generateIDchars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   remove?: boolean,\n *   minify?: boolean,\n *   prefix?: string,\n *   preserve?: Array<string>,\n *   preservePrefixes?: Array<string>,\n *   force?: boolean,\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    prefix = '',\n    preserve = [],\n    preservePrefixes = [],\n    force = false,\n  } = params;\n  const preserveIDs = new Set(\n    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []\n  );\n  const preserveIDPrefixes = Array.isArray(preservePrefixes)\n    ? preservePrefixes\n    : preservePrefixes\n    ? [preservePrefixes]\n    : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if (\n            (node.name === 'style' || node.name === 'script') &&\n            node.children.length !== 0\n          ) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (id != null) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({ element: node, name, value });\n            }\n          }\n        }\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n        const isIdPreserved = (id) =>\n          preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n        let currentID = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIDString = null;\n              do {\n                currentID = generateID(currentID);\n                currentIDString = getIDstring(currentID, prefix);\n              } while (isIdPreserved(currentIDString));\n              node.attributes.id = currentIDString;\n              for (const { element, name, value } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(\n                    `#${id}`,\n                    `#${currentIDString}`\n                  );\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(\n                    `${id}.`,\n                    `${currentIDString}.`\n                  );\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}