{"ast":null,"code":"'use strict';\n\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\n\nconst {\n  elems,\n  attrsGroups,\n  elemsGroups,\n  attrsGroupsDefaults,\n  presentationNonInheritableGroupAttrs\n} = require('./_collections');\n\nexports.type = 'visitor';\nexports.name = 'removeUnknownsAndDefaults';\nexports.active = true;\nexports.description = 'removes unknown elements content and attributes, removes attrs with default values'; // resolve all groups references\n\n/**\n * @type {Map<string, Set<string>>}\n */\n\nconst allowedChildrenPerElement = new Map();\n/**\n * @type {Map<string, Set<string>>}\n */\n\nconst allowedAttributesPerElement = new Map();\n/**\n * @type {Map<string, Map<string, string>>}\n */\n\nconst attributesDefaultsPerElement = new Map();\n\nfor (const [name, config] of Object.entries(elems)) {\n  /**\n   * @type {Set<string>}\n   */\n  const allowedChildren = new Set();\n\n  if (config.content) {\n    for (const elementName of config.content) {\n      allowedChildren.add(elementName);\n    }\n  }\n\n  if (config.contentGroups) {\n    for (const contentGroupName of config.contentGroups) {\n      const elemsGroup = elemsGroups[contentGroupName];\n\n      if (elemsGroup) {\n        for (const elementName of elemsGroup) {\n          allowedChildren.add(elementName);\n        }\n      }\n    }\n  }\n  /**\n   * @type {Set<string>}\n   */\n\n\n  const allowedAttributes = new Set();\n\n  if (config.attrs) {\n    for (const attrName of config.attrs) {\n      allowedAttributes.add(attrName);\n    }\n  }\n  /**\n   * @type {Map<string, string>}\n   */\n\n\n  const attributesDefaults = new Map();\n\n  if (config.defaults) {\n    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {\n      attributesDefaults.set(attrName, defaultValue);\n    }\n  }\n\n  for (const attrsGroupName of config.attrsGroups) {\n    const attrsGroup = attrsGroups[attrsGroupName];\n\n    if (attrsGroup) {\n      for (const attrName of attrsGroup) {\n        allowedAttributes.add(attrName);\n      }\n    }\n\n    const groupDefaults = attrsGroupsDefaults[attrsGroupName];\n\n    if (groupDefaults) {\n      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {\n        attributesDefaults.set(attrName, defaultValue);\n      }\n    }\n  }\n\n  allowedChildrenPerElement.set(name, allowedChildren);\n  allowedAttributesPerElement.set(name, allowedAttributes);\n  attributesDefaultsPerElement.set(name, attributesDefaults);\n}\n/**\n * Remove unknown elements content and attributes,\n * remove attributes with default values.\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   unknownContent?: boolean,\n *   unknownAttrs?: boolean,\n *   defaultAttrs?: boolean,\n *   uselessOverrides?: boolean,\n *   keepDataAttrs?: boolean,\n *   keepAriaAttrs?: boolean,\n *   keepRoleAttr?: boolean,\n * }>}\n */\n\n\nexports.fn = (root, params) => {\n  const {\n    unknownContent = true,\n    unknownAttrs = true,\n    defaultAttrs = true,\n    uselessOverrides = true,\n    keepDataAttrs = true,\n    keepAriaAttrs = true,\n    keepRoleAttr = false\n  } = params;\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip namespaced elements\n        if (node.name.includes(':')) {\n          return;\n        } // skip visiting foreignObject subtree\n\n\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        } // remove unknown element's content\n\n\n        if (unknownContent && parentNode.type === 'element') {\n          const allowedChildren = allowedChildrenPerElement.get(parentNode.name);\n\n          if (allowedChildren == null || allowedChildren.size === 0) {\n            // remove unknown elements\n            if (allowedChildrenPerElement.get(node.name) == null) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          } else {\n            // remove not allowed children\n            if (allowedChildren.has(node.name) === false) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          }\n        }\n\n        const allowedAttributes = allowedAttributesPerElement.get(node.name);\n        const attributesDefaults = attributesDefaultsPerElement.get(node.name);\n        const computedParentStyle = parentNode.type === 'element' ? computeStyle(stylesheet, parentNode) : null; // remove element's unknown attrs and attrs with default values\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (keepDataAttrs && name.startsWith('data-')) {\n            continue;\n          }\n\n          if (keepAriaAttrs && name.startsWith('aria-')) {\n            continue;\n          }\n\n          if (keepRoleAttr && name === 'role') {\n            continue;\n          } // skip xmlns attribute\n\n\n          if (name === 'xmlns') {\n            continue;\n          } // skip namespaced attributes except xml:* and xlink:*\n\n\n          if (name.includes(':')) {\n            const [prefix] = name.split(':');\n\n            if (prefix !== 'xml' && prefix !== 'xlink') {\n              continue;\n            }\n          }\n\n          if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {\n            delete node.attributes[name];\n          }\n\n          if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {\n            // keep defaults if parent has own or inherited style\n            if (computedParentStyle == null || computedParentStyle[name] == null) {\n              delete node.attributes[name];\n            }\n          }\n\n          if (uselessOverrides && node.attributes.id == null) {\n            const style = computedParentStyle == null ? null : computedParentStyle[name];\n\n            if (presentationNonInheritableGroupAttrs.includes(name) === false && style != null && style.type === 'static' && style.value === value) {\n              delete node.attributes[name];\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/removeUnknownsAndDefaults.js"],"names":["visitSkip","detachNodeFromParent","require","collectStylesheet","computeStyle","elems","attrsGroups","elemsGroups","attrsGroupsDefaults","presentationNonInheritableGroupAttrs","exports","type","name","active","description","allowedChildrenPerElement","Map","allowedAttributesPerElement","attributesDefaultsPerElement","config","Object","entries","allowedChildren","Set","content","elementName","add","contentGroups","contentGroupName","elemsGroup","allowedAttributes","attrs","attrName","attributesDefaults","defaults","defaultValue","set","attrsGroupName","attrsGroup","groupDefaults","fn","root","params","unknownContent","unknownAttrs","defaultAttrs","uselessOverrides","keepDataAttrs","keepAriaAttrs","keepRoleAttr","stylesheet","element","enter","node","parentNode","includes","get","size","has","computedParentStyle","value","attributes","startsWith","prefix","split","id","style"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst {\n  elems,\n  attrsGroups,\n  elemsGroups,\n  attrsGroupsDefaults,\n  presentationNonInheritableGroupAttrs,\n} = require('./_collections');\n\nexports.type = 'visitor';\nexports.name = 'removeUnknownsAndDefaults';\nexports.active = true;\nexports.description =\n  'removes unknown elements content and attributes, removes attrs with default values';\n\n// resolve all groups references\n\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedChildrenPerElement = new Map();\n/**\n * @type {Map<string, Set<string>>}\n */\nconst allowedAttributesPerElement = new Map();\n/**\n * @type {Map<string, Map<string, string>>}\n */\nconst attributesDefaultsPerElement = new Map();\n\nfor (const [name, config] of Object.entries(elems)) {\n  /**\n   * @type {Set<string>}\n   */\n  const allowedChildren = new Set();\n  if (config.content) {\n    for (const elementName of config.content) {\n      allowedChildren.add(elementName);\n    }\n  }\n  if (config.contentGroups) {\n    for (const contentGroupName of config.contentGroups) {\n      const elemsGroup = elemsGroups[contentGroupName];\n      if (elemsGroup) {\n        for (const elementName of elemsGroup) {\n          allowedChildren.add(elementName);\n        }\n      }\n    }\n  }\n  /**\n   * @type {Set<string>}\n   */\n  const allowedAttributes = new Set();\n  if (config.attrs) {\n    for (const attrName of config.attrs) {\n      allowedAttributes.add(attrName);\n    }\n  }\n  /**\n   * @type {Map<string, string>}\n   */\n  const attributesDefaults = new Map();\n  if (config.defaults) {\n    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {\n      attributesDefaults.set(attrName, defaultValue);\n    }\n  }\n  for (const attrsGroupName of config.attrsGroups) {\n    const attrsGroup = attrsGroups[attrsGroupName];\n    if (attrsGroup) {\n      for (const attrName of attrsGroup) {\n        allowedAttributes.add(attrName);\n      }\n    }\n    const groupDefaults = attrsGroupsDefaults[attrsGroupName];\n    if (groupDefaults) {\n      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {\n        attributesDefaults.set(attrName, defaultValue);\n      }\n    }\n  }\n  allowedChildrenPerElement.set(name, allowedChildren);\n  allowedAttributesPerElement.set(name, allowedAttributes);\n  attributesDefaultsPerElement.set(name, attributesDefaults);\n}\n\n/**\n * Remove unknown elements content and attributes,\n * remove attributes with default values.\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   unknownContent?: boolean,\n *   unknownAttrs?: boolean,\n *   defaultAttrs?: boolean,\n *   uselessOverrides?: boolean,\n *   keepDataAttrs?: boolean,\n *   keepAriaAttrs?: boolean,\n *   keepRoleAttr?: boolean,\n * }>}\n */\nexports.fn = (root, params) => {\n  const {\n    unknownContent = true,\n    unknownAttrs = true,\n    defaultAttrs = true,\n    uselessOverrides = true,\n    keepDataAttrs = true,\n    keepAriaAttrs = true,\n    keepRoleAttr = false,\n  } = params;\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip namespaced elements\n        if (node.name.includes(':')) {\n          return;\n        }\n        // skip visiting foreignObject subtree\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n\n        // remove unknown element's content\n        if (unknownContent && parentNode.type === 'element') {\n          const allowedChildren = allowedChildrenPerElement.get(\n            parentNode.name\n          );\n          if (allowedChildren == null || allowedChildren.size === 0) {\n            // remove unknown elements\n            if (allowedChildrenPerElement.get(node.name) == null) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          } else {\n            // remove not allowed children\n            if (allowedChildren.has(node.name) === false) {\n              detachNodeFromParent(node, parentNode);\n              return;\n            }\n          }\n        }\n\n        const allowedAttributes = allowedAttributesPerElement.get(node.name);\n        const attributesDefaults = attributesDefaultsPerElement.get(node.name);\n        const computedParentStyle =\n          parentNode.type === 'element'\n            ? computeStyle(stylesheet, parentNode)\n            : null;\n\n        // remove element's unknown attrs and attrs with default values\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (keepDataAttrs && name.startsWith('data-')) {\n            continue;\n          }\n          if (keepAriaAttrs && name.startsWith('aria-')) {\n            continue;\n          }\n          if (keepRoleAttr && name === 'role') {\n            continue;\n          }\n          // skip xmlns attribute\n          if (name === 'xmlns') {\n            continue;\n          }\n          // skip namespaced attributes except xml:* and xlink:*\n          if (name.includes(':')) {\n            const [prefix] = name.split(':');\n            if (prefix !== 'xml' && prefix !== 'xlink') {\n              continue;\n            }\n          }\n\n          if (\n            unknownAttrs &&\n            allowedAttributes &&\n            allowedAttributes.has(name) === false\n          ) {\n            delete node.attributes[name];\n          }\n          if (\n            defaultAttrs &&\n            node.attributes.id == null &&\n            attributesDefaults &&\n            attributesDefaults.get(name) === value\n          ) {\n            // keep defaults if parent has own or inherited style\n            if (\n              computedParentStyle == null ||\n              computedParentStyle[name] == null\n            ) {\n              delete node.attributes[name];\n            }\n          }\n          if (uselessOverrides && node.attributes.id == null) {\n            const style =\n              computedParentStyle == null ? null : computedParentStyle[name];\n            if (\n              presentationNonInheritableGroupAttrs.includes(name) === false &&\n              style != null &&\n              style.type === 'static' &&\n              style.value === value\n            ) {\n              delete node.attributes[name];\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}