{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1._)`{passingSchemas: ${params.passing}}`;\n  }\n};\nconst def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    const schArr = schema;\n    const valid = gen.let(\"valid\", false);\n    const passing = gen.let(\"passing\", null);\n    const schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing\n    }); // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf);\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n\n    function validateOneOf() {\n      schArr.forEach((sch, i) => {\n        let schCxt;\n\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n\n        if (i > 0) {\n          gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAOA;;AACA;;AASA,MAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE,wCAD2B;AAEpCC,QAAM,EAAE;AAAA,QAAC;AAACA;AAAD,KAAD;AAAA,WAAc,gBAAC,oBAAoBA,MAAM,CAACC,OAAO,GAAjD;AAAA;AAF4B,CAAtC;AAKA,MAAMC,GAAG,GAA0B;AACjCC,SAAO,EAAE,OADwB;AAEjCC,YAAU,EAAE,OAFqB;AAGjCC,aAAW,EAAE,IAHoB;AAIjCP,OAJiC;;AAKjCQ,MAAI,CAACC,GAAD,EAAgB;AAClB,UAAM;AAACC,SAAD;AAAMC,YAAN;AAAcC,kBAAd;AAA4BC;AAA5B,QAAkCJ,GAAxC;AACA;;AACA,QAAI,CAACK,KAAK,CAACC,OAAN,CAAcJ,MAAd,CAAL,EAA4B,MAAM,IAAIK,KAAJ,CAAU,0BAAV,CAAN;AAC5B,QAAIH,EAAE,CAACI,IAAH,CAAQC,aAAR,IAAyBN,YAAY,CAACM,aAA1C,EAAyD;AACzD,UAAMC,MAAM,GAAgBR,MAA5B;AACA,UAAMS,KAAK,GAAGV,GAAG,CAACW,GAAJ,CAAQ,OAAR,EAAiB,KAAjB,CAAd;AACA,UAAMlB,OAAO,GAAGO,GAAG,CAACW,GAAJ,CAAQ,SAAR,EAAmB,IAAnB,CAAhB;AACA,UAAMC,QAAQ,GAAGZ,GAAG,CAACa,IAAJ,CAAS,QAAT,CAAjB;AACAd,OAAG,CAACe,SAAJ,CAAc;AAACrB;AAAD,KAAd,EATkB,CAUlB;;AAEAO,OAAG,CAACe,KAAJ,CAAUC,aAAV;AAEAjB,OAAG,CAACkB,MAAJ,CACEP,KADF,EAEE,MAAMX,GAAG,CAACmB,KAAJ,EAFR,EAGE,MAAMnB,GAAG,CAACT,KAAJ,CAAU,IAAV,CAHR;;AAMA,aAAS0B,aAAT,GAAsB;AACpBP,YAAM,CAACU,OAAP,CAAe,CAACC,GAAD,EAAiBC,CAAjB,KAA8B;AAC3C,YAAIC,MAAJ;;AACA,YAAI,8BAAkBnB,EAAlB,EAAsBiB,GAAtB,CAAJ,EAAgC;AAC9BpB,aAAG,CAACuB,GAAJ,CAAQX,QAAR,EAAkB,IAAlB;AACD,SAFD,MAEO;AACLU,gBAAM,GAAGvB,GAAG,CAACyB,SAAJ,CACP;AACE7B,mBAAO,EAAE,OADX;AAEE8B,sBAAU,EAAEJ,CAFd;AAGEK,yBAAa,EAAE;AAHjB,WADO,EAMPd,QANO,CAAT;AAQD;;AAED,YAAIS,CAAC,GAAG,CAAR,EAAW;AACTrB,aAAG,CACA2B,EADH,CACM,gBAAC,GAAGf,QAAQ,OAAOF,KAAK,EAD9B,EAEGkB,MAFH,CAEUlB,KAFV,EAEiB,KAFjB,EAGGkB,MAHH,CAGUnC,OAHV,EAGmB,gBAAC,IAAIA,OAAO,KAAK4B,CAAC,GAHrC,EAIGQ,IAJH;AAKD;;AAED7B,WAAG,CAAC2B,EAAJ,CAAOf,QAAP,EAAiB,MAAK;AACpBZ,aAAG,CAAC4B,MAAJ,CAAWlB,KAAX,EAAkB,IAAlB;AACAV,aAAG,CAAC4B,MAAJ,CAAWnC,OAAX,EAAoB4B,CAApB;AACA,cAAIC,MAAJ,EAAYvB,GAAG,CAAC+B,cAAJ,CAAmBR,MAAnB,EAA2BS,cAA3B;AACb,SAJD;AAKD,OA5BD;AA6BD;AACF;;AAxDgC,CAAnC;AA2DAC,kBAAetC,GAAf","names":["error","message","params","passing","def","keyword","schemaType","trackErrors","code","cxt","gen","schema","parentSchema","it","Array","isArray","Error","opts","discriminator","schArr","valid","let","schValid","name","setParams","block","validateOneOf","result","reset","forEach","sch","i","schCxt","var","subschema","schemaProp","compositeRule","if","assign","else","mergeEvaluated","codegen_1","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}