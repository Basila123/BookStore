{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\n\nvar validate_1 = require(\"./compile/validate\");\n\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\n\nvar codegen_1 = require(\"./compile/codegen\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\n\nconst validation_error_1 = require(\"./runtime/validation_error\");\n\nconst ref_error_1 = require(\"./compile/ref_error\");\n\nconst rules_1 = require(\"./compile/rules\");\n\nconst compile_1 = require(\"./compile\");\n\nconst codegen_2 = require(\"./compile/codegen\");\n\nconst resolve_1 = require(\"./compile/resolve\");\n\nconst dataType_1 = require(\"./compile/validate/dataType\");\n\nconst util_1 = require(\"./compile/util\");\n\nconst $dataRefSchema = require(\"./refs/data.json\");\n\nconst uri_1 = require(\"./runtime/uri\");\n\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\n\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200; // eslint-disable-next-line complexity\n\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n\n  const s = o.strict;\n\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? { ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\n\nclass Ajv {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = { ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n\n    this._addVocabularies();\n\n    this._addDefaultMetaSchema();\n\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n\n    if (schemaId === \"id\") {\n      _dataRefSchema = { ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n\n  validate(schemaKeyRef, // key, ref or schema object\n  data // to be validated\n  ) {\n    let v;\n\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n\n    async function runCompileAsync(_schema, _meta) {\n      await loadMetaSchema.call(this, _schema.$schema);\n\n      const sch = this._addSchema(_schema, _meta);\n\n      return sch.validate || _compileAsync.call(this, sch);\n    }\n\n    async function loadMetaSchema($ref) {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {\n          $ref\n        }, true);\n      }\n    }\n\n    async function _compileAsync(sch) {\n      try {\n        return this._compileSchemaEnv(sch);\n      } catch (e) {\n        if (!(e instanceof ref_error_1.default)) throw e;\n        checkLoaded.call(this, e);\n        await loadMissingSchema.call(this, e.missingSchema);\n        return _compileAsync.call(this, sch);\n      }\n    }\n\n    function checkLoaded(_ref) {\n      let {\n        missingSchema: ref,\n        missingRef\n      } = _ref;\n\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n\n    async function loadMissingSchema(ref) {\n      const _schema = await _loadSchema.call(this, ref);\n\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n    }\n\n    async function _loadSchema(ref) {\n      const p = this._loading[ref];\n      if (p) return p;\n\n      try {\n        return await (this._loading[ref] = loadSchema(ref));\n      } finally {\n        delete this._loading[ref];\n      }\n    }\n  } // Adds schema to the instance\n\n\n  addSchema(schema, // If array is passed, `key` will be ignored\n  key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta) {\n    let _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n\n      return this;\n    }\n\n    let id;\n\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n\n    key = (0, resolve_1.normalizeId)(key || id);\n\n    this._checkUnique(key);\n\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  } // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n\n\n  addMetaSchema(schema, key) {\n    let _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;\n\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  } //  Validate schema against its meta-schema\n\n\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n\n    const valid = this.validate($schema, schema);\n\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n\n    return valid;\n  } // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n\n\n  getSchema(keyRef) {\n    let sch;\n\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n\n    return sch.validate || this._compileSchemaEnv(sch);\n  } // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n\n\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n\n      return this;\n    }\n\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n\n        this._removeAllSchemas(this.refs);\n\n        this._cache.clear();\n\n        return this;\n\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n\n          this._cache.delete(cacheKey);\n\n          let id = schemaKeyRef[this.opts.schemaId];\n\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n\n          return this;\n        }\n\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  } // add \"vocabulary\" - a collection of keywords\n\n\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n\n    return this;\n  }\n\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n\n    checkKeyword.call(this, keyword, def);\n\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n\n    keywordMetaschema.call(this, def);\n    const definition = { ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  } // Remove keyword\n\n\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n\n    return this;\n  } // Add format\n\n\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n\n  errorsText() {\n    let errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;\n    let {\n      separator = \", \",\n      dataVar = \"data\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n\n      let keywords = metaSchema;\n\n      for (const seg of segments) keywords = keywords[seg];\n\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n\n    return metaSchema;\n  }\n\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n\n  _addSchema(schema, meta, baseId) {\n    let validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n    let addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n\n    let sch = this._cache.get(schema);\n\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n\n    this._cache.set(sch.schema, sch);\n\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n\n}\n\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\n\nfunction checkOptions(checkOpts, options, msg) {\n  let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"error\";\n\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\n\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\n\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\n\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\n\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\n\nfunction getMetaSchemaOptions() {\n  const metaOpts = { ...this.opts\n  };\n\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n\n  return metaOpts;\n}\n\nconst noLogs = {\n  log() {},\n\n  warn() {},\n\n  error() {}\n\n};\n\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\n\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\n\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(_ref2 => {\n    let {\n      type: t\n    } = _ref2;\n    return t === dataType;\n  });\n\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: { ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\n\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\n\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\n\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"mappings":"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","names":["Object","enumerable","get","defaultRegExp","str","flags","RegExp","code","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","MAX_EXPRESSION","requiredOptions","o","s","strict","_optz","_a","optimize","undefined","regExp","_b","_c","uriResolver","_d","uri_1","strictSchema","_e","_f","strictNumbers","_g","_h","strictTypes","_j","_k","strictTuples","_l","_m","strictRequired","_o","_p","loopRequired","_q","loopEnum","_r","meta","_s","messages","_t","inlineRefs","_u","schemaId","_v","addUsedSchema","_w","validateSchema","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","Ajv","constructor","opts","Map","es5","lines","scope","codegen_2","prefixes","logger","getLogger","formatOpt","RULES","checkOptions","call","_metaOpts","getMetaSchemaOptions","formats","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","$dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","Error","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","ref_error_1","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","refs","_loadSchema","addSchema","p","_loading","key","_validateSchema","Array","isArray","_checkUnique","schemas","throwOrLogError","warn","message","errorsText","error","keyRef","getSchEnv","root","compile_1","removeSchema","_removeAllSchemas","_cache","clear","delete","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","length","checkKeyword","kwd","addRule","keywordMetaschema","definition","type","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","stringify","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","resolve_1","set","startsWith","_compileMetaSchema","currentOpts","exports","validation_error_1","checkOpts","options","log","opt","optsSchemas","defs","metaOpts","noLogs","console","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/core.ts"],"sourcesContent":["export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n"]},"metadata":{},"sourceType":"script"}