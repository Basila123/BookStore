{"ast":null,"code":"'use strict';\n\nexports.type = 'visitor';\nexports.name = 'sortDefsChildren';\nexports.active = true;\nexports.description = 'Sorts children of <defs> to improve compression';\n/**\n * Sorts children of defs in order to improve compression.\n * Sorted first by frequency then by element name length then by element name (to ensure grouping).\n *\n * @author David Leston\n *\n * @type {import('../lib/types').Plugin<void>}\n */\n\nexports.fn = () => {\n  return {\n    element: {\n      enter: node => {\n        if (node.name === 'defs') {\n          /**\n           * @type {Map<string, number>}\n           */\n          const frequencies = new Map();\n\n          for (const child of node.children) {\n            if (child.type === 'element') {\n              const frequency = frequencies.get(child.name);\n\n              if (frequency == null) {\n                frequencies.set(child.name, 1);\n              } else {\n                frequencies.set(child.name, frequency + 1);\n              }\n            }\n          }\n\n          node.children.sort((a, b) => {\n            if (a.type !== 'element' || b.type !== 'element') {\n              return 0;\n            }\n\n            const aFrequency = frequencies.get(a.name);\n            const bFrequency = frequencies.get(b.name);\n\n            if (aFrequency != null && bFrequency != null) {\n              const frequencyComparison = bFrequency - aFrequency;\n\n              if (frequencyComparison !== 0) {\n                return frequencyComparison;\n              }\n            }\n\n            const lengthComparison = b.name.length - a.name.length;\n\n            if (lengthComparison !== 0) {\n              return lengthComparison;\n            }\n\n            if (a.name !== b.name) {\n              return a.name > b.name ? -1 : 1;\n            }\n\n            return 0;\n          });\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/sortDefsChildren.js"],"names":["exports","type","name","active","description","fn","element","enter","node","frequencies","Map","child","children","frequency","get","set","sort","a","b","aFrequency","bFrequency","frequencyComparison","lengthComparison","length"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,IAAR,GAAe,SAAf;AACAD,OAAO,CAACE,IAAR,GAAe,kBAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,IAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,iDAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,OAAO,CAACK,EAAR,GAAa,MAAM;AACjB,SAAO;AACLC,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAGC,IAAD,IAAU;AACf,YAAIA,IAAI,CAACN,IAAL,KAAc,MAAlB,EAA0B;AACxB;AACV;AACA;AACU,gBAAMO,WAAW,GAAG,IAAIC,GAAJ,EAApB;;AACA,eAAK,MAAMC,KAAX,IAAoBH,IAAI,CAACI,QAAzB,EAAmC;AACjC,gBAAID,KAAK,CAACV,IAAN,KAAe,SAAnB,EAA8B;AAC5B,oBAAMY,SAAS,GAAGJ,WAAW,CAACK,GAAZ,CAAgBH,KAAK,CAACT,IAAtB,CAAlB;;AACA,kBAAIW,SAAS,IAAI,IAAjB,EAAuB;AACrBJ,gBAAAA,WAAW,CAACM,GAAZ,CAAgBJ,KAAK,CAACT,IAAtB,EAA4B,CAA5B;AACD,eAFD,MAEO;AACLO,gBAAAA,WAAW,CAACM,GAAZ,CAAgBJ,KAAK,CAACT,IAAtB,EAA4BW,SAAS,GAAG,CAAxC;AACD;AACF;AACF;;AACDL,UAAAA,IAAI,CAACI,QAAL,CAAcI,IAAd,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC3B,gBAAID,CAAC,CAAChB,IAAF,KAAW,SAAX,IAAwBiB,CAAC,CAACjB,IAAF,KAAW,SAAvC,EAAkD;AAChD,qBAAO,CAAP;AACD;;AACD,kBAAMkB,UAAU,GAAGV,WAAW,CAACK,GAAZ,CAAgBG,CAAC,CAACf,IAAlB,CAAnB;AACA,kBAAMkB,UAAU,GAAGX,WAAW,CAACK,GAAZ,CAAgBI,CAAC,CAAChB,IAAlB,CAAnB;;AACA,gBAAIiB,UAAU,IAAI,IAAd,IAAsBC,UAAU,IAAI,IAAxC,EAA8C;AAC5C,oBAAMC,mBAAmB,GAAGD,UAAU,GAAGD,UAAzC;;AACA,kBAAIE,mBAAmB,KAAK,CAA5B,EAA+B;AAC7B,uBAAOA,mBAAP;AACD;AACF;;AACD,kBAAMC,gBAAgB,GAAGJ,CAAC,CAAChB,IAAF,CAAOqB,MAAP,GAAgBN,CAAC,CAACf,IAAF,CAAOqB,MAAhD;;AACA,gBAAID,gBAAgB,KAAK,CAAzB,EAA4B;AAC1B,qBAAOA,gBAAP;AACD;;AACD,gBAAIL,CAAC,CAACf,IAAF,KAAWgB,CAAC,CAAChB,IAAjB,EAAuB;AACrB,qBAAOe,CAAC,CAACf,IAAF,GAASgB,CAAC,CAAChB,IAAX,GAAkB,CAAC,CAAnB,GAAuB,CAA9B;AACD;;AACD,mBAAO,CAAP;AACD,WApBD;AAqBD;AACF;AAvCM;AADJ,GAAP;AA2CD,CA5CD","sourcesContent":["'use strict';\n\nexports.type = 'visitor';\nexports.name = 'sortDefsChildren';\nexports.active = true;\nexports.description = 'Sorts children of <defs> to improve compression';\n\n/**\n * Sorts children of defs in order to improve compression.\n * Sorted first by frequency then by element name length then by element name (to ensure grouping).\n *\n * @author David Leston\n *\n * @type {import('../lib/types').Plugin<void>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      enter: (node) => {\n        if (node.name === 'defs') {\n          /**\n           * @type {Map<string, number>}\n           */\n          const frequencies = new Map();\n          for (const child of node.children) {\n            if (child.type === 'element') {\n              const frequency = frequencies.get(child.name);\n              if (frequency == null) {\n                frequencies.set(child.name, 1);\n              } else {\n                frequencies.set(child.name, frequency + 1);\n              }\n            }\n          }\n          node.children.sort((a, b) => {\n            if (a.type !== 'element' || b.type !== 'element') {\n              return 0;\n            }\n            const aFrequency = frequencies.get(a.name);\n            const bFrequency = frequencies.get(b.name);\n            if (aFrequency != null && bFrequency != null) {\n              const frequencyComparison = bFrequency - aFrequency;\n              if (frequencyComparison !== 0) {\n                return frequencyComparison;\n              }\n            }\n            const lengthComparison = b.name.length - a.name.length;\n            if (lengthComparison !== 0) {\n              return lengthComparison;\n            }\n            if (a.name !== b.name) {\n              return a.name > b.name ? -1 : 1;\n            }\n            return 0;\n          });\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}