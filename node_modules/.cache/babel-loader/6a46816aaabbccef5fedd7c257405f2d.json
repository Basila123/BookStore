{"ast":null,"code":"'use strict';\n\nconst selectorParser = require('postcss-selector-parser');\n\nconst valueParser = require('postcss-value-parser');\n\nconst {\n  parser\n} = require('../parser.js');\n\nconst reducer = require('./reducer.js');\n\nconst stringifier = require('./stringifier.js');\n\nconst MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;\n/**\n * @param {string} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\n\nfunction transformValue(value, options, result, item) {\n  return valueParser(value).walk(node => {\n    // skip anything which isn't a calc() function\n    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {\n      return;\n    } // stringify calc expression and produce an AST\n\n\n    const contents = valueParser.stringify(node.nodes);\n    const ast = parser.parse(contents); // reduce AST to its simplest form, that is, either to a single value\n    // or a simplified calc expression\n\n    const reducedAst = reducer(ast, options.precision); // stringify AST and write it back\n\n    /** @type {valueParser.Node} */\n\n    node.type = 'word';\n    node.value = stringifier(node.value, reducedAst, value, options, result, item);\n    return false;\n  }).toString();\n}\n/**\n * @param {import(\"postcss-selector-parser\").Selectors} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\n\n\nfunction transformSelector(value, options, result, item) {\n  return selectorParser(selectors => {\n    selectors.walk(node => {\n      // attribute value\n      // e.g. the \"calc(3*3)\" part of \"div[data-size=\"calc(3*3)\"]\"\n      if (node.type === 'attribute' && node.value) {\n        node.setValue(transformValue(node.value, options, result, item));\n      } // tag value\n      // e.g. the \"calc(3*3)\" part of \"div:nth-child(2n + calc(3*3))\"\n\n\n      if (node.type === 'tag') {\n        node.value = transformValue(node.value, options, result, item);\n      }\n\n      return;\n    });\n  }).processSync(value);\n}\n/**\n * @param {any} node\n * @param {{precision: number, preserve: boolean, warnWhenCannotResolve: boolean}} options\n * @param {'value'|'params'|'selector'} property\n * @param {import(\"postcss\").Result} result\n */\n\n\nmodule.exports = (node, property, options, result) => {\n  let value = node[property];\n\n  try {\n    value = property === 'selector' ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node);\n  } catch (error) {\n    if (error instanceof Error) {\n      result.warn(error.message, {\n        node\n      });\n    } else {\n      result.warn('Error', {\n        node\n      });\n    }\n\n    return;\n  } // if the preserve option is enabled and the value has changed, write the\n  // transformed value into a cloned node which is inserted before the current\n  // node, preserving the original value. Otherwise, overwrite the original\n  // value.\n\n\n  if (options.preserve && node[property] !== value) {\n    const clone = node.clone();\n    clone[property] = value;\n    node.parent.insertBefore(node, clone);\n  } else {\n    node[property] = value;\n  }\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-calc/src/lib/transform.js"],"names":["selectorParser","require","valueParser","parser","reducer","stringifier","MATCH_CALC","transformValue","value","options","result","item","walk","node","type","test","contents","stringify","nodes","ast","parse","reducedAst","precision","toString","transformSelector","selectors","setValue","processSync","module","exports","property","error","Error","warn","message","preserve","clone","parent","insertBefore"],"mappings":"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","sourcesContent":["'use strict';\nconst selectorParser = require('postcss-selector-parser');\nconst valueParser = require('postcss-value-parser');\n\nconst { parser } = require('../parser.js');\n\nconst reducer = require('./reducer.js');\nconst stringifier = require('./stringifier.js');\n\nconst MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;\n\n/**\n * @param {string} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformValue(value, options, result, item) {\n  return valueParser(value)\n    .walk((node) => {\n      // skip anything which isn't a calc() function\n      if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {\n        return;\n      }\n\n      // stringify calc expression and produce an AST\n      const contents = valueParser.stringify(node.nodes);\n      const ast = parser.parse(contents);\n\n      // reduce AST to its simplest form, that is, either to a single value\n      // or a simplified calc expression\n      const reducedAst = reducer(ast, options.precision);\n\n      // stringify AST and write it back\n      /** @type {valueParser.Node} */ (node).type = 'word';\n      node.value = stringifier(\n        node.value,\n        reducedAst,\n        value,\n        options,\n        result,\n        item\n      );\n\n      return false;\n    })\n    .toString();\n}\n/**\n * @param {import(\"postcss-selector-parser\").Selectors} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformSelector(value, options, result, item) {\n  return selectorParser((selectors) => {\n    selectors.walk((node) => {\n      // attribute value\n      // e.g. the \"calc(3*3)\" part of \"div[data-size=\"calc(3*3)\"]\"\n      if (node.type === 'attribute' && node.value) {\n        node.setValue(transformValue(node.value, options, result, item));\n      }\n\n      // tag value\n      // e.g. the \"calc(3*3)\" part of \"div:nth-child(2n + calc(3*3))\"\n      if (node.type === 'tag') {\n        node.value = transformValue(node.value, options, result, item);\n      }\n\n      return;\n    });\n  }).processSync(value);\n}\n\n/**\n * @param {any} node\n * @param {{precision: number, preserve: boolean, warnWhenCannotResolve: boolean}} options\n * @param {'value'|'params'|'selector'} property\n * @param {import(\"postcss\").Result} result\n */\nmodule.exports = (node, property, options, result) => {\n  let value = node[property];\n\n  try {\n    value =\n      property === 'selector'\n        ? transformSelector(node[property], options, result, node)\n        : transformValue(node[property], options, result, node);\n  } catch (error) {\n    if (error instanceof Error) {\n      result.warn(error.message, { node });\n    } else {\n      result.warn('Error', { node });\n    }\n    return;\n  }\n\n  // if the preserve option is enabled and the value has changed, write the\n  // transformed value into a cloned node which is inserted before the current\n  // node, preserving the original value. Otherwise, overwrite the original\n  // value.\n  if (options.preserve && node[property] !== value) {\n    const clone = node.clone();\n    clone[property] = value;\n    node.parent.insertBefore(node, clone);\n  } else {\n    node[property] = value;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}