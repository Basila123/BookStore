{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n */\n// @ts-ignore sax will be replaced with something else later\n\nconst SAX = require('@trysound/sax');\n\nconst JSAPI = require('./svgo/jsAPI.js');\n\nconst {\n  textElems\n} = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines.slice(startLine, endLine).map((line, index) => {\n      const lineSlice = line.slice(startColumn, endColumn);\n      let ellipsisPrefix = '';\n      let ellipsisSuffix = '';\n\n      if (startColumn !== 0) {\n        ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n      }\n\n      if (endColumn < line.length - 1) {\n        ellipsisSuffix = '…';\n      }\n\n      const number = startLine + 1 + index;\n      const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n\n      if (number === this.line) {\n        const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n        const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\\t]/g, ' ');\n        const spacing = gutterSpacing + lineSpacing;\n        return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n      }\n\n      return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n    }).join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true\n};\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\n\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n\n  const root = new JSAPI({\n    type: 'root',\n    children: []\n  });\n  /**\n   * @type {XastParent}\n   */\n\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n\n  const stack = [root];\n  /**\n   * @type {<T extends XastNode>(node: T) => T}\n   */\n\n  const pushToContent = node => {\n    const wrapped = new JSAPI(node, current);\n    current.children.push(wrapped);\n    return wrapped;\n  };\n  /**\n   * @type {(doctype: string) => void}\n   */\n\n\n  sax.ondoctype = doctype => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype\n      }\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n\n\n  sax.onprocessinginstruction = data => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(comment: string) => void}\n   */\n\n\n  sax.oncomment = comment => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim()\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(cdata: string) => void}\n   */\n\n\n  sax.oncdata = cdata => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n\n\n  sax.onopentag = data => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: []\n    };\n\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n\n    element = pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n  /**\n   * @type {(text: string) => void}\n   */\n\n\n  sax.ontext = text => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim()\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n  /**\n   * @type {(e: any) => void}\n   */\n\n\n  sax.onerror = e => {\n    const error = new SvgoParserError(e.reason, e.line + 1, e.column, data, from);\n\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\n\nexports.parseSvg = parseSvg;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/lib/parser.js"],"names":["SAX","require","JSAPI","textElems","SvgoParserError","Error","constructor","message","line","column","source","file","name","reason","captureStackTrace","toString","lines","split","startLine","Math","max","endLine","min","length","lineNumberWidth","String","startColumn","endColumn","code","slice","map","index","lineSlice","ellipsisPrefix","ellipsisSuffix","number","gutter","padStart","gutterSpacing","replace","lineSpacing","spacing","join","entityDeclaration","config","strict","trim","normalize","lowercase","xmlns","position","parseSvg","data","from","sax","parser","root","type","children","current","stack","pushToContent","node","wrapped","push","ondoctype","doctype","subsetStart","indexOf","lastIndex","entityMatch","exec","ENTITIES","onprocessinginstruction","value","body","oncomment","comment","oncdata","cdata","onopentag","element","attributes","attr","Object","entries","ontext","text","includes","test","onclosetag","pop","onerror","e","error","write","close","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst JSAPI = require('./svgo/jsAPI.js');\nconst { textElems } = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines\n      .slice(startLine, endLine)\n      .map((line, index) => {\n        const lineSlice = line.slice(startColumn, endColumn);\n        let ellipsisPrefix = '';\n        let ellipsisSuffix = '';\n        if (startColumn !== 0) {\n          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n        }\n        if (endColumn < line.length - 1) {\n          ellipsisSuffix = '…';\n        }\n        const number = startLine + 1 + index;\n        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n        if (number === this.line) {\n          const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n          const lineSpacing = (\n            ellipsisPrefix + line.slice(startColumn, this.column - 1)\n          ).replace(/[^\\t]/g, ' ');\n          const spacing = gutterSpacing + lineSpacing;\n          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n        }\n        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n      })\n      .join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\n\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true,\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = new JSAPI({ type: 'root', children: [] });\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n  const stack = [root];\n\n  /**\n   * @type {<T extends XastNode>(node: T) => T}\n   */\n  const pushToContent = (node) => {\n    const wrapped = new JSAPI(node, current);\n    current.children.push(wrapped);\n    return wrapped;\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = (doctype) => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype,\n      },\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = (data) => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = (comment) => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim(),\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = (cdata) => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = (data) => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: [],\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    element = pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = (text) => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text,\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim(),\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = (e) => {\n    const error = new SvgoParserError(\n      e.reason,\n      e.line + 1,\n      e.column,\n      data,\n      from\n    );\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;\n"]},"metadata":{},"sourceType":"script"}