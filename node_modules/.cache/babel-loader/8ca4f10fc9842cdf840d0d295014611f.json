{"ast":null,"code":"'use strict';\n\nconst {\n  stringify\n} = require('postcss-value-parser');\n\nfunction uniqueFontFamilies(list) {\n  return list.filter((item, i) => {\n    if (item.toLowerCase() === 'monospace') {\n      return true;\n    }\n\n    return i === list.indexOf(item);\n  });\n}\n\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = new Set(['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui']);\n\nfunction makeArray(value, length) {\n  let array = [];\n\n  while (length--) {\n    array[length] = value;\n  }\n\n  return array;\n} // eslint-disable-next-line no-useless-escape\n\n\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character = null;\n  let charCode = null;\n  let value = null;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(0); // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp([...genericFontFamilykeywords].concat(globalKeywords).join('|'), 'i');\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  }); // Escape trailing spaces unless they’re already part of an escape\n\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n\nmodule.exports = function (nodes, opts) {\n  const family = [];\n  let last = null;\n  let i, max;\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last = {\n          type: 'word',\n          value: ''\n        };\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n  let normalizedFamilies = family.map(node => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {\n        return stringify(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return stringify(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = normalizedFamilies.length; i < max; i += 1) {\n      if (genericFontFamilykeywords.has(normalizedFamilies[i].toLowerCase())) {\n        normalizedFamilies = normalizedFamilies.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    normalizedFamilies = uniqueFontFamilies(normalizedFamilies);\n  }\n\n  return [{\n    type: 'word',\n    value: normalizedFamilies.join()\n  }];\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-minify-font-values/src/lib/minify-family.js"],"names":["stringify","require","uniqueFontFamilies","list","filter","item","i","toLowerCase","indexOf","globalKeywords","genericFontFamilykeywords","Set","makeArray","value","length","array","regexSimpleEscapeCharacters","escape","string","escapeForString","counter","character","charCode","output","charAt","charCodeAt","test","toString","slice","firstChar","regexKeyword","RegExp","concat","join","regexInvalidIdentifier","regexSpaceAtStart","regexWhitespace","regexIdentifierCharacter","regexConsecutiveSpaces","regexTrailingEscape","regexTrailingSpace","escapeIdentifierSequence","identifiers","split","index","result","escapeResult","subString","push","replace","$0","$1","$2","spaceCount","escapesNeeded","Math","floor","module","exports","nodes","opts","family","last","max","forEach","node","arr","type","normalizedFamilies","map","isKeyword","removeQuotes","escaped","removeAfterKeyword","has","removeDuplicates"],"mappings":"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","sourcesContent":["'use strict';\nconst { stringify } = require('postcss-value-parser');\n\nfunction uniqueFontFamilies(list) {\n  return list.filter((item, i) => {\n    if (item.toLowerCase() === 'monospace') {\n      return true;\n    }\n    return i === list.indexOf(item);\n  });\n}\n\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = new Set([\n  'sans-serif',\n  'serif',\n  'fantasy',\n  'cursive',\n  'monospace',\n  'system-ui',\n]);\n\nfunction makeArray(value, length) {\n  let array = [];\n  while (length--) {\n    array[length] = value;\n  }\n  return array;\n}\n\n// eslint-disable-next-line no-useless-escape\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character = null;\n  let charCode = null;\n  let value = null;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(0);\n\n    // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (\n      !escapeForString &&\n      regexSimpleEscapeCharacters.test(character)\n    ) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp(\n  [...genericFontFamilykeywords].concat(globalKeywords).join('|'),\n  'i'\n);\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  });\n\n  // Escape trailing spaces unless they’re already part of an escape\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n\nmodule.exports = function (nodes, opts) {\n  const family = [];\n  let last = null;\n  let i, max;\n\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last = { type: 'word', value: '' };\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n\n  let normalizedFamilies = family.map((node) => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (\n        !opts.removeQuotes ||\n        isKeyword ||\n        /[0-9]/.test(node.value.slice(0, 1))\n      ) {\n        return stringify(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return stringify(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = normalizedFamilies.length; i < max; i += 1) {\n      if (genericFontFamilykeywords.has(normalizedFamilies[i].toLowerCase())) {\n        normalizedFamilies = normalizedFamilies.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    normalizedFamilies = uniqueFontFamilies(normalizedFamilies);\n  }\n\n  return [\n    {\n      type: 'word',\n      value: normalizedFamilies.join(),\n    },\n  ];\n};\n"]},"metadata":{},"sourceType":"script"}