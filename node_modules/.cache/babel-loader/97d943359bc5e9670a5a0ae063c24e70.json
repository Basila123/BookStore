{"ast":null,"code":"'use strict';\n\nconst {\n  list\n} = require('postcss');\n\nconst {\n  unit\n} = require('postcss-value-parser');\n\nconst stylehacks = require('stylehacks');\n\nconst canMerge = require('../canMerge');\n\nconst getDecls = require('../getDecls');\n\nconst getValue = require('../getValue');\n\nconst mergeRules = require('../mergeRules');\n\nconst insertCloned = require('../insertCloned');\n\nconst remove = require('../remove');\n\nconst isCustomProp = require('../isCustomProp');\n\nconst canExplode = require('../canExplode');\n\nconst properties = ['column-width', 'column-count'];\nconst auto = 'auto';\nconst inherit = 'inherit';\n/**\n * Normalize a columns shorthand definition. Both of the longhand\n * properties' initial values are 'auto', and as per the spec,\n * omitted values are set to their initial values. Thus, we can\n * remove any 'auto' definition when there are two values.\n *\n * Specification link: https://www.w3.org/TR/css3-multicol/\n */\n\nfunction normalize(values) {\n  if (values[0].toLowerCase() === auto) {\n    return values[1];\n  }\n\n  if (values[1].toLowerCase() === auto) {\n    return values[0];\n  }\n\n  if (values[0].toLowerCase() === inherit && values[1].toLowerCase() === inherit) {\n    return inherit;\n  }\n\n  return values.join(' ');\n}\n\nfunction explode(rule) {\n  rule.walkDecls(/^columns$/i, decl => {\n    if (!canExplode(decl)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    let values = list.space(decl.value);\n\n    if (values.length === 1) {\n      values.push(auto);\n    }\n\n    values.forEach((value, i) => {\n      let prop = properties[1];\n      const dimension = unit(value);\n\n      if (value.toLowerCase() === auto) {\n        prop = properties[i];\n      } else if (dimension && dimension.unit !== '') {\n        prop = properties[0];\n      }\n\n      insertCloned(decl.parent, decl, {\n        prop,\n        value\n      });\n    });\n    decl.remove();\n  });\n}\n\nfunction cleanup(rule) {\n  let decls = getDecls(rule, ['columns'].concat(properties));\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1]; // remove properties of lower precedence\n\n    const lesser = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === 'columns' && node.prop !== lastNode.prop);\n    lesser.forEach(remove);\n    decls = decls.filter(node => !lesser.includes(node)); // get duplicate properties\n\n    let duplicates = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode)));\n    duplicates.forEach(remove);\n    decls = decls.filter(node => node !== lastNode && !duplicates.includes(node));\n  }\n}\n\nfunction merge(rule) {\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n      insertCloned(lastNode.parent, lastNode, {\n        prop: 'columns',\n        value: normalize(rules.map(getValue))\n      });\n      rules.forEach(remove);\n      return true;\n    }\n  });\n  cleanup(rule);\n}\n\nmodule.exports = {\n  explode,\n  merge\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-merge-longhand/src/lib/decl/columns.js"],"names":["list","require","unit","stylehacks","canMerge","getDecls","getValue","mergeRules","insertCloned","remove","isCustomProp","canExplode","properties","auto","inherit","normalize","values","toLowerCase","join","explode","rule","walkDecls","decl","detect","space","value","length","push","forEach","i","prop","dimension","parent","cleanup","decls","concat","lastNode","lesser","filter","node","important","includes","duplicates","merge","rules","some","map","module","exports"],"mappings":"AAAA;;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAWD,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAMO,YAAY,GAAGP,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMQ,MAAM,GAAGR,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMS,YAAY,GAAGT,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAMU,UAAU,GAAGV,OAAO,CAAC,eAAD,CAA1B;;AAEA,MAAMW,UAAU,GAAG,CAAC,cAAD,EAAiB,cAAjB,CAAnB;AACA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,OAAO,GAAG,SAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,MAAIA,MAAM,CAAC,CAAD,CAAN,CAAUC,WAAV,OAA4BJ,IAAhC,EAAsC;AACpC,WAAOG,MAAM,CAAC,CAAD,CAAb;AACD;;AAED,MAAIA,MAAM,CAAC,CAAD,CAAN,CAAUC,WAAV,OAA4BJ,IAAhC,EAAsC;AACpC,WAAOG,MAAM,CAAC,CAAD,CAAb;AACD;;AAED,MACEA,MAAM,CAAC,CAAD,CAAN,CAAUC,WAAV,OAA4BH,OAA5B,IACAE,MAAM,CAAC,CAAD,CAAN,CAAUC,WAAV,OAA4BH,OAF9B,EAGE;AACA,WAAOA,OAAP;AACD;;AAED,SAAOE,MAAM,CAACE,IAAP,CAAY,GAAZ,CAAP;AACD;;AAED,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACrBA,EAAAA,IAAI,CAACC,SAAL,CAAe,YAAf,EAA8BC,IAAD,IAAU;AACrC,QAAI,CAACX,UAAU,CAACW,IAAD,CAAf,EAAuB;AACrB;AACD;;AAED,QAAInB,UAAU,CAACoB,MAAX,CAAkBD,IAAlB,CAAJ,EAA6B;AAC3B;AACD;;AAED,QAAIN,MAAM,GAAGhB,IAAI,CAACwB,KAAL,CAAWF,IAAI,CAACG,KAAhB,CAAb;;AAEA,QAAIT,MAAM,CAACU,MAAP,KAAkB,CAAtB,EAAyB;AACvBV,MAAAA,MAAM,CAACW,IAAP,CAAYd,IAAZ;AACD;;AAEDG,IAAAA,MAAM,CAACY,OAAP,CAAe,CAACH,KAAD,EAAQI,CAAR,KAAc;AAC3B,UAAIC,IAAI,GAAGlB,UAAU,CAAC,CAAD,CAArB;AACA,YAAMmB,SAAS,GAAG7B,IAAI,CAACuB,KAAD,CAAtB;;AACA,UAAIA,KAAK,CAACR,WAAN,OAAwBJ,IAA5B,EAAkC;AAChCiB,QAAAA,IAAI,GAAGlB,UAAU,CAACiB,CAAD,CAAjB;AACD,OAFD,MAEO,IAAIE,SAAS,IAAIA,SAAS,CAAC7B,IAAV,KAAmB,EAApC,EAAwC;AAC7C4B,QAAAA,IAAI,GAAGlB,UAAU,CAAC,CAAD,CAAjB;AACD;;AAEDJ,MAAAA,YAAY,CAACc,IAAI,CAACU,MAAN,EAAcV,IAAd,EAAoB;AAC9BQ,QAAAA,IAD8B;AAE9BL,QAAAA;AAF8B,OAApB,CAAZ;AAID,KAbD;AAeAH,IAAAA,IAAI,CAACb,MAAL;AACD,GA/BD;AAgCD;;AAED,SAASwB,OAAT,CAAiBb,IAAjB,EAAuB;AACrB,MAAIc,KAAK,GAAG7B,QAAQ,CAACe,IAAD,EAAO,CAAC,SAAD,EAAYe,MAAZ,CAAmBvB,UAAnB,CAAP,CAApB;;AAEA,SAAOsB,KAAK,CAACR,MAAb,EAAqB;AACnB,UAAMU,QAAQ,GAAGF,KAAK,CAACA,KAAK,CAACR,MAAN,GAAe,CAAhB,CAAtB,CADmB,CAGnB;;AACA,UAAMW,MAAM,GAAGH,KAAK,CAACI,MAAN,CACZC,IAAD,IACE,CAACpC,UAAU,CAACoB,MAAX,CAAkBa,QAAlB,CAAD,IACA,CAACjC,UAAU,CAACoB,MAAX,CAAkBgB,IAAlB,CADD,IAEAA,IAAI,KAAKH,QAFT,IAGAG,IAAI,CAACC,SAAL,KAAmBJ,QAAQ,CAACI,SAH5B,IAIAJ,QAAQ,CAACN,IAAT,KAAkB,SAJlB,IAKAS,IAAI,CAACT,IAAL,KAAcM,QAAQ,CAACN,IAPZ,CAAf;AAUAO,IAAAA,MAAM,CAACT,OAAP,CAAenB,MAAf;AACAyB,IAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAcC,IAAD,IAAU,CAACF,MAAM,CAACI,QAAP,CAAgBF,IAAhB,CAAxB,CAAR,CAfmB,CAiBnB;;AACA,QAAIG,UAAU,GAAGR,KAAK,CAACI,MAAN,CACdC,IAAD,IACE,CAACpC,UAAU,CAACoB,MAAX,CAAkBa,QAAlB,CAAD,IACA,CAACjC,UAAU,CAACoB,MAAX,CAAkBgB,IAAlB,CADD,IAEAA,IAAI,KAAKH,QAFT,IAGAG,IAAI,CAACC,SAAL,KAAmBJ,QAAQ,CAACI,SAH5B,IAIAD,IAAI,CAACT,IAAL,KAAcM,QAAQ,CAACN,IAJvB,IAKA,EAAE,CAACpB,YAAY,CAAC6B,IAAD,CAAb,IAAuB7B,YAAY,CAAC0B,QAAD,CAArC,CAPa,CAAjB;AAUAM,IAAAA,UAAU,CAACd,OAAX,CAAmBnB,MAAnB;AACAyB,IAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CACLC,IAAD,IAAUA,IAAI,KAAKH,QAAT,IAAqB,CAACM,UAAU,CAACD,QAAX,CAAoBF,IAApB,CAD1B,CAAR;AAGD;AACF;;AAED,SAASI,KAAT,CAAevB,IAAf,EAAqB;AACnBb,EAAAA,UAAU,CAACa,IAAD,EAAOR,UAAP,EAAmB,CAACgC,KAAD,EAAQR,QAAR,KAAqB;AAChD,QAAIhC,QAAQ,CAACwC,KAAD,CAAR,IAAmB,CAACA,KAAK,CAACC,IAAN,CAAW1C,UAAU,CAACoB,MAAtB,CAAxB,EAAuD;AACrDf,MAAAA,YAAY,CAAC4B,QAAQ,CAACJ,MAAV,EAAkBI,QAAlB,EAA4B;AACtCN,QAAAA,IAAI,EAAE,SADgC;AAEtCL,QAAAA,KAAK,EAAEV,SAAS,CAAC6B,KAAK,CAACE,GAAN,CAAUxC,QAAV,CAAD;AAFsB,OAA5B,CAAZ;AAKAsC,MAAAA,KAAK,CAAChB,OAAN,CAAcnB,MAAd;AAEA,aAAO,IAAP;AACD;AACF,GAXS,CAAV;AAaAwB,EAAAA,OAAO,CAACb,IAAD,CAAP;AACD;;AAED2B,MAAM,CAACC,OAAP,GAAiB;AACf7B,EAAAA,OADe;AAEfwB,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict';\nconst { list } = require('postcss');\nconst { unit } = require('postcss-value-parser');\nconst stylehacks = require('stylehacks');\nconst canMerge = require('../canMerge');\nconst getDecls = require('../getDecls');\nconst getValue = require('../getValue');\nconst mergeRules = require('../mergeRules');\nconst insertCloned = require('../insertCloned');\nconst remove = require('../remove');\nconst isCustomProp = require('../isCustomProp');\nconst canExplode = require('../canExplode');\n\nconst properties = ['column-width', 'column-count'];\nconst auto = 'auto';\nconst inherit = 'inherit';\n\n/**\n * Normalize a columns shorthand definition. Both of the longhand\n * properties' initial values are 'auto', and as per the spec,\n * omitted values are set to their initial values. Thus, we can\n * remove any 'auto' definition when there are two values.\n *\n * Specification link: https://www.w3.org/TR/css3-multicol/\n */\n\nfunction normalize(values) {\n  if (values[0].toLowerCase() === auto) {\n    return values[1];\n  }\n\n  if (values[1].toLowerCase() === auto) {\n    return values[0];\n  }\n\n  if (\n    values[0].toLowerCase() === inherit &&\n    values[1].toLowerCase() === inherit\n  ) {\n    return inherit;\n  }\n\n  return values.join(' ');\n}\n\nfunction explode(rule) {\n  rule.walkDecls(/^columns$/i, (decl) => {\n    if (!canExplode(decl)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    let values = list.space(decl.value);\n\n    if (values.length === 1) {\n      values.push(auto);\n    }\n\n    values.forEach((value, i) => {\n      let prop = properties[1];\n      const dimension = unit(value);\n      if (value.toLowerCase() === auto) {\n        prop = properties[i];\n      } else if (dimension && dimension.unit !== '') {\n        prop = properties[0];\n      }\n\n      insertCloned(decl.parent, decl, {\n        prop,\n        value,\n      });\n    });\n\n    decl.remove();\n  });\n}\n\nfunction cleanup(rule) {\n  let decls = getDecls(rule, ['columns'].concat(properties));\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n\n    // remove properties of lower precedence\n    const lesser = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        lastNode.prop === 'columns' &&\n        node.prop !== lastNode.prop\n    );\n\n    lesser.forEach(remove);\n    decls = decls.filter((node) => !lesser.includes(node));\n\n    // get duplicate properties\n    let duplicates = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        node.prop === lastNode.prop &&\n        !(!isCustomProp(node) && isCustomProp(lastNode))\n    );\n\n    duplicates.forEach(remove);\n    decls = decls.filter(\n      (node) => node !== lastNode && !duplicates.includes(node)\n    );\n  }\n}\n\nfunction merge(rule) {\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n      insertCloned(lastNode.parent, lastNode, {\n        prop: 'columns',\n        value: normalize(rules.map(getValue)),\n      });\n\n      rules.forEach(remove);\n\n      return true;\n    }\n  });\n\n  cleanup(rule);\n}\n\nmodule.exports = {\n  explode,\n  merge,\n};\n"]},"metadata":{},"sourceType":"script"}