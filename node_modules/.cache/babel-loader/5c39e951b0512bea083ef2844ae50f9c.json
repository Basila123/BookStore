{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst transform = {\n  trimStart: s => s.trimStart(),\n  trimEnd: s => s.trimEnd(),\n  trimLeft: s => s.trimStart(),\n  trimRight: s => s.trimEnd(),\n  trim: s => s.trim(),\n  toLowerCase: s => s.toLowerCase(),\n  toUpperCase: s => s.toUpperCase(),\n  toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s\n};\nconst getDef = Object.assign(_getDef, {\n  transform\n});\n\nfunction _getDef() {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n\n    code(cxt) {\n      const {\n        gen,\n        data,\n        schema,\n        parentSchema,\n        it\n      } = cxt;\n      const {\n        parentData,\n        parentDataProperty\n      } = it;\n      const tNames = schema;\n      if (!tNames.length) return;\n      let cfg;\n\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema);\n        cfg = gen.scopeValue(\"obj\", {\n          ref: config,\n          code: (0, codegen_1.stringify)(config)\n        });\n      }\n\n      gen.if((0, codegen_1._)`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()));\n        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, data);\n      });\n\n      function transformExpr(ts) {\n        if (!ts.length) return data;\n        const t = ts.pop();\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`);\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t],\n          code: (0, codegen_1._)`require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`\n        });\n        const arg = transformExpr(ts);\n        return cfg && t === \"toEnumCase\" ? (0, codegen_1._)`${func}(${arg}, ${cfg})` : (0, codegen_1._)`${func}(${arg})`;\n      }\n    },\n\n    metaSchema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        enum: Object.keys(transform)\n      }\n    }\n  };\n}\n\nfunction getEnumCaseCfg(parentSchema) {\n  // build hash table to enum values\n  const cfg = {\n    hash: {}\n  }; // requires `enum` in the same schema as transform\n\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue;\n    const k = configKey(v); // requires all `enum` values have unique keys\n\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n    }\n\n    cfg.hash[k] = v;\n  }\n\n  return cfg;\n}\n\nfunction configKey(s) {\n  return s.toLowerCase();\n}\n\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"mappings":"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","names":["transform","trimStart","s","trimEnd","trimLeft","trimRight","trim","toLowerCase","toUpperCase","toEnumCase","cfg","hash","configKey","getDef","Object","assign","_getDef","keyword","schemaType","before","code","cxt","gen","data","schema","parentSchema","it","parentData","parentDataProperty","tNames","length","includes","config","getEnumCaseCfg","scopeValue","ref","if","transformExpr","slice","ts","t","pop","Error","func","arg","metaSchema","type","items","enum","keys","v","k","exports","module"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv-keywords/src/definitions/transform.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordCxt, Code, Name} from \"ajv\"\nimport {_, stringify, getProperty} from \"ajv/dist/compile/codegen\"\n\ntype TransformName =\n  | \"trimStart\"\n  | \"trimEnd\"\n  | \"trimLeft\"\n  | \"trimRight\"\n  | \"trim\"\n  | \"toLowerCase\"\n  | \"toUpperCase\"\n  | \"toEnumCase\"\n\ninterface TransformConfig {\n  hash: Record<string, string | undefined>\n}\n\ntype Transform = (s: string, cfg?: TransformConfig) => string\n\nconst transform: {[key in TransformName]: Transform} = {\n  trimStart: (s) => s.trimStart(),\n  trimEnd: (s) => s.trimEnd(),\n  trimLeft: (s) => s.trimStart(),\n  trimRight: (s) => s.trimEnd(),\n  trim: (s) => s.trim(),\n  toLowerCase: (s) => s.toLowerCase(),\n  toUpperCase: (s) => s.toUpperCase(),\n  toEnumCase: (s, cfg) => cfg?.hash[configKey(s)] || s,\n}\n\nconst getDef: (() => CodeKeywordDefinition) & {\n  transform: typeof transform\n} = Object.assign(_getDef, {transform})\n\nfunction _getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt: KeywordCxt) {\n      const {gen, data, schema, parentSchema, it} = cxt\n      const {parentData, parentDataProperty} = it\n      const tNames: string[] = schema\n      if (!tNames.length) return\n      let cfg: Name | undefined\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema)\n        cfg = gen.scopeValue(\"obj\", {ref: config, code: stringify(config)})\n      }\n      gen.if(_`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()))\n        gen.assign(_`${parentData}[${parentDataProperty}]`, data)\n      })\n\n      function transformExpr(ts: string[]): Code {\n        if (!ts.length) return data\n        const t = ts.pop() as string\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`)\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t as TransformName],\n          code: _`require(\"ajv-keywords/dist/definitions/transform\").transform${getProperty(t)}`,\n        })\n        const arg = transformExpr(ts)\n        return cfg && t === \"toEnumCase\" ? _`${func}(${arg}, ${cfg})` : _`${func}(${arg})`\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", enum: Object.keys(transform)},\n    },\n  }\n}\n\nfunction getEnumCaseCfg(parentSchema: AnySchemaObject): TransformConfig {\n  // build hash table to enum values\n  const cfg: TransformConfig = {hash: {}}\n\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"')\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue\n    const k = configKey(v)\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique')\n    }\n    cfg.hash[k] = v\n  }\n\n  return cfg\n}\n\nfunction configKey(s: string): string {\n  return s.toLowerCase()\n}\n\nexport default getDef\nmodule.exports = getDef\n"]},"metadata":{},"sourceType":"script"}