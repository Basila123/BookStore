{"ast":null,"code":"'use strict';\n\nconst convertUnit = require('./convertUnit.js');\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\n\n\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n\n  return false;\n}\n/** @param {'-'|'+'} operator */\n\n\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\n\n\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\n\n\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex(x => x.node.type === node.type);\n\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      } // can cast because of the criterion used to find itemIndex\n\n\n      const otherValueNode =\n      /** @type import('../parser').ValueExpression*/\n      collected[itemIndex].node;\n      const {\n        left: reducedNode,\n        right: current\n      } = convertNodesUnits(otherValueNode, node, precision);\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      } // make sure reducedNode.value >= 0\n\n\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '+'\n        };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '-'\n        };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({\n          node,\n          preOperator\n        });\n      } else {\n        node.value *= -1;\n        collected.push({\n          node,\n          preOperator: flip(preOperator)\n        });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(collectRightOperator, node.right, collected, precision);\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision); // prevent infinite recursive call\n\n      if (reducedNode.type !== 'MathExpression' || isAddSubOperator(reducedNode.operator)) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({\n          node: reducedNode,\n          preOperator\n        });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({\n      node,\n      preOperator\n    });\n  }\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\n\n\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n  const withoutZeroItem = collected.filter(item => !(isValueType(item.node) && item.node.value === 0));\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n\n  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node)) {\n    const firstZeroItem = collected.find(item => isValueType(item.node) && item.node.value === 0);\n\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  } // make sure the preOperator of the first item is +\n\n\n  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node)) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  let root = withoutZeroItem[0].node;\n\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node\n    };\n  }\n\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\n\n\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n}\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor\n    }\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\n\n\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  } // number * (expr)\n\n\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n\n  return node;\n}\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier\n    }\n  };\n}\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\n\n\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(right.value, right.unit, left.unit, precision);\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit\n        };\n      }\n\n      return {\n        left,\n        right\n      };\n\n    default:\n      return {\n        left,\n        right\n      };\n  }\n}\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\n\n\nfunction includesNoCssProperties(node) {\n  return node.content.type !== 'Function' && (node.content.type !== 'MathExpression' || node.content.right.type !== 'Function' && node.content.left.type !== 'Function');\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\n\n\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n\n    return node;\n  }\n\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n\n  return node;\n}\n\nmodule.exports = reduce;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-calc/src/lib/reducer.js"],"names":["convertUnit","require","isValueType","node","type","flip","operator","isAddSubOperator","collectAddSubItems","preOperator","collected","precision","Error","itemIndex","findIndex","x","value","otherValueNode","left","reducedNode","right","current","convertNodesUnits","push","collectRightOperator","reduce","content","reduceAddSubExpression","withoutZeroItem","filter","item","firstNonZeroItem","firstZeroItem","find","unshift","root","i","length","reduceDivisionExpression","unit","applyNumberDivision","divisor","reduceMultiplicationExpression","applyNumberMultiplication","multiplier","converted","includesNoCssProperties","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst convertUnit = require('./convertUnit.js');\n\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n  return false;\n}\n\n/** @param {'-'|'+'} operator */\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex((x) => x.node.type === node.type);\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n      // can cast because of the criterion used to find itemIndex\n      const otherValueNode = /** @type import('../parser').ValueExpression*/ (\n        collected[itemIndex].node\n      );\n      const { left: reducedNode, right: current } = convertNodesUnits(\n        otherValueNode,\n        node,\n        precision\n      );\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      }\n      // make sure reducedNode.value >= 0\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = { node: reducedNode, preOperator: '+' };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = { node: reducedNode, preOperator: '-' };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({ node, preOperator });\n      } else {\n        node.value *= -1;\n        collected.push({ node, preOperator: flip(preOperator) });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator =\n        preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(\n        collectRightOperator,\n        node.right,\n        collected,\n        precision\n      );\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision);\n      // prevent infinite recursive call\n      if (\n        reducedNode.type !== 'MathExpression' ||\n        isAddSubOperator(reducedNode.operator)\n      ) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({ node: reducedNode, preOperator });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({ node, preOperator });\n  }\n}\n\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n\n  const withoutZeroItem = collected.filter(\n    (item) => !(isValueType(item.node) && item.node.value === 0)\n  );\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n  if (\n    !firstNonZeroItem ||\n    (firstNonZeroItem.preOperator === '-' &&\n      !isValueType(firstNonZeroItem.node))\n  ) {\n    const firstZeroItem = collected.find(\n      (item) => isValueType(item.node) && item.node.value === 0\n    );\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  }\n\n  // make sure the preOperator of the first item is +\n  if (\n    withoutZeroItem[0].preOperator === '-' &&\n    isValueType(withoutZeroItem[0].node)\n  ) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  let root = withoutZeroItem[0].node;\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node,\n    };\n  }\n\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n}\n\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor,\n    },\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  }\n  // number * (expr)\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n  return node;\n}\n\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier,\n    },\n  };\n}\n\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(\n          right.value,\n          right.unit,\n          left.unit,\n          precision\n        );\n\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit,\n        };\n      }\n\n      return { left, right };\n    default:\n      return { left, right };\n  }\n}\n\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\nfunction includesNoCssProperties(node) {\n  return (\n    node.content.type !== 'Function' &&\n    (node.content.type !== 'MathExpression' ||\n      (node.content.right.type !== 'Function' &&\n        node.content.left.type !== 'Function'))\n  );\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n\n    return node;\n  }\n\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n\n  return node;\n}\n\nmodule.exports = reduce;\n"]},"metadata":{},"sourceType":"script"}