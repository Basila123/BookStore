{"ast":null,"code":"'use strict';\n\nconst isTag = node => {\n  return node.type === 'element';\n};\n\nconst existsOne = (test, elems) => {\n  return elems.some(elem => {\n    if (isTag(elem)) {\n      return test(elem) || existsOne(test, getChildren(elem));\n    } else {\n      return false;\n    }\n  });\n};\n\nconst getAttributeValue = (elem, name) => {\n  return elem.attributes[name];\n};\n\nconst getChildren = node => {\n  return node.children || [];\n};\n\nconst getName = elemAst => {\n  return elemAst.name;\n};\n\nconst getParent = node => {\n  return node.parentNode || null;\n};\n\nconst getSiblings = elem => {\n  var parent = getParent(elem);\n  return parent ? getChildren(parent) : [];\n};\n\nconst getText = node => {\n  if (node.children[0].type === 'text' && node.children[0].type === 'cdata') {\n    return node.children[0].value;\n  }\n\n  return '';\n};\n\nconst hasAttrib = (elem, name) => {\n  return elem.attributes[name] !== undefined;\n};\n\nconst removeSubsets = nodes => {\n  let idx = nodes.length;\n  let node;\n  let ancestor;\n  let replace; // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n\n  while (--idx > -1) {\n    node = ancestor = nodes[idx]; // Temporarily remove the node under consideration\n\n    nodes[idx] = null;\n    replace = true;\n\n    while (ancestor) {\n      if (nodes.includes(ancestor)) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n\n      ancestor = getParent(ancestor);\n    } // If the node has been found to be unique, re-insert it.\n\n\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n\n  return nodes;\n};\n\nconst findAll = (test, elems) => {\n  const result = [];\n\n  for (const elem of elems) {\n    if (isTag(elem)) {\n      if (test(elem)) {\n        result.push(elem);\n      }\n\n      result.push(...findAll(test, getChildren(elem)));\n    }\n  }\n\n  return result;\n};\n\nconst findOne = (test, elems) => {\n  for (const elem of elems) {\n    if (isTag(elem)) {\n      if (test(elem)) {\n        return elem;\n      }\n\n      const result = findOne(test, getChildren(elem));\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n\n  return null;\n};\n\nconst svgoCssSelectAdapter = {\n  isTag,\n  existsOne,\n  getAttributeValue,\n  getChildren,\n  getName,\n  getParent,\n  getSiblings,\n  getText,\n  hasAttrib,\n  removeSubsets,\n  findAll,\n  findOne\n};\nmodule.exports = svgoCssSelectAdapter;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/lib/svgo/css-select-adapter.js"],"names":["isTag","node","type","existsOne","test","elems","some","elem","getChildren","getAttributeValue","name","attributes","children","getName","elemAst","getParent","parentNode","getSiblings","parent","getText","value","hasAttrib","undefined","removeSubsets","nodes","idx","length","ancestor","replace","includes","splice","findAll","result","push","findOne","svgoCssSelectAdapter","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst isTag = (node) => {\n  return node.type === 'element';\n};\n\nconst existsOne = (test, elems) => {\n  return elems.some((elem) => {\n    if (isTag(elem)) {\n      return test(elem) || existsOne(test, getChildren(elem));\n    } else {\n      return false;\n    }\n  });\n};\n\nconst getAttributeValue = (elem, name) => {\n  return elem.attributes[name];\n};\n\nconst getChildren = (node) => {\n  return node.children || [];\n};\n\nconst getName = (elemAst) => {\n  return elemAst.name;\n};\n\nconst getParent = (node) => {\n  return node.parentNode || null;\n};\n\nconst getSiblings = (elem) => {\n  var parent = getParent(elem);\n  return parent ? getChildren(parent) : [];\n};\n\nconst getText = (node) => {\n  if (node.children[0].type === 'text' && node.children[0].type === 'cdata') {\n    return node.children[0].value;\n  }\n  return '';\n};\n\nconst hasAttrib = (elem, name) => {\n  return elem.attributes[name] !== undefined;\n};\n\nconst removeSubsets = (nodes) => {\n  let idx = nodes.length;\n  let node;\n  let ancestor;\n  let replace;\n  // Check if each node (or one of its ancestors) is already contained in the\n  // array.\n  while (--idx > -1) {\n    node = ancestor = nodes[idx];\n    // Temporarily remove the node under consideration\n    nodes[idx] = null;\n    replace = true;\n    while (ancestor) {\n      if (nodes.includes(ancestor)) {\n        replace = false;\n        nodes.splice(idx, 1);\n        break;\n      }\n      ancestor = getParent(ancestor);\n    }\n    // If the node has been found to be unique, re-insert it.\n    if (replace) {\n      nodes[idx] = node;\n    }\n  }\n  return nodes;\n};\n\nconst findAll = (test, elems) => {\n  const result = [];\n  for (const elem of elems) {\n    if (isTag(elem)) {\n      if (test(elem)) {\n        result.push(elem);\n      }\n      result.push(...findAll(test, getChildren(elem)));\n    }\n  }\n  return result;\n};\n\nconst findOne = (test, elems) => {\n  for (const elem of elems) {\n    if (isTag(elem)) {\n      if (test(elem)) {\n        return elem;\n      }\n      const result = findOne(test, getChildren(elem));\n      if (result) {\n        return result;\n      }\n    }\n  }\n  return null;\n};\n\nconst svgoCssSelectAdapter = {\n  isTag,\n  existsOne,\n  getAttributeValue,\n  getChildren,\n  getName,\n  getParent,\n  getSiblings,\n  getText,\n  hasAttrib,\n  removeSubsets,\n  findAll,\n  findOne,\n};\n\nmodule.exports = svgoCssSelectAdapter;\n"]},"metadata":{},"sourceType":"script"}