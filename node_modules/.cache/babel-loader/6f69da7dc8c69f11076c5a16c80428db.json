{"ast":null,"code":"'use strict';\n\nconst {\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\n\nconst {\n  path2js,\n  js2path,\n  intersects\n} = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'mergePaths';\nexports.active = true;\nexports.description = 'merges multiple paths in one if possible';\n/**\n * Merge multiple Paths into one.\n *\n * @author Kir Belevich, Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   force?: boolean,\n *   floatPrecision?: number,\n *   noSpaceAfterFlags?: boolean\n * }>}\n */\n\nexports.fn = (root, params) => {\n  const {\n    force = false,\n    floatPrecision,\n    noSpaceAfterFlags = false // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n\n  } = params;\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        let prevChild = null;\n\n        for (const child of node.children) {\n          // skip if previous element is not path or contains animation elements\n          if (prevChild == null || prevChild.type !== 'element' || prevChild.name !== 'path' || prevChild.children.length !== 0 || prevChild.attributes.d == null) {\n            prevChild = child;\n            continue;\n          } // skip if element is not path or contains animation elements\n\n\n          if (child.type !== 'element' || child.name !== 'path' || child.children.length !== 0 || child.attributes.d == null) {\n            prevChild = child;\n            continue;\n          } // preserve paths with markers\n\n\n          const computedStyle = computeStyle(stylesheet, child);\n\n          if (computedStyle['marker-start'] || computedStyle['marker-mid'] || computedStyle['marker-end']) {\n            prevChild = child;\n            continue;\n          }\n\n          const prevChildAttrs = Object.keys(prevChild.attributes);\n          const childAttrs = Object.keys(child.attributes);\n          let attributesAreEqual = prevChildAttrs.length === childAttrs.length;\n\n          for (const name of childAttrs) {\n            if (name !== 'd') {\n              if (prevChild.attributes[name] == null || prevChild.attributes[name] !== child.attributes[name]) {\n                attributesAreEqual = false;\n              }\n            }\n          }\n\n          const prevPathJS = path2js(prevChild);\n          const curPathJS = path2js(child);\n\n          if (attributesAreEqual && (force || !intersects(prevPathJS, curPathJS))) {\n            js2path(prevChild, prevPathJS.concat(curPathJS), {\n              floatPrecision,\n              noSpaceAfterFlags\n            });\n            detachNodeFromParent(child, node);\n            continue;\n          }\n\n          prevChild = child;\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/mergePaths.js"],"names":["detachNodeFromParent","require","collectStylesheet","computeStyle","path2js","js2path","intersects","exports","type","name","active","description","fn","root","params","force","floatPrecision","noSpaceAfterFlags","stylesheet","element","enter","node","prevChild","child","children","length","attributes","d","computedStyle","prevChildAttrs","Object","keys","childAttrs","attributesAreEqual","prevPathJS","curPathJS","concat"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { detachNodeFromParent } = require('../lib/xast.js');\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { path2js, js2path, intersects } = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'mergePaths';\nexports.active = true;\nexports.description = 'merges multiple paths in one if possible';\n\n/**\n * Merge multiple Paths into one.\n *\n * @author Kir Belevich, Lev Solntsev\n *\n * @type {import('../lib/types').Plugin<{\n *   force?: boolean,\n *   floatPrecision?: number,\n *   noSpaceAfterFlags?: boolean\n * }>}\n */\nexports.fn = (root, params) => {\n  const {\n    force = false,\n    floatPrecision,\n    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n  } = params;\n  const stylesheet = collectStylesheet(root);\n\n  return {\n    element: {\n      enter: (node) => {\n        let prevChild = null;\n\n        for (const child of node.children) {\n          // skip if previous element is not path or contains animation elements\n          if (\n            prevChild == null ||\n            prevChild.type !== 'element' ||\n            prevChild.name !== 'path' ||\n            prevChild.children.length !== 0 ||\n            prevChild.attributes.d == null\n          ) {\n            prevChild = child;\n            continue;\n          }\n\n          // skip if element is not path or contains animation elements\n          if (\n            child.type !== 'element' ||\n            child.name !== 'path' ||\n            child.children.length !== 0 ||\n            child.attributes.d == null\n          ) {\n            prevChild = child;\n            continue;\n          }\n\n          // preserve paths with markers\n          const computedStyle = computeStyle(stylesheet, child);\n          if (\n            computedStyle['marker-start'] ||\n            computedStyle['marker-mid'] ||\n            computedStyle['marker-end']\n          ) {\n            prevChild = child;\n            continue;\n          }\n\n          const prevChildAttrs = Object.keys(prevChild.attributes);\n          const childAttrs = Object.keys(child.attributes);\n          let attributesAreEqual = prevChildAttrs.length === childAttrs.length;\n          for (const name of childAttrs) {\n            if (name !== 'd') {\n              if (\n                prevChild.attributes[name] == null ||\n                prevChild.attributes[name] !== child.attributes[name]\n              ) {\n                attributesAreEqual = false;\n              }\n            }\n          }\n          const prevPathJS = path2js(prevChild);\n          const curPathJS = path2js(child);\n\n          if (\n            attributesAreEqual &&\n            (force || !intersects(prevPathJS, curPathJS))\n          ) {\n            js2path(prevChild, prevPathJS.concat(curPathJS), {\n              floatPrecision,\n              noSpaceAfterFlags,\n            });\n            detachNodeFromParent(child, node);\n            continue;\n          }\n\n          prevChild = child;\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}