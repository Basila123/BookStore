{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst util_1 = require(\"./util\");\n\nconst names_1 = require(\"./names\");\n\nexports.keywordError = {\n  message: _ref => {\n    let {\n      keyword\n    } = _ref;\n    return (0, codegen_1.str)`must pass \"${keyword}\" keyword validation`;\n  }\n};\nexports.keyword$DataError = {\n  message: _ref2 => {\n    let {\n      keyword,\n      schemaType\n    } = _ref2;\n    return schemaType ? (0, codegen_1.str)`\"${keyword}\" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`\"${keyword}\" keyword is invalid ($data)`;\n  }\n};\n\nfunction reportError(cxt) {\n  let error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.keywordError;\n  let errorPaths = arguments.length > 2 ? arguments[2] : undefined;\n  let overrideAllErrors = arguments.length > 3 ? arguments[3] : undefined;\n  const {\n    it\n  } = cxt;\n  const {\n    gen,\n    compositeRule,\n    allErrors\n  } = it;\n  const errObj = errorObjectCode(cxt, error, errorPaths);\n\n  if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {\n    addError(gen, errObj);\n  } else {\n    returnErrors(it, (0, codegen_1._)`[${errObj}]`);\n  }\n}\n\nexports.reportError = reportError;\n\nfunction reportExtraError(cxt) {\n  let error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.keywordError;\n  let errorPaths = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    it\n  } = cxt;\n  const {\n    gen,\n    compositeRule,\n    allErrors\n  } = it;\n  const errObj = errorObjectCode(cxt, error, errorPaths);\n  addError(gen, errObj);\n\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, names_1.default.vErrors);\n  }\n}\n\nexports.reportExtraError = reportExtraError;\n\nfunction resetErrorsCount(gen, errsCount) {\n  gen.assign(names_1.default.errors, errsCount);\n  gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\n\nexports.resetErrorsCount = resetErrorsCount;\n\nfunction extendErrors(_ref3) {\n  let {\n    gen,\n    keyword,\n    schemaValue,\n    data,\n    errsCount,\n    it\n  } = _ref3;\n\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\");\n  const err = gen.name(\"err\");\n  gen.forRange(\"i\", errsCount, names_1.default.errors, i => {\n    gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);\n    gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n    gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);\n\n    if (it.opts.verbose) {\n      gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);\n      gen.assign((0, codegen_1._)`${err}.data`, data);\n    }\n  });\n}\n\nexports.extendErrors = extendErrors;\n\nfunction addError(gen, errObj) {\n  const err = gen.const(\"err\", errObj);\n  gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);\n  gen.code((0, codegen_1._)`${names_1.default.errors}++`);\n}\n\nfunction returnErrors(it, errs) {\n  const {\n    gen,\n    validateName,\n    schemaEnv\n  } = it;\n\n  if (schemaEnv.$async) {\n    gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, errs);\n    gen.return(false);\n  }\n}\n\nconst E = {\n  keyword: new codegen_1.Name(\"keyword\"),\n  schemaPath: new codegen_1.Name(\"schemaPath\"),\n  params: new codegen_1.Name(\"params\"),\n  propertyName: new codegen_1.Name(\"propertyName\"),\n  message: new codegen_1.Name(\"message\"),\n  schema: new codegen_1.Name(\"schema\"),\n  parentSchema: new codegen_1.Name(\"parentSchema\")\n};\n\nfunction errorObjectCode(cxt, error, errorPaths) {\n  const {\n    createErrors\n  } = cxt.it;\n  if (createErrors === false) return (0, codegen_1._)`{}`;\n  return errorObject(cxt, error, errorPaths);\n}\n\nfunction errorObject(cxt, error) {\n  let errorPaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    gen,\n    it\n  } = cxt;\n  const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];\n  extraErrorProps(cxt, error, keyValues);\n  return gen.object(...keyValues);\n}\n\nfunction errorInstancePath(_ref4, _ref5) {\n  let {\n    errorPath\n  } = _ref4;\n  let {\n    instancePath\n  } = _ref5;\n  const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;\n  return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\n\nfunction errorSchemaPath(_ref6, _ref7) {\n  let {\n    keyword,\n    it: {\n      errSchemaPath\n    }\n  } = _ref6;\n  let {\n    schemaPath,\n    parentSchema\n  } = _ref7;\n  let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;\n\n  if (schemaPath) {\n    schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n  }\n\n  return [E.schemaPath, schPath];\n}\n\nfunction extraErrorProps(cxt, _ref8, keyValues) {\n  let {\n    params,\n    message\n  } = _ref8;\n  const {\n    keyword,\n    data,\n    schemaValue,\n    it\n  } = cxt;\n  const {\n    opts,\n    propertyName,\n    topSchemaRef,\n    schemaPath\n  } = it;\n  keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._)`{}`]);\n\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n  }\n\n  if (opts.verbose) {\n    keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n  }\n\n  if (propertyName) keyValues.push([E.propertyName, propertyName]);\n}","map":{"version":3,"mappings":"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","names":["exports","message","keyword","schemaType","reportError","cxt","error","errorPaths","overrideAllErrors","it","gen","compositeRule","allErrors","errObj","errorObjectCode","addError","returnErrors","reportExtraError","names_1","vErrors","resetErrorsCount","errsCount","assign","errors","if","extendErrors","schemaValue","data","undefined","Error","err","name","forRange","i","const","instancePath","errorPath","errSchemaPath","opts","verbose","code","errs","validateName","schemaEnv","$async","throw","ValidationError","return","E","codegen_1","schemaPath","params","propertyName","schema","parentSchema","createErrors","errorObject","keyValues","errorInstancePath","errorSchemaPath","extraErrorProps","object","instPath","util_1","Str","schPath","topSchemaRef","push","messages"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/compile/errors.ts"],"sourcesContent":["import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n"]},"metadata":{},"sourceType":"script"}