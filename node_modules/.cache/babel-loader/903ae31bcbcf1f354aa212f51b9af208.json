{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)`must match format \"${schemaCode}\"`;\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)`{format: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", (0, codegen_1._)`${fmts}[${schemaCode}]`);\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\"); // TODO simplify\n\n      gen.if((0, codegen_1._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || \"string\"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`\"string\"`).assign(format, fDef));\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)`${schemaCode} && !${format}`;\n      }\n\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;\n        const validData = (0, codegen_1._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n        return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n      }\n    }\n\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n        }\n      }\n\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)`await ${fmtRef}(${data})`;\n        }\n\n        return typeof format == \"function\" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","schemaCode","params","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","unknownFmt","invalidFmt","strictSchema","codegen_1","callFormat","$async","validData","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","undefined","fmt","key","validate","async","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/vocabularies/format/format.ts"],"sourcesContent":["import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}