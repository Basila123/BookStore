{"ast":null,"code":"'use strict';\n\nconst csstree = require('css-tree');\n\nconst {\n  referencesProps\n} = require('./_collections.js');\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PluginInfo} PluginInfo\n */\n\n\nexports.type = 'visitor';\nexports.name = 'prefixIds';\nexports.active = false;\nexports.description = 'prefix IDs';\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\n\nconst getBasename = path => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n\n  if (matched) {\n    return matched[1];\n  }\n\n  return '';\n};\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\n\n\nconst escapeIdentifierName = str => {\n  return str.replace(/[. ]/g, '_');\n};\n/**\n * @type {(string: string) => string}\n */\n\n\nconst unquote = string => {\n  if (string.startsWith('\"') && string.endsWith('\"') || string.startsWith(\"'\") && string.endsWith(\"'\")) {\n    return string.slice(1, -1);\n  }\n\n  return string;\n};\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\n\n\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n\n  return prefix + value;\n};\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\n\n\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n\n  return null;\n};\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),\n *   delim?: string,\n *   prefixIds?: boolean,\n *   prefixClassNames?: boolean,\n * }>}\n */\n\n\nexports.fn = (_root, params, info) => {\n  const {\n    delim = '__',\n    prefixIds = true,\n    prefixClassNames = true\n  } = params;\n  return {\n    element: {\n      enter: node => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        } // prefix id/class selectors and url() references in styles\n\n\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          } // parse styles\n\n\n          let cssText = '';\n\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n\n\n          let cssAst = null;\n\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, node => {\n            // #ID, .class selectors\n            if (prefixIds && node.type === 'IdSelector' || prefixClassNames && node.type === 'ClassSelector') {\n              node.name = prefixId(prefix, node.name);\n              return;\n            } // url(...) references\n\n\n            if (node.type === 'Url' && node.value.value && node.value.value.length > 0) {\n              const prefixed = prefixReference(prefix, unquote(node.value.value));\n\n              if (prefixed != null) {\n                node.value.value = prefixed;\n              }\n            }\n          }); // update styles\n\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n\n          return;\n        } // prefix an ID attribute value\n\n\n        if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        } // prefix a class attribute value\n\n\n        if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {\n          node.attributes.class = node.attributes.class.split(/\\s+/).map(name => prefixId(prefix, name)).join(' ');\n        } // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n\n\n        for (const name of ['href', 'xlink:href']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        } // prefix an URL attribute value\n\n\n        for (const name of referencesProps) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            node.attributes[name] = node.attributes[name].replace(/url\\((.*?)\\)/gi, (match, url) => {\n              const prefixed = prefixReference(prefix, url);\n\n              if (prefixed == null) {\n                return match;\n              }\n\n              return `url(${prefixed})`;\n            });\n          }\n        } // prefix begin/end attribute value\n\n\n        for (const name of ['begin', 'end']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map(val => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/prefixIds.js"],"names":["csstree","require","referencesProps","exports","type","name","active","description","getBasename","path","matched","match","escapeIdentifierName","str","replace","unquote","string","startsWith","endsWith","slice","prefixId","prefix","value","prefixReference","fn","_root","params","info","delim","prefixIds","prefixClassNames","element","enter","node","length","children","cssText","cssAst","parse","parseValue","parseCustomProperty","walk","prefixed","generate","attributes","id","class","split","map","join","url","parts","val","postfix"],"mappings":"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","sourcesContent":["'use strict';\n\nconst csstree = require('css-tree');\nconst { referencesProps } = require('./_collections.js');\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PluginInfo} PluginInfo\n */\n\nexports.type = 'visitor';\nexports.name = 'prefixIds';\nexports.active = false;\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = (path) => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = (str) => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = (string) => {\n  if (\n    (string.startsWith('\"') && string.endsWith('\"')) ||\n    (string.startsWith(\"'\") && string.endsWith(\"'\"))\n  ) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n  return prefix + value;\n};\n\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n  return null;\n};\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),\n *   delim?: string,\n *   prefixIds?: boolean,\n *   prefixClassNames?: boolean,\n * }>}\n */\nexports.fn = (_root, params, info) => {\n  const { delim = '__', prefixIds = true, prefixClassNames = true } = params;\n\n  return {\n    element: {\n      enter: (node) => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        }\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n\n          // parse styles\n          let cssText = '';\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n          let cssAst = null;\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false,\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, (node) => {\n            // #ID, .class selectors\n            if (\n              (prefixIds && node.type === 'IdSelector') ||\n              (prefixClassNames && node.type === 'ClassSelector')\n            ) {\n              node.name = prefixId(prefix, node.name);\n              return;\n            }\n            // url(...) references\n            if (\n              node.type === 'Url' &&\n              node.value.value &&\n              node.value.value.length > 0\n            ) {\n              const prefixed = prefixReference(\n                prefix,\n                unquote(node.value.value)\n              );\n              if (prefixed != null) {\n                node.value.value = prefixed;\n              }\n            }\n          });\n\n          // update styles\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n          return;\n        }\n\n        // prefix an ID attribute value\n        if (\n          prefixIds &&\n          node.attributes.id != null &&\n          node.attributes.id.length !== 0\n        ) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (\n          prefixClassNames &&\n          node.attributes.class != null &&\n          node.attributes.class.length !== 0\n        ) {\n          node.attributes.class = node.attributes.class\n            .split(/\\s+/)\n            .map((name) => prefixId(prefix, name))\n            .join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix an URL attribute value\n        for (const name of referencesProps) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            node.attributes[name] = node.attributes[name].replace(\n              /url\\((.*?)\\)/gi,\n              (match, url) => {\n                const prefixed = prefixReference(prefix, url);\n                if (prefixed == null) {\n                  return match;\n                }\n                return `url(${prefixed})`;\n              }\n            );\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map((val) => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}