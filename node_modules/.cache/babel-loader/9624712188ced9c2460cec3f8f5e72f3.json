{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree'); // @ts-ignore not defined in @types/csso\n\n\nconst specificity = require('csso/lib/restructure/prepare/specificity');\n\nconst stable = require('stable');\n\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nexports.type = 'visitor';\nexports.name = 'inlineStyles';\nexports.active = true;\nexports.description = 'inline styles (additional options)';\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\n\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   onlyMatchedOnce?: boolean,\n *   removeMatchedSelectors?: boolean,\n *   useMqs?: Array<string>,\n *   usePseudos?: Array<string>\n * }>}\n */\n\n\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = ['']\n  } = params;\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n\n  let selectors = [];\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        } // collect only non-empty <style /> elements\n\n\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        } // values other than the empty string or text/css are not used\n\n\n        if (node.attributes.type != null && node.attributes.type !== '' && node.attributes.type !== 'text/css') {\n          return;\n        } // parse css in style element\n\n\n        let cssText = '';\n\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n\n\n        let cssAst = null;\n\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false\n          });\n        } catch {\n          return;\n        }\n\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({\n            node,\n            parentNode,\n            cssAst\n          });\n        } // collect selectors\n\n\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n\n            if (rule == null) {\n              return;\n            } // skip media queries not included into useMqs param\n\n\n            let mq = '';\n\n            if (atrule != null) {\n              mq = atrule.name;\n\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n\n\n            const pseudos = [];\n\n            if (node.type === 'Selector') {\n              node.children.each((childNode, childItem, childList) => {\n                if (childNode.type === 'PseudoClassSelector' || childNode.type === 'PseudoElementSelector') {\n                  pseudos.push({\n                    item: childItem,\n                    list: childList\n                  });\n                }\n              });\n            } // skip pseudo classes and pseudo elements not includes into usePseudos param\n\n\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(pseudos.map(pseudo => pseudo.item.data))\n            });\n\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            } // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n\n\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({\n              node,\n              item,\n              rule\n            });\n          }\n\n        });\n      }\n    },\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        } // stable sort selectors\n\n\n        const sortedSelectors = stable(selectors, (a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n\n          const matchedElements = [];\n\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          } // nothing selected\n\n\n          if (matchedElements.length === 0) {\n            continue;\n          } // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n\n\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          } // apply <style/> to matched elements\n\n\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(selectedEl.attributes.style == null ? '' : selectedEl.attributes.style, {\n              context: 'declarationList',\n              parseValue: false\n            });\n\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              }\n\n            }); // merge declarations\n\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(ruleDeclaration.property);\n                const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);\n\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {\n                  styleDeclarationList.children.replace(matchedItem, ruleDeclarationItem);\n                  styleDeclarationItems.set(ruleDeclaration.property, ruleDeclarationItem);\n                }\n              }\n\n            });\n            selectedEl.attributes.style = csstree.generate(styleDeclarationList);\n          }\n\n          if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === 'SelectorList') {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n\n          selector.matchedElements = matchedElements;\n        } // no further processing required\n\n\n        if (removeMatchedSelectors === false) {\n          return;\n        } // clean up matched class + ID attribute values\n\n\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(' '));\n            const firstSubSelector = selector.node.children.first();\n\n            if (firstSubSelector != null && firstSubSelector.type === 'ClassSelector') {\n              classList.delete(firstSubSelector.name);\n            }\n\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            } // ID\n\n\n            if (firstSubSelector != null && firstSubSelector.type === 'IdSelector') {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (node.type === 'Rule' && node.prelude.type === 'SelectorList' && node.prelude.children.isEmpty()) {\n                list.remove(item);\n              }\n            }\n          });\n\n          if (style.cssAst.children.isEmpty()) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/inlineStyles.js"],"names":["csstree","require","specificity","stable","visitSkip","querySelectorAll","detachNodeFromParent","exports","type","name","active","description","compareSpecificity","a","b","i","fn","root","params","onlyMatchedOnce","removeMatchedSelectors","useMqs","usePseudos","styles","selectors","element","enter","node","parentNode","children","length","attributes","cssText","child","value","cssAst","parse","parseValue","parseCustomProperty","push","walk","visit","item","atrule","rule","mq","prelude","generate","includes","pseudos","each","childNode","childItem","childList","list","pseudoSelectors","List","fromArray","map","pseudo","data","remove","exit","sortedSelectors","aSpecificity","bSpecificity","reverse","selector","selectorText","matchedElements","selectError","selectedEl","styleDeclarationList","style","context","styleDeclarationItems","Map","set","property","ruleDeclaration","matchedItem","get","ruleDeclarationItem","createItem","append","important","replace","classList","Set","class","split","firstSubSelector","first","delete","size","Array","from","join","id","isEmpty","firstChild"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree');\n// @ts-ignore not defined in @types/csso\nconst specificity = require('csso/lib/restructure/prepare/specificity');\nconst stable = require('stable');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent,\n} = require('../lib/xast.js');\n\nexports.type = 'visitor';\nexports.name = 'inlineStyles';\nexports.active = true;\nexports.description = 'inline styles (additional options)';\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   onlyMatchedOnce?: boolean,\n *   removeMatchedSelectors?: boolean,\n *   useMqs?: Array<string>,\n *   usePseudos?: Array<string>\n * }>}\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = [''],\n  } = params;\n\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n  let selectors = [];\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        // collect only non-empty <style /> elements\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        // values other than the empty string or text/css are not used\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n        // parse css in style element\n        let cssText = '';\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false,\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({ node, parentNode, cssAst });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n            if (rule == null) {\n              return;\n            }\n\n            // skip media queries not included into useMqs param\n            let mq = '';\n            if (atrule != null) {\n              mq = atrule.name;\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n            const pseudos = [];\n            if (node.type === 'Selector') {\n              node.children.each((childNode, childItem, childList) => {\n                if (\n                  childNode.type === 'PseudoClassSelector' ||\n                  childNode.type === 'PseudoElementSelector'\n                ) {\n                  pseudos.push({ item: childItem, list: childList });\n                }\n              });\n            }\n\n            // skip pseudo classes and pseudo elements not includes into usePseudos param\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(\n                pseudos.map((pseudo) => pseudo.item.data)\n              ),\n            });\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            }\n\n            // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({ node, item, rule });\n          },\n        });\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        // stable sort selectors\n        const sortedSelectors = stable(selectors, (a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(\n              selectedEl.attributes.style == null\n                ? ''\n                : selectedEl.attributes.style,\n              {\n                context: 'declarationList',\n                parseValue: false,\n              }\n            );\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              },\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(\n                  ruleDeclaration.property\n                );\n                const ruleDeclarationItem =\n                  styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (\n                  matchedItem.data.important !== true &&\n                  ruleDeclaration.important === true\n                ) {\n                  styleDeclarationList.children.replace(\n                    matchedItem,\n                    ruleDeclarationItem\n                  );\n                  styleDeclarationItems.set(\n                    ruleDeclaration.property,\n                    ruleDeclarationItem\n                  );\n                }\n              },\n            });\n            selectedEl.attributes.style =\n              csstree.generate(styleDeclarationList);\n          }\n\n          if (\n            removeMatchedSelectors &&\n            matchedElements.length !== 0 &&\n            selector.rule.prelude.type === 'SelectorList'\n          ) {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (removeMatchedSelectors === false) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(\n              selectedEl.attributes.class == null\n                ? null\n                : selectedEl.attributes.class.split(' ')\n            );\n            const firstSubSelector = selector.node.children.first();\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'ClassSelector'\n            ) {\n              classList.delete(firstSubSelector.name);\n            }\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'IdSelector'\n            ) {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (\n                node.type === 'Rule' &&\n                node.prelude.type === 'SelectorList' &&\n                node.prelude.children.isEmpty()\n              ) {\n                list.remove(item);\n              }\n            },\n          });\n\n          if (style.cssAst.children.isEmpty()) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}