{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\n\nconst rules_1 = require(\"../rules\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst errors_1 = require(\"../errors\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nvar DataType;\n\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n\n    if (schema.nullable === true) types.push(\"null\");\n  }\n\n  return types;\n}\n\nexports.getSchemaTypes = getSchemaTypes;\n\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\n\nexports.getJSONTypes = getJSONTypes;\n\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n\n  return checkTypes;\n}\n\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\n\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", (0, codegen_1._)`typeof ${data}`);\n  const coerced = gen.let(\"coerced\", (0, codegen_1._)`undefined`);\n\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n\n  gen.if((0, codegen_1._)`${coerced} !== undefined`);\n\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, codegen_1._)`\"\" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`\"\"`);\n        return;\n\n      case \"number\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n        return;\n\n      case \"null\":\n        gen.elseIf((0, codegen_1._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n        gen.assign(coerced, null);\n        return;\n\n      case \"array\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);\n    }\n  }\n}\n\nfunction assignParentData(_ref, expr) {\n  let {\n    gen,\n    parentData,\n    parentDataProperty\n  } = _ref;\n  // TODO use gen.property\n  gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));\n}\n\nfunction checkDataType(dataType, data, strictNums) {\n  let correct = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DataType.Correct;\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)`${data} ${EQ} null`;\n\n    case \"array\":\n      cond = (0, codegen_1._)`Array.isArray(${data})`;\n      break;\n\n    case \"object\":\n      cond = (0, codegen_1._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n      break;\n\n    case \"integer\":\n      cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);\n      break;\n\n    case \"number\":\n      cond = numCond();\n      break;\n\n    default:\n      return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;\n  }\n\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n\n  function numCond() {\n    let _cond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n\n    return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);\n  }\n}\n\nexports.checkDataType = checkDataType;\n\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n\n  let cond;\n  const types = (0, util_1.toHash)(dataTypes);\n\n  if (types.array && types.object) {\n    const notObj = (0, codegen_1._)`typeof ${data} != \"object\"`;\n    cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n\n  if (types.number) delete types.integer;\n\n  for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n\n  return cond;\n}\n\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: _ref2 => {\n    let {\n      schema\n    } = _ref2;\n    return `must be ${schema}`;\n  },\n  params: _ref3 => {\n    let {\n      schema,\n      schemaValue\n    } = _ref3;\n    return typeof schema == \"string\" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`;\n  }\n};\n\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\n\nexports.reportTypeError = reportTypeError;\n\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":{"version":3,"mappings":"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","names":["DataType","exports","getSchemaTypes","schema","types","getJSONTypes","type","hasNull","includes","nullable","Error","length","undefined","push","ts","Array","isArray","every","rules_1","join","coerceAndCheckDataType","it","gen","data","opts","coerceTo","coerceToTypes","coerceTypes","checkTypes","wrongType","checkDataTypes","strictNumbers","Wrong","if","coerceData","reportTypeError","COERCIBLE","Set","filter","t","has","dataType","let","coerced","assign","coerceSpecificType","else","endIf","assignParentData","elseIf","expr","parentData","parentDataProperty","checkDataType","strictNums","correct","Correct","EQ","codegen_1","NEQ","cond","numCond","_cond","dataTypes","array","object","notObj","null","number","integer","typeError","message","params","schemaValue","cxt","getTypeErrorContext","schemaCode","keyword","parentSchema"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/compile/validate/dataType.ts"],"sourcesContent":["import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}