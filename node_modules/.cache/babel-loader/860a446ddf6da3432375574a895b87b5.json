{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools.js');\n\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform\n} = require('./_transforms.js');\n\nexports.type = 'visitor';\nexports.name = 'convertTransform';\nexports.active = true;\nexports.description = 'collapses multiple transformations and optimizes it';\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   convertToShorts?: boolean,\n *   degPrecision?: number,\n *   floatPrecision?: number,\n *   transformPrecision?: number,\n *   matrixToTransform?: boolean,\n *   shortTranslate?: boolean,\n *   shortScale?: boolean,\n *   shortRotate?: boolean,\n *   removeUseless?: boolean,\n *   collapseIntoOne?: boolean,\n *   leadingZero?: boolean,\n *   negativeExtraSpace?: boolean,\n * }>}\n */\n\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace\n  };\n  return {\n    element: {\n      enter: node => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        } // gradientTransform\n\n\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        } // patternTransform\n\n\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      }\n    }\n  };\n};\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\n\n\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach(item => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\n\n\nconst definePrecision = (data, _ref) => {\n  let { ...newParams\n  } = _ref;\n  const matrixData = [];\n\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n\n  let significantDigits = newParams.transformPrecision; // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(newParams.transformPrecision, Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision);\n    significantDigits = Math.max.apply(Math, matrixData.map(n => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n    ));\n  } // No sense in angle precision more then number of significant digits in matrix.\n\n\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(0, Math.min(newParams.floatPrecision, significantDigits - 2));\n  }\n\n  return newParams;\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst degRound = (data, params) => {\n  if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\n\n\nconst floatDigits = n => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\n\n\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i]; // convert matrix to the short aliases\n\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n\n      if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n\n      transform = transforms[i];\n    } // fixed-point numbers\n    // 12.754997 → 12.755\n\n\n    roundTransform(transform, params); // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n\n    if (params.shortTranslate && transform.name === 'translate' && transform.data.length === 2 && !transform.data[1]) {\n      transform.data.pop();\n    } // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n\n\n    if (params.shortScale && transform.name === 'scale' && transform.data.length === 2 && transform.data[0] === transform.data[1]) {\n      transform.data.pop();\n    } // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n\n\n    if (params.shortRotate && transforms[i - 2] && transforms[i - 2].name === 'translate' && transforms[i - 1].name === 'rotate' && transforms[i].name === 'translate' && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [transforms[i - 1].data[0], transforms[i - 2].data[0], transforms[i - 2].data[1]]\n      }); // splice compensation\n\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\n\n\nconst removeUseless = transforms => {\n  return transforms.filter(transform => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == 'rotate') && !transform.data[0] || // translate(0, 0)\n    transform.name == 'translate' && !transform.data[0] && !transform.data[1] || // scale(1)\n    transform.name == 'scale' && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)\n    transform.name == 'matrix' && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {\n      return false;\n    }\n\n    return true;\n  });\n};\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\n\n\nconst js2transform = (transformJS, params) => {\n  var transformString = ''; // collect output value string\n\n  transformJS.forEach(transform => {\n    roundTransform(transform, params);\n    transformString += (transformString && ' ') + transform.name + '(' + cleanupOutData(transform.data, params) + ')';\n  });\n  return transformString;\n};\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\n\n\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n\n    case 'rotate':\n      transform.data = [...degRound(transform.data.slice(0, 1), params), ...floatRound(transform.data.slice(1), params)];\n      break;\n\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n\n    case 'matrix':\n      transform.data = [...transformRound(transform.data.slice(0, 4), params), ...floatRound(transform.data.slice(4), params)];\n      break;\n  }\n\n  return transform;\n};\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\n\n\nconst round = data => {\n  return data.map(Math.round);\n};\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\n\n\nconst smartRound = (precision, data) => {\n  for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i--;) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/convertTransform.js"],"names":["cleanupOutData","require","transform2js","transformsMultiply","matrixToTransform","exports","type","name","active","description","fn","_root","params","convertToShorts","degPrecision","floatPrecision","transformPrecision","shortTranslate","shortScale","shortRotate","removeUseless","collapseIntoOne","leadingZero","negativeExtraSpace","newParams","element","enter","node","attributes","transform","convertTransform","gradientTransform","patternTransform","item","attrName","data","definePrecision","length","forEach","roundTransform","js2transform","matrixData","push","slice","significantDigits","Math","min","max","apply","map","floatDigits","n","toString","replace","degRound","smartRound","round","floatRound","transformRound","str","indexOf","transforms","i","decomposed","splice","pop","filter","transformJS","transformString","precision","tolerance","pow","toFixed","Number","rounded","abs"],"mappings":"AAAA;AAEA;AACA;AACA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAqBC,OAAO,CAAC,sBAAD,CAAlC;;AACA,MAAM;AACJC,EAAAA,YADI;AAEJC,EAAAA,kBAFI;AAGJC,EAAAA;AAHI,IAIFH,OAAO,CAAC,kBAAD,CAJX;;AAMAI,OAAO,CAACC,IAAR,GAAe,SAAf;AACAD,OAAO,CAACE,IAAR,GAAe,kBAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,IAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,qDAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,OAAO,CAACK,EAAR,GAAa,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC9B,QAAM;AACJC,IAAAA,eAAe,GAAG,IADd;AAEJ;AACAC,IAAAA,YAHI;AAIJC,IAAAA,cAAc,GAAG,CAJb;AAKJC,IAAAA,kBAAkB,GAAG,CALjB;AAMJZ,IAAAA,iBAAiB,GAAG,IANhB;AAOJa,IAAAA,cAAc,GAAG,IAPb;AAQJC,IAAAA,UAAU,GAAG,IART;AASJC,IAAAA,WAAW,GAAG,IATV;AAUJC,IAAAA,aAAa,GAAG,IAVZ;AAWJC,IAAAA,eAAe,GAAG,IAXd;AAYJC,IAAAA,WAAW,GAAG,IAZV;AAaJC,IAAAA,kBAAkB,GAAG;AAbjB,MAcFX,MAdJ;AAeA,QAAMY,SAAS,GAAG;AAChBX,IAAAA,eADgB;AAEhBC,IAAAA,YAFgB;AAGhBC,IAAAA,cAHgB;AAIhBC,IAAAA,kBAJgB;AAKhBZ,IAAAA,iBALgB;AAMhBa,IAAAA,cANgB;AAOhBC,IAAAA,UAPgB;AAQhBC,IAAAA,WARgB;AAShBC,IAAAA,aATgB;AAUhBC,IAAAA,eAVgB;AAWhBC,IAAAA,WAXgB;AAYhBC,IAAAA;AAZgB,GAAlB;AAcA,SAAO;AACLE,IAAAA,OAAO,EAAE;AACPC,MAAAA,KAAK,EAAGC,IAAD,IAAU;AACf;AACA,YAAIA,IAAI,CAACC,UAAL,CAAgBC,SAAhB,IAA6B,IAAjC,EAAuC;AACrCC,UAAAA,gBAAgB,CAACH,IAAD,EAAO,WAAP,EAAoBH,SAApB,CAAhB;AACD,SAJc,CAKf;;;AACA,YAAIG,IAAI,CAACC,UAAL,CAAgBG,iBAAhB,IAAqC,IAAzC,EAA+C;AAC7CD,UAAAA,gBAAgB,CAACH,IAAD,EAAO,mBAAP,EAA4BH,SAA5B,CAAhB;AACD,SARc,CASf;;;AACA,YAAIG,IAAI,CAACC,UAAL,CAAgBI,gBAAhB,IAAoC,IAAxC,EAA8C;AAC5CF,UAAAA,gBAAgB,CAACH,IAAD,EAAO,kBAAP,EAA2BH,SAA3B,CAAhB;AACD;AACF;AAdM;AADJ,GAAP;AAkBD,CAhDD;AAkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,gBAAgB,GAAG,CAACG,IAAD,EAAOC,QAAP,EAAiBtB,MAAjB,KAA4B;AACnD,MAAIuB,IAAI,GAAGjC,YAAY,CAAC+B,IAAI,CAACL,UAAL,CAAgBM,QAAhB,CAAD,CAAvB;AACAtB,EAAAA,MAAM,GAAGwB,eAAe,CAACD,IAAD,EAAOvB,MAAP,CAAxB;;AAEA,MAAIA,MAAM,CAACS,eAAP,IAA0Bc,IAAI,CAACE,MAAL,GAAc,CAA5C,EAA+C;AAC7CF,IAAAA,IAAI,GAAG,CAAChC,kBAAkB,CAACgC,IAAD,CAAnB,CAAP;AACD;;AAED,MAAIvB,MAAM,CAACC,eAAX,EAA4B;AAC1BsB,IAAAA,IAAI,GAAGtB,eAAe,CAACsB,IAAD,EAAOvB,MAAP,CAAtB;AACD,GAFD,MAEO;AACLuB,IAAAA,IAAI,CAACG,OAAL,CAAcL,IAAD,IAAUM,cAAc,CAACN,IAAD,EAAOrB,MAAP,CAArC;AACD;;AAED,MAAIA,MAAM,CAACQ,aAAX,EAA0B;AACxBe,IAAAA,IAAI,GAAGf,aAAa,CAACe,IAAD,CAApB;AACD;;AAED,MAAIA,IAAI,CAACE,MAAT,EAAiB;AACfJ,IAAAA,IAAI,CAACL,UAAL,CAAgBM,QAAhB,IAA4BM,YAAY,CAACL,IAAD,EAAOvB,MAAP,CAAxC;AACD,GAFD,MAEO;AACL,WAAOqB,IAAI,CAACL,UAAL,CAAgBM,QAAhB,CAAP;AACD;AACF,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,eAAe,GAAG,CAACD,IAAD,WAA4B;AAAA,MAArB,EAAE,GAAGX;AAAL,GAAqB;AAClD,QAAMiB,UAAU,GAAG,EAAnB;;AACA,OAAK,MAAMR,IAAX,IAAmBE,IAAnB,EAAyB;AACvB,QAAIF,IAAI,CAAC1B,IAAL,IAAa,QAAjB,EAA2B;AACzBkC,MAAAA,UAAU,CAACC,IAAX,CAAgB,GAAGT,IAAI,CAACE,IAAL,CAAUQ,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,CAAnB;AACD;AACF;;AACD,MAAIC,iBAAiB,GAAGpB,SAAS,CAACR,kBAAlC,CAPkD,CAQlD;;AACA,MAAIyB,UAAU,CAACJ,MAAf,EAAuB;AACrBb,IAAAA,SAAS,CAACR,kBAAV,GAA+B6B,IAAI,CAACC,GAAL,CAC7BtB,SAAS,CAACR,kBADmB,EAE7B6B,IAAI,CAACE,GAAL,CAASC,KAAT,CAAeH,IAAf,EAAqBJ,UAAU,CAACQ,GAAX,CAAeC,WAAf,CAArB,KACE1B,SAAS,CAACR,kBAHiB,CAA/B;AAKA4B,IAAAA,iBAAiB,GAAGC,IAAI,CAACE,GAAL,CAASC,KAAT,CAClBH,IADkB,EAElBJ,UAAU,CAACQ,GAAX,CACGE,CAAD,IAAOA,CAAC,CAACC,QAAF,GAAaC,OAAb,CAAqB,MAArB,EAA6B,EAA7B,EAAiChB,MAD1C,CACiD;AADjD,KAFkB,CAApB;AAMD,GArBiD,CAsBlD;;;AACA,MAAIb,SAAS,CAACV,YAAV,IAA0B,IAA9B,EAAoC;AAClCU,IAAAA,SAAS,CAACV,YAAV,GAAyB+B,IAAI,CAACE,GAAL,CACvB,CADuB,EAEvBF,IAAI,CAACC,GAAL,CAAStB,SAAS,CAACT,cAAnB,EAAmC6B,iBAAiB,GAAG,CAAvD,CAFuB,CAAzB;AAID;;AACD,SAAOpB,SAAP;AACD,CA9BD;AAgCA;AACA;AACA;;;AACA,MAAM8B,QAAQ,GAAG,CAACnB,IAAD,EAAOvB,MAAP,KAAkB;AACjC,MACEA,MAAM,CAACE,YAAP,IAAuB,IAAvB,IACAF,MAAM,CAACE,YAAP,IAAuB,CADvB,IAEAF,MAAM,CAACG,cAAP,GAAwB,EAH1B,EAIE;AACA,WAAOwC,UAAU,CAAC3C,MAAM,CAACE,YAAR,EAAsBqB,IAAtB,CAAjB;AACD,GAND,MAMO;AACL,WAAOqB,KAAK,CAACrB,IAAD,CAAZ;AACD;AACF,CAVD;AAWA;AACA;AACA;;;AACA,MAAMsB,UAAU,GAAG,CAACtB,IAAD,EAAOvB,MAAP,KAAkB;AACnC,MAAIA,MAAM,CAACG,cAAP,IAAyB,CAAzB,IAA8BH,MAAM,CAACG,cAAP,GAAwB,EAA1D,EAA8D;AAC5D,WAAOwC,UAAU,CAAC3C,MAAM,CAACG,cAAR,EAAwBoB,IAAxB,CAAjB;AACD,GAFD,MAEO;AACL,WAAOqB,KAAK,CAACrB,IAAD,CAAZ;AACD;AACF,CAND;AAQA;AACA;AACA;;;AACA,MAAMuB,cAAc,GAAG,CAACvB,IAAD,EAAOvB,MAAP,KAAkB;AACvC,MAAIA,MAAM,CAACI,kBAAP,IAA6B,CAA7B,IAAkCJ,MAAM,CAACG,cAAP,GAAwB,EAA9D,EAAkE;AAChE,WAAOwC,UAAU,CAAC3C,MAAM,CAACI,kBAAR,EAA4BmB,IAA5B,CAAjB;AACD,GAFD,MAEO;AACL,WAAOqB,KAAK,CAACrB,IAAD,CAAZ;AACD;AACF,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACA,MAAMe,WAAW,GAAIC,CAAD,IAAO;AACzB,QAAMQ,GAAG,GAAGR,CAAC,CAACC,QAAF,EAAZ;AACA,SAAOO,GAAG,CAAChB,KAAJ,CAAUgB,GAAG,CAACC,OAAJ,CAAY,GAAZ,CAAV,EAA4BvB,MAA5B,GAAqC,CAA5C;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;;;AACA,MAAMxB,eAAe,GAAG,CAACgD,UAAD,EAAajD,MAAb,KAAwB;AAC9C,OAAK,IAAIkD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACxB,MAA/B,EAAuCyB,CAAC,EAAxC,EAA4C;AAC1C,QAAIjC,SAAS,GAAGgC,UAAU,CAACC,CAAD,CAA1B,CAD0C,CAG1C;;AACA,QAAIlD,MAAM,CAACR,iBAAP,IAA4ByB,SAAS,CAACtB,IAAV,KAAmB,QAAnD,EAA6D;AAC3D,UAAIwD,UAAU,GAAG3D,iBAAiB,CAACyB,SAAD,EAAYjB,MAAZ,CAAlC;;AACA,UACE4B,YAAY,CAACuB,UAAD,EAAanD,MAAb,CAAZ,CAAiCyB,MAAjC,IACAG,YAAY,CAAC,CAACX,SAAD,CAAD,EAAcjB,MAAd,CAAZ,CAAkCyB,MAFpC,EAGE;AACAwB,QAAAA,UAAU,CAACG,MAAX,CAAkBF,CAAlB,EAAqB,CAArB,EAAwB,GAAGC,UAA3B;AACD;;AACDlC,MAAAA,SAAS,GAAGgC,UAAU,CAACC,CAAD,CAAtB;AACD,KAbyC,CAe1C;AACA;;;AACAvB,IAAAA,cAAc,CAACV,SAAD,EAAYjB,MAAZ,CAAd,CAjB0C,CAmB1C;AACA;;AACA,QACEA,MAAM,CAACK,cAAP,IACAY,SAAS,CAACtB,IAAV,KAAmB,WADnB,IAEAsB,SAAS,CAACM,IAAV,CAAeE,MAAf,KAA0B,CAF1B,IAGA,CAACR,SAAS,CAACM,IAAV,CAAe,CAAf,CAJH,EAKE;AACAN,MAAAA,SAAS,CAACM,IAAV,CAAe8B,GAAf;AACD,KA5ByC,CA8B1C;AACA;;;AACA,QACErD,MAAM,CAACM,UAAP,IACAW,SAAS,CAACtB,IAAV,KAAmB,OADnB,IAEAsB,SAAS,CAACM,IAAV,CAAeE,MAAf,KAA0B,CAF1B,IAGAR,SAAS,CAACM,IAAV,CAAe,CAAf,MAAsBN,SAAS,CAACM,IAAV,CAAe,CAAf,CAJxB,EAKE;AACAN,MAAAA,SAAS,CAACM,IAAV,CAAe8B,GAAf;AACD,KAvCyC,CAyC1C;AACA;;;AACA,QACErD,MAAM,CAACO,WAAP,IACA0C,UAAU,CAACC,CAAC,GAAG,CAAL,CADV,IAEAD,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkBvD,IAAlB,KAA2B,WAF3B,IAGAsD,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkBvD,IAAlB,KAA2B,QAH3B,IAIAsD,UAAU,CAACC,CAAD,CAAV,CAAcvD,IAAd,KAAuB,WAJvB,IAKAsD,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkB3B,IAAlB,CAAuB,CAAvB,MAA8B,CAAC0B,UAAU,CAACC,CAAD,CAAV,CAAc3B,IAAd,CAAmB,CAAnB,CAL/B,IAMA0B,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkB3B,IAAlB,CAAuB,CAAvB,MAA8B,CAAC0B,UAAU,CAACC,CAAD,CAAV,CAAc3B,IAAd,CAAmB,CAAnB,CAPjC,EAQE;AACA0B,MAAAA,UAAU,CAACG,MAAX,CAAkBF,CAAC,GAAG,CAAtB,EAAyB,CAAzB,EAA4B;AAC1BvD,QAAAA,IAAI,EAAE,QADoB;AAE1B4B,QAAAA,IAAI,EAAE,CACJ0B,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkB3B,IAAlB,CAAuB,CAAvB,CADI,EAEJ0B,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkB3B,IAAlB,CAAuB,CAAvB,CAFI,EAGJ0B,UAAU,CAACC,CAAC,GAAG,CAAL,CAAV,CAAkB3B,IAAlB,CAAuB,CAAvB,CAHI;AAFoB,OAA5B,EADA,CAUA;;AACA2B,MAAAA,CAAC,IAAI,CAAL;AACD;AACF;;AAED,SAAOD,UAAP;AACD,CApED;AAsEA;AACA;AACA;AACA;AACA;;;AACA,MAAMzC,aAAa,GAAIyC,UAAD,IAAgB;AACpC,SAAOA,UAAU,CAACK,MAAX,CAAmBrC,SAAD,IAAe;AACtC;AACA,QACG,CAAC,WAAD,EAAc,QAAd,EAAwB,OAAxB,EAAiC,OAAjC,EAA0C+B,OAA1C,CAAkD/B,SAAS,CAACtB,IAA5D,IAAoE,CAAC,CAArE,KACEsB,SAAS,CAACM,IAAV,CAAeE,MAAf,IAAyB,CAAzB,IAA8BR,SAAS,CAACtB,IAAV,IAAkB,QADlD,KAEC,CAACsB,SAAS,CAACM,IAAV,CAAe,CAAf,CAFH,IAGA;AACCN,IAAAA,SAAS,CAACtB,IAAV,IAAkB,WAAlB,IACC,CAACsB,SAAS,CAACM,IAAV,CAAe,CAAf,CADF,IAEC,CAACN,SAAS,CAACM,IAAV,CAAe,CAAf,CANH,IAOA;AACCN,IAAAA,SAAS,CAACtB,IAAV,IAAkB,OAAlB,IACCsB,SAAS,CAACM,IAAV,CAAe,CAAf,KAAqB,CADtB,KAEEN,SAAS,CAACM,IAAV,CAAeE,MAAf,GAAwB,CAAxB,IAA6BR,SAAS,CAACM,IAAV,CAAe,CAAf,KAAqB,CAFpD,CARD,IAWA;AACCN,IAAAA,SAAS,CAACtB,IAAV,IAAkB,QAAlB,IACCsB,SAAS,CAACM,IAAV,CAAe,CAAf,KAAqB,CADtB,IAECN,SAAS,CAACM,IAAV,CAAe,CAAf,KAAqB,CAFtB,IAGC,EACEN,SAAS,CAACM,IAAV,CAAe,CAAf,KACAN,SAAS,CAACM,IAAV,CAAe,CAAf,CADA,IAEAN,SAAS,CAACM,IAAV,CAAe,CAAf,CAFA,IAGAN,SAAS,CAACM,IAAV,CAAe,CAAf,CAJF,CAhBJ,EAsBE;AACA,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD,GA7BM,CAAP;AA8BD,CA/BD;AAiCA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,YAAY,GAAG,CAAC2B,WAAD,EAAcvD,MAAd,KAAyB;AAC5C,MAAIwD,eAAe,GAAG,EAAtB,CAD4C,CAG5C;;AACAD,EAAAA,WAAW,CAAC7B,OAAZ,CAAqBT,SAAD,IAAe;AACjCU,IAAAA,cAAc,CAACV,SAAD,EAAYjB,MAAZ,CAAd;AACAwD,IAAAA,eAAe,IACb,CAACA,eAAe,IAAI,GAApB,IACAvC,SAAS,CAACtB,IADV,GAEA,GAFA,GAGAP,cAAc,CAAC6B,SAAS,CAACM,IAAX,EAAiBvB,MAAjB,CAHd,GAIA,GALF;AAMD,GARD;AAUA,SAAOwD,eAAP;AACD,CAfD;AAiBA;AACA;AACA;;;AACA,MAAM7B,cAAc,GAAG,CAACV,SAAD,EAAYjB,MAAZ,KAAuB;AAC5C,UAAQiB,SAAS,CAACtB,IAAlB;AACE,SAAK,WAAL;AACEsB,MAAAA,SAAS,CAACM,IAAV,GAAiBsB,UAAU,CAAC5B,SAAS,CAACM,IAAX,EAAiBvB,MAAjB,CAA3B;AACA;;AACF,SAAK,QAAL;AACEiB,MAAAA,SAAS,CAACM,IAAV,GAAiB,CACf,GAAGmB,QAAQ,CAACzB,SAAS,CAACM,IAAV,CAAeQ,KAAf,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B/B,MAA7B,CADI,EAEf,GAAG6C,UAAU,CAAC5B,SAAS,CAACM,IAAV,CAAeQ,KAAf,CAAqB,CAArB,CAAD,EAA0B/B,MAA1B,CAFE,CAAjB;AAIA;;AACF,SAAK,OAAL;AACA,SAAK,OAAL;AACEiB,MAAAA,SAAS,CAACM,IAAV,GAAiBmB,QAAQ,CAACzB,SAAS,CAACM,IAAX,EAAiBvB,MAAjB,CAAzB;AACA;;AACF,SAAK,OAAL;AACEiB,MAAAA,SAAS,CAACM,IAAV,GAAiBuB,cAAc,CAAC7B,SAAS,CAACM,IAAX,EAAiBvB,MAAjB,CAA/B;AACA;;AACF,SAAK,QAAL;AACEiB,MAAAA,SAAS,CAACM,IAAV,GAAiB,CACf,GAAGuB,cAAc,CAAC7B,SAAS,CAACM,IAAV,CAAeQ,KAAf,CAAqB,CAArB,EAAwB,CAAxB,CAAD,EAA6B/B,MAA7B,CADF,EAEf,GAAG6C,UAAU,CAAC5B,SAAS,CAACM,IAAV,CAAeQ,KAAf,CAAqB,CAArB,CAAD,EAA0B/B,MAA1B,CAFE,CAAjB;AAIA;AAtBJ;;AAwBA,SAAOiB,SAAP;AACD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;;;AACA,MAAM2B,KAAK,GAAIrB,IAAD,IAAU;AACtB,SAAOA,IAAI,CAACc,GAAL,CAASJ,IAAI,CAACW,KAAd,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMD,UAAU,GAAG,CAACc,SAAD,EAAYlC,IAAZ,KAAqB;AACtC,OACE,IAAI2B,CAAC,GAAG3B,IAAI,CAACE,MAAb,EACEiC,SAAS,GAAG,CAACzB,IAAI,CAAC0B,GAAL,CAAS,GAAT,EAAcF,SAAd,EAAyBG,OAAzB,CAAiCH,SAAjC,CAFjB,EAGEP,CAAC,EAHH,GAKE;AACA,QAAIW,MAAM,CAACtC,IAAI,CAAC2B,CAAD,CAAJ,CAAQU,OAAR,CAAgBH,SAAhB,CAAD,CAAN,KAAuClC,IAAI,CAAC2B,CAAD,CAA/C,EAAoD;AAClD,UAAIY,OAAO,GAAG,CAACvC,IAAI,CAAC2B,CAAD,CAAJ,CAAQU,OAAR,CAAgBH,SAAS,GAAG,CAA5B,CAAf;AACAlC,MAAAA,IAAI,CAAC2B,CAAD,CAAJ,GACE,CAACjB,IAAI,CAAC8B,GAAL,CAASD,OAAO,GAAGvC,IAAI,CAAC2B,CAAD,CAAvB,EAA4BU,OAA5B,CAAoCH,SAAS,GAAG,CAAhD,CAAD,IAAuDC,SAAvD,GACI,CAACnC,IAAI,CAAC2B,CAAD,CAAJ,CAAQU,OAAR,CAAgBH,SAAhB,CADL,GAEIK,OAHN;AAID;AACF;;AACD,SAAOvC,IAAP;AACD,CAhBD","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { cleanupOutData } = require('../lib/svgo/tools.js');\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform,\n} = require('./_transforms.js');\n\nexports.type = 'visitor';\nexports.name = 'convertTransform';\nexports.active = true;\nexports.description = 'collapses multiple transformations and optimizes it';\n\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   convertToShorts?: boolean,\n *   degPrecision?: number,\n *   floatPrecision?: number,\n *   transformPrecision?: number,\n *   matrixToTransform?: boolean,\n *   shortTranslate?: boolean,\n *   shortScale?: boolean,\n *   shortRotate?: boolean,\n *   removeUseless?: boolean,\n *   collapseIntoOne?: boolean,\n *   leadingZero?: boolean,\n *   negativeExtraSpace?: boolean,\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false,\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace,\n  };\n  return {\n    element: {\n      enter: (node) => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        }\n        // gradientTransform\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        }\n        // patternTransform\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      },\n    },\n  };\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach((item) => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\nconst definePrecision = (data, { ...newParams }) => {\n  const matrixData = [];\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n  let significantDigits = newParams.transformPrecision;\n  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(\n      newParams.transformPrecision,\n      Math.max.apply(Math, matrixData.map(floatDigits)) ||\n        newParams.transformPrecision\n    );\n    significantDigits = Math.max.apply(\n      Math,\n      matrixData.map(\n        (n) => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n      )\n    );\n  }\n  // No sense in angle precision more then number of significant digits in matrix.\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(\n      0,\n      Math.min(newParams.floatPrecision, significantDigits - 2)\n    );\n  }\n  return newParams;\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst degRound = (data, params) => {\n  if (\n    params.degPrecision != null &&\n    params.degPrecision >= 1 &&\n    params.floatPrecision < 20\n  ) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\nconst floatDigits = (n) => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i];\n\n    // convert matrix to the short aliases\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n      if (\n        js2transform(decomposed, params).length <=\n        js2transform([transform], params).length\n      ) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n      transform = transforms[i];\n    }\n\n    // fixed-point numbers\n    // 12.754997 → 12.755\n    roundTransform(transform, params);\n\n    // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n    if (\n      params.shortTranslate &&\n      transform.name === 'translate' &&\n      transform.data.length === 2 &&\n      !transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n    if (\n      params.shortScale &&\n      transform.name === 'scale' &&\n      transform.data.length === 2 &&\n      transform.data[0] === transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n    if (\n      params.shortRotate &&\n      transforms[i - 2] &&\n      transforms[i - 2].name === 'translate' &&\n      transforms[i - 1].name === 'rotate' &&\n      transforms[i].name === 'translate' &&\n      transforms[i - 2].data[0] === -transforms[i].data[0] &&\n      transforms[i - 2].data[1] === -transforms[i].data[1]\n    ) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [\n          transforms[i - 1].data[0],\n          transforms[i - 2].data[0],\n          transforms[i - 2].data[1],\n        ],\n      });\n\n      // splice compensation\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\nconst removeUseless = (transforms) => {\n  return transforms.filter((transform) => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (\n      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&\n        (transform.data.length == 1 || transform.name == 'rotate') &&\n        !transform.data[0]) ||\n      // translate(0, 0)\n      (transform.name == 'translate' &&\n        !transform.data[0] &&\n        !transform.data[1]) ||\n      // scale(1)\n      (transform.name == 'scale' &&\n        transform.data[0] == 1 &&\n        (transform.data.length < 2 || transform.data[1] == 1)) ||\n      // matrix(1 0 0 1 0 0)\n      (transform.name == 'matrix' &&\n        transform.data[0] == 1 &&\n        transform.data[3] == 1 &&\n        !(\n          transform.data[1] ||\n          transform.data[2] ||\n          transform.data[4] ||\n          transform.data[5]\n        ))\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\nconst js2transform = (transformJS, params) => {\n  var transformString = '';\n\n  // collect output value string\n  transformJS.forEach((transform) => {\n    roundTransform(transform, params);\n    transformString +=\n      (transformString && ' ') +\n      transform.name +\n      '(' +\n      cleanupOutData(transform.data, params) +\n      ')';\n  });\n\n  return transformString;\n};\n\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n    case 'rotate':\n      transform.data = [\n        ...degRound(transform.data.slice(0, 1), params),\n        ...floatRound(transform.data.slice(1), params),\n      ];\n      break;\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n    case 'matrix':\n      transform.data = [\n        ...transformRound(transform.data.slice(0, 4), params),\n        ...floatRound(transform.data.slice(4), params),\n      ];\n      break;\n  }\n  return transform;\n};\n\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\nconst round = (data) => {\n  return data.map(Math.round);\n};\n\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\nconst smartRound = (precision, data) => {\n  for (\n    var i = data.length,\n      tolerance = +Math.pow(0.1, precision).toFixed(precision);\n    i--;\n\n  ) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n};\n"]},"metadata":{},"sourceType":"script"}