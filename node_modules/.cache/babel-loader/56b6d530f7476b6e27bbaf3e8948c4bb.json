{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nfunction getValues(list, node, index) {\n  if (index % 2 === 0) {\n    let value = NaN;\n\n    if (node.type === 'function' && (node.value === 'var' || node.value === 'env') && node.nodes.length === 1) {\n      value = valueParser.stringify(node.nodes);\n    } else if (node.type === 'word') {\n      value = parseFloat(node.value);\n    }\n\n    return [...list, value];\n  }\n\n  return list;\n}\n\nfunction matrix3d(node, values) {\n  if (values.length !== 16) {\n    return;\n  } // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)\n\n\n  if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {\n    const {\n      nodes\n    } = node;\n    node.value = 'matrix';\n    node.nodes = [nodes[0], // a\n    nodes[1], // ,\n    nodes[2], // b\n    nodes[3], // ,\n    nodes[8], // c\n    nodes[9], // ,\n    nodes[10], // d\n    nodes[11], // ,\n    nodes[24], // tx\n    nodes[25], // ,\n    nodes[26] // ty\n    ];\n  }\n}\n\nconst rotate3dMappings = new Map([[[1, 0, 0].toString(), 'rotateX'], // rotate3d(1, 0, 0, a) => rotateX(a)\n[[0, 1, 0].toString(), 'rotateY'], // rotate3d(0, 1, 0, a) => rotateY(a)\n[[0, 0, 1].toString(), 'rotate'] // rotate3d(0, 0, 1, a) => rotate(a)\n]);\n\nfunction rotate3d(node, values) {\n  if (values.length !== 4) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const match = rotate3dMappings.get(values.slice(0, 3).toString());\n\n  if (match) {\n    node.value = match;\n    node.nodes = [nodes[6]];\n  }\n}\n\nfunction rotateZ(node, values) {\n  if (values.length !== 1) {\n    return;\n  } // rotateZ(rz) => rotate(rz)\n\n\n  node.value = 'rotate';\n}\n\nfunction scale(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const [first, second] = values; // scale(sx, sy) => scale(sx)\n\n  if (first === second) {\n    node.nodes = [nodes[0]];\n    return;\n  } // scale(sx, 1) => scaleX(sx)\n\n\n  if (second === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n    return;\n  } // scale(1, sy) => scaleY(sy)\n\n\n  if (first === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n    return;\n  }\n}\n\nfunction scale3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const [first, second, third] = values; // scale3d(sx, 1, 1) => scaleX(sx)\n\n  if (second === 1 && third === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n    return;\n  } // scale3d(1, sy, 1) => scaleY(sy)\n\n\n  if (first === 1 && third === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n    return;\n  } // scale3d(1, 1, sz) => scaleZ(sz)\n\n\n  if (first === 1 && second === 1) {\n    node.value = 'scaleZ';\n    node.nodes = [nodes[4]];\n    return;\n  }\n}\n\nfunction translate(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node; // translate(tx, 0) => translate(tx)\n\n  if (values[1] === 0) {\n    node.nodes = [nodes[0]];\n    return;\n  } // translate(0, ty) => translateY(ty)\n\n\n  if (values[0] === 0) {\n    node.value = 'translateY';\n    node.nodes = [nodes[2]];\n    return;\n  }\n}\n\nfunction translate3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node; // translate3d(0, 0, tz) => translateZ(tz)\n\n  if (values[0] === 0 && values[1] === 0) {\n    node.value = 'translateZ';\n    node.nodes = [nodes[4]];\n  }\n}\n\nconst reducers = new Map([['matrix3d', matrix3d], ['rotate3d', rotate3d], ['rotateZ', rotateZ], ['scale', scale], ['scale3d', scale3d], ['translate', translate], ['translate3d', translate3d]]);\n\nfunction normalizeReducerName(name) {\n  const lowerCasedName = name.toLowerCase();\n\n  if (lowerCasedName === 'rotatez') {\n    return 'rotateZ';\n  }\n\n  return lowerCasedName;\n}\n\nfunction reduce(node) {\n  if (node.type === 'function') {\n    const normalizedReducerName = normalizeReducerName(node.value);\n    const reducer = reducers.get(normalizedReducerName);\n\n    if (reducer !== undefined) {\n      reducer(node, node.nodes.reduce(getValues, []));\n    }\n  }\n\n  return false;\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-reduce-transforms',\n\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/transform$/i, decl => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n              return;\n            }\n\n            const result = valueParser(value).walk(reduce).toString();\n            decl.value = result;\n            cache.set(value, result);\n          });\n        }\n\n      };\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-reduce-transforms/src/index.js"],"names":["valueParser","require","getValues","list","node","index","value","NaN","type","nodes","length","stringify","parseFloat","matrix3d","values","rotate3dMappings","Map","toString","rotate3d","match","get","slice","rotateZ","scale","first","second","scale3d","third","translate","translate3d","reducers","normalizeReducerName","name","lowerCasedName","toLowerCase","reduce","normalizedReducerName","reducer","undefined","pluginCreator","postcssPlugin","prepare","cache","OnceExit","css","walkDecls","decl","has","result","walk","set","postcss","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\n\nfunction getValues(list, node, index) {\n  if (index % 2 === 0) {\n    let value = NaN;\n\n    if (\n      node.type === 'function' &&\n      (node.value === 'var' || node.value === 'env') &&\n      node.nodes.length === 1\n    ) {\n      value = valueParser.stringify(node.nodes);\n    } else if (node.type === 'word') {\n      value = parseFloat(node.value);\n    }\n\n    return [...list, value];\n  }\n\n  return list;\n}\n\nfunction matrix3d(node, values) {\n  if (values.length !== 16) {\n    return;\n  }\n\n  // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)\n  if (\n    values[15] &&\n    values[2] === 0 &&\n    values[3] === 0 &&\n    values[6] === 0 &&\n    values[7] === 0 &&\n    values[8] === 0 &&\n    values[9] === 0 &&\n    values[10] === 1 &&\n    values[11] === 0 &&\n    values[14] === 0 &&\n    values[15] === 1\n  ) {\n    const { nodes } = node;\n\n    node.value = 'matrix';\n    node.nodes = [\n      nodes[0], // a\n      nodes[1], // ,\n      nodes[2], // b\n      nodes[3], // ,\n      nodes[8], // c\n      nodes[9], // ,\n      nodes[10], // d\n      nodes[11], // ,\n      nodes[24], // tx\n      nodes[25], // ,\n      nodes[26], // ty\n    ];\n  }\n}\n\nconst rotate3dMappings = new Map([\n  [[1, 0, 0].toString(), 'rotateX'], // rotate3d(1, 0, 0, a) => rotateX(a)\n  [[0, 1, 0].toString(), 'rotateY'], // rotate3d(0, 1, 0, a) => rotateY(a)\n  [[0, 0, 1].toString(), 'rotate'], // rotate3d(0, 0, 1, a) => rotate(a)\n]);\n\nfunction rotate3d(node, values) {\n  if (values.length !== 4) {\n    return;\n  }\n\n  const { nodes } = node;\n  const match = rotate3dMappings.get(values.slice(0, 3).toString());\n\n  if (match) {\n    node.value = match;\n    node.nodes = [nodes[6]];\n  }\n}\n\nfunction rotateZ(node, values) {\n  if (values.length !== 1) {\n    return;\n  }\n\n  // rotateZ(rz) => rotate(rz)\n  node.value = 'rotate';\n}\n\nfunction scale(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second] = values;\n\n  // scale(sx, sy) => scale(sx)\n  if (first === second) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(sx, 1) => scaleX(sx)\n  if (second === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(1, sy) => scaleY(sy)\n  if (first === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\nfunction scale3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second, third] = values;\n\n  // scale3d(sx, 1, 1) => scaleX(sx)\n  if (second === 1 && third === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale3d(1, sy, 1) => scaleY(sy)\n  if (first === 1 && third === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n\n  // scale3d(1, 1, sz) => scaleZ(sz)\n  if (first === 1 && second === 1) {\n    node.value = 'scaleZ';\n    node.nodes = [nodes[4]];\n\n    return;\n  }\n}\n\nfunction translate(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate(tx, 0) => translate(tx)\n  if (values[1] === 0) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // translate(0, ty) => translateY(ty)\n  if (values[0] === 0) {\n    node.value = 'translateY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\nfunction translate3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate3d(0, 0, tz) => translateZ(tz)\n  if (values[0] === 0 && values[1] === 0) {\n    node.value = 'translateZ';\n    node.nodes = [nodes[4]];\n  }\n}\n\nconst reducers = new Map([\n  ['matrix3d', matrix3d],\n  ['rotate3d', rotate3d],\n  ['rotateZ', rotateZ],\n  ['scale', scale],\n  ['scale3d', scale3d],\n  ['translate', translate],\n  ['translate3d', translate3d],\n]);\n\nfunction normalizeReducerName(name) {\n  const lowerCasedName = name.toLowerCase();\n\n  if (lowerCasedName === 'rotatez') {\n    return 'rotateZ';\n  }\n\n  return lowerCasedName;\n}\n\nfunction reduce(node) {\n  if (node.type === 'function') {\n    const normalizedReducerName = normalizeReducerName(node.value);\n    const reducer = reducers.get(normalizedReducerName);\n    if (reducer !== undefined) {\n      reducer(node, node.nodes.reduce(getValues, []));\n    }\n  }\n  return false;\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-reduce-transforms',\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/transform$/i, (decl) => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n\n              return;\n            }\n\n            const result = valueParser(value).walk(reduce).toString();\n\n            decl.value = result;\n            cache.set(value, result);\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]},"metadata":{},"sourceType":"script"}