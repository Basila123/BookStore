{"ast":null,"code":"'use strict';\n\nconst stylehacks = require('stylehacks');\n\nconst canMerge = require('../canMerge');\n\nconst getDecls = require('../getDecls');\n\nconst minifyTrbl = require('../minifyTrbl');\n\nconst parseTrbl = require('../parseTrbl');\n\nconst insertCloned = require('../insertCloned');\n\nconst mergeRules = require('../mergeRules');\n\nconst mergeValues = require('../mergeValues');\n\nconst remove = require('../remove');\n\nconst trbl = require('../trbl');\n\nconst isCustomProp = require('../isCustomProp');\n\nconst canExplode = require('../canExplode');\n\nmodule.exports = prop => {\n  const properties = trbl.map(direction => `${prop}-${direction}`);\n\n  const cleanup = rule => {\n    let decls = getDecls(rule, [prop].concat(properties));\n\n    while (decls.length) {\n      const lastNode = decls[decls.length - 1]; // remove properties of lower precedence\n\n      const lesser = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && lastNode.prop === prop && node.prop !== lastNode.prop);\n      lesser.forEach(remove);\n      decls = decls.filter(node => !lesser.includes(node)); // get duplicate properties\n\n      let duplicates = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode)));\n      duplicates.forEach(remove);\n      decls = decls.filter(node => node !== lastNode && !duplicates.includes(node));\n    }\n  };\n\n  const processor = {\n    explode: rule => {\n      rule.walkDecls(new RegExp('^' + prop + '$', 'i'), decl => {\n        if (!canExplode(decl)) {\n          return;\n        }\n\n        if (stylehacks.detect(decl)) {\n          return;\n        }\n\n        const values = parseTrbl(decl.value);\n        trbl.forEach((direction, index) => {\n          insertCloned(decl.parent, decl, {\n            prop: properties[index],\n            value: values[index]\n          });\n        });\n        decl.remove();\n      });\n    },\n    merge: rule => {\n      mergeRules(rule, properties, (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: minifyTrbl(mergeValues(...rules))\n          });\n          rules.forEach(remove);\n          return true;\n        }\n      });\n      cleanup(rule);\n    }\n  };\n  return processor;\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-merge-longhand/src/lib/decl/boxBase.js"],"names":["stylehacks","require","canMerge","getDecls","minifyTrbl","parseTrbl","insertCloned","mergeRules","mergeValues","remove","trbl","isCustomProp","canExplode","module","exports","prop","properties","map","direction","cleanup","rule","decls","concat","length","lastNode","lesser","filter","node","detect","important","forEach","includes","duplicates","processor","explode","walkDecls","RegExp","decl","values","value","index","parent","merge","rules","some"],"mappings":"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","sourcesContent":["'use strict';\nconst stylehacks = require('stylehacks');\nconst canMerge = require('../canMerge');\nconst getDecls = require('../getDecls');\nconst minifyTrbl = require('../minifyTrbl');\nconst parseTrbl = require('../parseTrbl');\nconst insertCloned = require('../insertCloned');\nconst mergeRules = require('../mergeRules');\nconst mergeValues = require('../mergeValues');\nconst remove = require('../remove');\nconst trbl = require('../trbl');\nconst isCustomProp = require('../isCustomProp');\nconst canExplode = require('../canExplode');\n\nmodule.exports = (prop) => {\n  const properties = trbl.map((direction) => `${prop}-${direction}`);\n\n  const cleanup = (rule) => {\n    let decls = getDecls(rule, [prop].concat(properties));\n\n    while (decls.length) {\n      const lastNode = decls[decls.length - 1];\n\n      // remove properties of lower precedence\n      const lesser = decls.filter(\n        (node) =>\n          !stylehacks.detect(lastNode) &&\n          !stylehacks.detect(node) &&\n          node !== lastNode &&\n          node.important === lastNode.important &&\n          lastNode.prop === prop &&\n          node.prop !== lastNode.prop\n      );\n\n      lesser.forEach(remove);\n      decls = decls.filter((node) => !lesser.includes(node));\n\n      // get duplicate properties\n      let duplicates = decls.filter(\n        (node) =>\n          !stylehacks.detect(lastNode) &&\n          !stylehacks.detect(node) &&\n          node !== lastNode &&\n          node.important === lastNode.important &&\n          node.prop === lastNode.prop &&\n          !(!isCustomProp(node) && isCustomProp(lastNode))\n      );\n\n      duplicates.forEach(remove);\n      decls = decls.filter(\n        (node) => node !== lastNode && !duplicates.includes(node)\n      );\n    }\n  };\n\n  const processor = {\n    explode: (rule) => {\n      rule.walkDecls(new RegExp('^' + prop + '$', 'i'), (decl) => {\n        if (!canExplode(decl)) {\n          return;\n        }\n\n        if (stylehacks.detect(decl)) {\n          return;\n        }\n\n        const values = parseTrbl(decl.value);\n\n        trbl.forEach((direction, index) => {\n          insertCloned(decl.parent, decl, {\n            prop: properties[index],\n            value: values[index],\n          });\n        });\n\n        decl.remove();\n      });\n    },\n    merge: (rule) => {\n      mergeRules(rule, properties, (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(lastNode.parent, lastNode, {\n            prop,\n            value: minifyTrbl(mergeValues(...rules)),\n          });\n          rules.forEach(remove);\n\n          return true;\n        }\n      });\n\n      cleanup(rule);\n    },\n  };\n\n  return processor;\n};\n"]},"metadata":{},"sourceType":"script"}