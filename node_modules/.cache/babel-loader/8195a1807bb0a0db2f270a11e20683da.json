{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst errors_1 = require(\"../errors\");\n\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\n\nexports.macroKeywordCode = macroKeywordCode;\n\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n\n  function assignValid() {\n    let _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)`await ` : codegen_1.nil;\n\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n\n  function reportErrs(errors) {\n    var _a;\n\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\n\nexports.funcKeywordCode = funcKeywordCode;\n\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\n\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\n\nfunction checkAsyncKeyword(_ref, def) {\n  let {\n    schemaEnv\n  } = _ref;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\n\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\n\nfunction validSchemaType(schema, schemaType) {\n  let allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\n\nexports.validSchemaType = validSchemaType;\n\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  let {\n    schema,\n    opts,\n    self,\n    errSchemaPath\n  } = _ref2;\n\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n\n  const deps = def.dependencies;\n\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\n\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"mappings":"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","names":["macroKeywordCode","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","codegen_1","errSchemaPath","topSchemaRef","compositeRule","pass","error","exports","funcKeywordCode","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","_a","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","names_1","this","passSchema","data","parentData","parentDataProperty","errs","vErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","code","validSchemaType","schemaType","allowUndefined","length","some","st","Array","isArray","validateKeywordUsage","includes","deps","dependencies","kwd","Object","prototype","hasOwnProperty","join","msg","errorsText","logger"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/compile/validate/keyword.ts"],"sourcesContent":["import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}