{"ast":null,"code":"'use strict'; // TODO implement as separate plugin\n\nconst {\n  transformsMultiply,\n  transform2js,\n  transformArc\n} = require('./_transforms.js');\n\nconst {\n  removeLeadingZero\n} = require('../lib/svgo/tools.js');\n\nconst {\n  referencesProps,\n  attrsGroupsDefaults\n} = require('./_collections.js');\n\nconst regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\nconst defaultStrokeWidth = attrsGroupsDefaults.presentation['stroke-width'];\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\n\nconst applyTransforms = (elem, pathData, params) => {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (elem.attributes.transform == null || elem.attributes.transform === '' || // styles are not considered when applying transform\n  // can be fixed properly with new style engine\n  elem.attributes.style != null || Object.entries(elem.attributes).some(_ref => {\n    let [name, value] = _ref;\n    return referencesProps.includes(name) && value.includes('url(');\n  })) {\n    return;\n  }\n\n  const matrix = transformsMultiply(transform2js(elem.attributes.transform));\n  const stroke = elem.computedAttr('stroke');\n  const id = elem.computedAttr('id');\n  const transformPrecision = params.transformPrecision;\n\n  if (stroke && stroke != 'none') {\n    if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2])) return; // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n\n    if (id) {\n      let idElem = elem;\n      let hasStrokeWidth = false;\n\n      do {\n        if (idElem.attributes['stroke-width']) {\n          hasStrokeWidth = true;\n        }\n      } while (idElem.attributes.id !== id && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n      if (!hasStrokeWidth) return;\n    }\n\n    const scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n    if (scale !== 1) {\n      const strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n      if (elem.attributes['vector-effect'] == null || elem.attributes['vector-effect'] !== 'non-scaling-stroke') {\n        if (elem.attributes['stroke-width'] != null) {\n          elem.attributes['stroke-width'] = elem.attributes['stroke-width'].trim().replace(regNumericValues, num => removeLeadingZero(num * scale));\n        } else {\n          elem.attributes['stroke-width'] = strokeWidth.replace(regNumericValues, num => removeLeadingZero(num * scale));\n        }\n\n        if (elem.attributes['stroke-dashoffset'] != null) {\n          elem.attributes['stroke-dashoffset'] = elem.attributes['stroke-dashoffset'].trim().replace(regNumericValues, num => removeLeadingZero(num * scale));\n        }\n\n        if (elem.attributes['stroke-dasharray'] != null) {\n          elem.attributes['stroke-dasharray'] = elem.attributes['stroke-dasharray'].trim().replace(regNumericValues, num => removeLeadingZero(num * scale));\n        }\n      }\n    }\n  } else if (id) {\n    // Stroke and stroke-width can be redefined with <use>\n    return;\n  }\n\n  applyMatrixToPathData(pathData, matrix.data); // remove transform attr\n\n  delete elem.attributes.transform;\n  return;\n};\n\nexports.applyTransforms = applyTransforms;\n\nconst transformAbsolutePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y + matrix[4];\n  const newY = matrix[1] * x + matrix[3] * y + matrix[5];\n  return [newX, newY];\n};\n\nconst transformRelativePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y;\n  const newY = matrix[1] * x + matrix[3] * y;\n  return [newX, newY];\n};\n\nconst applyMatrixToPathData = (pathData, matrix) => {\n  const start = [0, 0];\n  const cursor = [0, 0];\n\n  for (const pathItem of pathData) {\n    let {\n      command,\n      args\n    } = pathItem; // moveto (x y)\n\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    if (command === 'm') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    } // horizontal lineto (x)\n    // convert to lineto to handle two-dimentional transforms\n\n\n    if (command === 'H') {\n      command = 'L';\n      args = [args[0], cursor[1]];\n    }\n\n    if (command === 'h') {\n      command = 'l';\n      args = [args[0], 0];\n    } // vertical lineto (y)\n    // convert to lineto to handle two-dimentional transforms\n\n\n    if (command === 'V') {\n      command = 'L';\n      args = [cursor[0], args[0]];\n    }\n\n    if (command === 'v') {\n      command = 'l';\n      args = [0, args[0]];\n    } // lineto (x y)\n\n\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    } // curveto (x1 y1 x2 y2 x y)\n\n\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);\n      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);\n      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    } // smooth curveto (x2 y2 x y)\n\n\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    } // quadratic Bézier curveto (x1 y1 x y)\n\n\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    } // smooth quadratic Bézier curveto (x y)\n\n\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    } // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n\n\n    if (command === 'A') {\n      transformArc(cursor, args, matrix);\n      cursor[0] = args[5];\n      cursor[1] = args[6]; // reduce number of digits in rotation angle\n\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n\n      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n\n    if (command === 'a') {\n      transformArc([0, 0], args, matrix);\n      cursor[0] += args[5];\n      cursor[1] += args[6]; // reduce number of digits in rotation angle\n\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n\n      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    } // closepath\n\n\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n  }\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/_applyTransforms.js"],"names":["transformsMultiply","transform2js","transformArc","require","removeLeadingZero","referencesProps","attrsGroupsDefaults","regNumericValues","defaultStrokeWidth","presentation","applyTransforms","elem","pathData","params","attributes","transform","style","Object","entries","some","name","value","includes","matrix","stroke","computedAttr","id","transformPrecision","applyTransformsStroked","data","idElem","hasStrokeWidth","parentNode","scale","Math","sqrt","toFixed","strokeWidth","trim","replace","num","applyMatrixToPathData","exports","transformAbsolutePoint","x","y","newX","newY","transformRelativePoint","start","cursor","pathItem","command","args","x1","y1","x2","y2","abs","a","rotation"],"mappings":"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","sourcesContent":["'use strict';\n\n// TODO implement as separate plugin\n\nconst {\n  transformsMultiply,\n  transform2js,\n  transformArc,\n} = require('./_transforms.js');\nconst { removeLeadingZero } = require('../lib/svgo/tools.js');\nconst { referencesProps, attrsGroupsDefaults } = require('./_collections.js');\n\nconst regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\nconst defaultStrokeWidth = attrsGroupsDefaults.presentation['stroke-width'];\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\nconst applyTransforms = (elem, pathData, params) => {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (\n    elem.attributes.transform == null ||\n    elem.attributes.transform === '' ||\n    // styles are not considered when applying transform\n    // can be fixed properly with new style engine\n    elem.attributes.style != null ||\n    Object.entries(elem.attributes).some(\n      ([name, value]) =>\n        referencesProps.includes(name) && value.includes('url(')\n    )\n  ) {\n    return;\n  }\n\n  const matrix = transformsMultiply(transform2js(elem.attributes.transform));\n  const stroke = elem.computedAttr('stroke');\n  const id = elem.computedAttr('id');\n  const transformPrecision = params.transformPrecision;\n\n  if (stroke && stroke != 'none') {\n    if (\n      !params.applyTransformsStroked ||\n      ((matrix.data[0] != matrix.data[3] ||\n        matrix.data[1] != -matrix.data[2]) &&\n        (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))\n    )\n      return;\n\n    // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n    if (id) {\n      let idElem = elem;\n      let hasStrokeWidth = false;\n\n      do {\n        if (idElem.attributes['stroke-width']) {\n          hasStrokeWidth = true;\n        }\n      } while (\n        idElem.attributes.id !== id &&\n        !hasStrokeWidth &&\n        (idElem = idElem.parentNode)\n      );\n\n      if (!hasStrokeWidth) return;\n    }\n\n    const scale = +Math.sqrt(\n      matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]\n    ).toFixed(transformPrecision);\n\n    if (scale !== 1) {\n      const strokeWidth =\n        elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n      if (\n        elem.attributes['vector-effect'] == null ||\n        elem.attributes['vector-effect'] !== 'non-scaling-stroke'\n      ) {\n        if (elem.attributes['stroke-width'] != null) {\n          elem.attributes['stroke-width'] = elem.attributes['stroke-width']\n            .trim()\n            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));\n        } else {\n          elem.attributes['stroke-width'] = strokeWidth.replace(\n            regNumericValues,\n            (num) => removeLeadingZero(num * scale)\n          );\n        }\n\n        if (elem.attributes['stroke-dashoffset'] != null) {\n          elem.attributes['stroke-dashoffset'] = elem.attributes[\n            'stroke-dashoffset'\n          ]\n            .trim()\n            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));\n        }\n\n        if (elem.attributes['stroke-dasharray'] != null) {\n          elem.attributes['stroke-dasharray'] = elem.attributes[\n            'stroke-dasharray'\n          ]\n            .trim()\n            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));\n        }\n      }\n    }\n  } else if (id) {\n    // Stroke and stroke-width can be redefined with <use>\n    return;\n  }\n\n  applyMatrixToPathData(pathData, matrix.data);\n\n  // remove transform attr\n  delete elem.attributes.transform;\n\n  return;\n};\nexports.applyTransforms = applyTransforms;\n\nconst transformAbsolutePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y + matrix[4];\n  const newY = matrix[1] * x + matrix[3] * y + matrix[5];\n  return [newX, newY];\n};\n\nconst transformRelativePoint = (matrix, x, y) => {\n  const newX = matrix[0] * x + matrix[2] * y;\n  const newY = matrix[1] * x + matrix[3] * y;\n  return [newX, newY];\n};\n\nconst applyMatrixToPathData = (pathData, matrix) => {\n  const start = [0, 0];\n  const cursor = [0, 0];\n\n  for (const pathItem of pathData) {\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'm') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // horizontal lineto (x)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'H') {\n      command = 'L';\n      args = [args[0], cursor[1]];\n    }\n    if (command === 'h') {\n      command = 'l';\n      args = [args[0], 0];\n    }\n\n    // vertical lineto (y)\n    // convert to lineto to handle two-dimentional transforms\n    if (command === 'V') {\n      command = 'L';\n      args = [cursor[0], args[0]];\n    }\n    if (command === 'v') {\n      command = 'l';\n      args = [0, args[0]];\n    }\n\n    // lineto (x y)\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);\n      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);\n      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x2;\n      args[3] = y2;\n      args[4] = x;\n      args[5] = y;\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x2;\n      args[1] = y2;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);\n      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);\n      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);\n      args[0] = x1;\n      args[1] = y1;\n      args[2] = x;\n      args[3] = y;\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);\n      args[0] = x;\n      args[1] = y;\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'A') {\n      transformArc(cursor, args, matrix);\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n    if (command === 'a') {\n      transformArc([0, 0], args, matrix);\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n      // reduce number of digits in rotation angle\n      if (Math.abs(args[2]) > 80) {\n        const a = args[0];\n        const rotation = args[2];\n        args[0] = args[1];\n        args[1] = a;\n        args[2] = rotation + (rotation > 0 ? -90 : 90);\n      }\n      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);\n      args[5] = x;\n      args[6] = y;\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}