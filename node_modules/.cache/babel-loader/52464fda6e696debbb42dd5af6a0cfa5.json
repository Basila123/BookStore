{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst _util_1 = require(\"./_util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        schemaProp\n      }\n    } = _ref;\n    return schemaProp ? (0, codegen_1.str)`should match case \"${schemaProp}\" schema` : (0, codegen_1.str)`should match default case schema`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        schemaProp\n      }\n    } = _ref2;\n    return schemaProp ? (0, codegen_1._)`{failingCase: ${schemaProp}}` : (0, codegen_1._)`{failingDefault: true}`;\n  }\n};\n\nfunction getDef(opts) {\n  const metaSchema = (0, _util_1.metaSchemaRef)(opts);\n  return [{\n    keyword: \"select\",\n    schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n    $data: true,\n    error,\n    dependencies: [\"selectCases\"],\n\n    code(cxt) {\n      const {\n        gen,\n        schemaCode,\n        parentSchema\n      } = cxt;\n      cxt.block$data(codegen_1.nil, () => {\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        const value = gen.const(\"value\", (0, codegen_1._)`${schemaCode} === null ? \"null\" : ${schemaCode}`);\n        gen.if(false); // optimizer should remove it from generated code\n\n        for (const schemaProp in parentSchema.selectCases) {\n          cxt.setParams({\n            schemaProp\n          });\n          gen.elseIf((0, codegen_1._)`\"\" + ${value} == ${schemaProp}`); // intentional ==, to match numbers and booleans\n\n          const schCxt = cxt.subschema({\n            keyword: \"selectCases\",\n            schemaProp\n          }, schValid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          gen.assign(valid, schValid);\n        }\n\n        gen.else();\n\n        if (parentSchema.selectDefault !== undefined) {\n          cxt.setParams({\n            schemaProp: undefined\n          });\n          const schCxt = cxt.subschema({\n            keyword: \"selectDefault\"\n          }, schValid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          gen.assign(valid, schValid);\n        }\n\n        gen.endIf();\n        cxt.pass(valid);\n      });\n    }\n\n  }, {\n    keyword: \"selectCases\",\n    dependencies: [\"select\"],\n    metaSchema: {\n      type: \"object\",\n      additionalProperties: metaSchema\n    }\n  }, {\n    keyword: \"selectDefault\",\n    dependencies: [\"select\", \"selectCases\"],\n    metaSchema\n  }];\n}\n\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"mappings":";;;;;;AACA;;AAEA;;AAIA,MAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE;AAAA,QAAC;AAACC,YAAM,EAAE;AAACC;AAAD;AAAT,KAAD;AAAA,WACPA,UAAU,GACN,kBAAG,sBAAsBA,UAAU,UAD7B,GAEN,kBAAG,kCAHA;AAAA,GAD2B;AAKpCD,QAAM,EAAE;AAAA,QAAC;AAACA,YAAM,EAAE;AAACC;AAAD;AAAT,KAAD;AAAA,WACNA,UAAU,GAAG,gBAAC,iBAAiBA,UAAU,GAA/B,GAAqC,gBAAC,wBAD1C;AAAA;AAL4B,CAAtC;;AASA,SAAwBC,MAAxB,CAA+BC,IAA/B,EAAuD;AACrD,QAAMC,UAAU,GAAG,2BAAcD,IAAd,CAAnB;AAEA,SAAO,CACL;AACEE,WAAO,EAAE,QADX;AAEEC,cAAU,EAAE,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgC,MAAhC,CAFd;AAGEC,SAAK,EAAE,IAHT;AAIET,SAJF;AAKEU,gBAAY,EAAE,CAAC,aAAD,CALhB;;AAMEC,QAAI,CAACC,GAAD,EAAgB;AAClB,YAAM;AAACC,WAAD;AAAMC,kBAAN;AAAkBC;AAAlB,UAAkCH,GAAxC;AACAA,SAAG,CAACI,UAAJ,CAAeC,aAAf,EAAoB,MAAK;AACvB,cAAMC,KAAK,GAAGL,GAAG,CAACM,GAAJ,CAAQ,OAAR,EAAiB,IAAjB,CAAd;AACA,cAAMC,QAAQ,GAAGP,GAAG,CAACQ,IAAJ,CAAS,QAAT,CAAjB;AACA,cAAMC,KAAK,GAAGT,GAAG,CAACU,KAAJ,CAAU,OAAV,EAAmB,gBAAC,GAAGT,UAAU,wBAAwBA,UAAU,EAAnE,CAAd;AACAD,WAAG,CAACW,EAAJ,CAAO,KAAP,EAJuB,CAIT;;AACd,aAAK,MAAMrB,UAAX,IAAyBY,YAAY,CAACU,WAAtC,EAAmD;AACjDb,aAAG,CAACc,SAAJ,CAAc;AAACvB;AAAD,WAAd;AACAU,aAAG,CAACc,MAAJ,CAAW,gBAAC,QAAQL,KAAK,OAAOnB,UAAU,EAA1C,EAFiD,CAEH;;AAC9C,gBAAMyB,MAAM,GAAGhB,GAAG,CAACiB,SAAJ,CAAc;AAACtB,mBAAO,EAAE,aAAV;AAAyBJ;AAAzB,WAAd,EAAoDiB,QAApD,CAAf;AACAR,aAAG,CAACkB,cAAJ,CAAmBF,MAAnB,EAA2BX,cAA3B;AACAJ,aAAG,CAACkB,MAAJ,CAAWb,KAAX,EAAkBE,QAAlB;AACD;;AACDP,WAAG,CAACmB,IAAJ;;AACA,YAAIjB,YAAY,CAACkB,aAAb,KAA+BC,SAAnC,EAA8C;AAC5CtB,aAAG,CAACc,SAAJ,CAAc;AAACvB,sBAAU,EAAE+B;AAAb,WAAd;AACA,gBAAMN,MAAM,GAAGhB,GAAG,CAACiB,SAAJ,CAAc;AAACtB,mBAAO,EAAE;AAAV,WAAd,EAA0Ca,QAA1C,CAAf;AACAR,aAAG,CAACkB,cAAJ,CAAmBF,MAAnB,EAA2BX,cAA3B;AACAJ,aAAG,CAACkB,MAAJ,CAAWb,KAAX,EAAkBE,QAAlB;AACD;;AACDP,WAAG,CAACsB,KAAJ;AACAvB,WAAG,CAACwB,IAAJ,CAASlB,KAAT;AACD,OArBD;AAsBD;;AA9BH,GADK,EAiCL;AACEX,WAAO,EAAE,aADX;AAEEG,gBAAY,EAAE,CAAC,QAAD,CAFhB;AAGEJ,cAAU,EAAE;AACV+B,UAAI,EAAE,QADI;AAEVC,0BAAoB,EAAEhC;AAFZ;AAHd,GAjCK,EAyCL;AACEC,WAAO,EAAE,eADX;AAEEG,gBAAY,EAAE,CAAC,QAAD,EAAW,aAAX,CAFhB;AAGEJ;AAHF,GAzCK,CAAP;AA+CD;;AAlDDiC;AAoDAC,MAAM,CAACD,OAAP,GAAiBnC,MAAjB","names":["error","message","params","schemaProp","getDef","opts","metaSchema","keyword","schemaType","$data","dependencies","code","cxt","gen","schemaCode","parentSchema","block$data","codegen_1","valid","let","schValid","name","value","const","if","selectCases","setParams","elseIf","schCxt","subschema","mergeEvaluated","assign","else","selectDefault","undefined","endIf","pass","type","additionalProperties","exports","module"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv-keywords/src/definitions/select.ts"],"sourcesContent":["import type {KeywordDefinition, KeywordErrorDefinition, KeywordCxt, ErrorObject} from \"ajv\"\nimport {_, str, nil, Name} from \"ajv/dist/compile/codegen\"\nimport type {DefinitionOptions} from \"./_types\"\nimport {metaSchemaRef} from \"./_util\"\n\nexport type SelectError = ErrorObject<\"select\", {failingCase?: string; failingDefault?: true}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {schemaProp}}) =>\n    schemaProp\n      ? str`should match case \"${schemaProp}\" schema`\n      : str`should match default case schema`,\n  params: ({params: {schemaProp}}) =>\n    schemaProp ? _`{failingCase: ${schemaProp}}` : _`{failingDefault: true}`,\n}\n\nexport default function getDef(opts?: DefinitionOptions): KeywordDefinition[] {\n  const metaSchema = metaSchemaRef(opts)\n\n  return [\n    {\n      keyword: \"select\",\n      schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n      $data: true,\n      error,\n      dependencies: [\"selectCases\"],\n      code(cxt: KeywordCxt) {\n        const {gen, schemaCode, parentSchema} = cxt\n        cxt.block$data(nil, () => {\n          const valid = gen.let(\"valid\", true)\n          const schValid = gen.name(\"_valid\")\n          const value = gen.const(\"value\", _`${schemaCode} === null ? \"null\" : ${schemaCode}`)\n          gen.if(false) // optimizer should remove it from generated code\n          for (const schemaProp in parentSchema.selectCases) {\n            cxt.setParams({schemaProp})\n            gen.elseIf(_`\"\" + ${value} == ${schemaProp}`) // intentional ==, to match numbers and booleans\n            const schCxt = cxt.subschema({keyword: \"selectCases\", schemaProp}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.else()\n          if (parentSchema.selectDefault !== undefined) {\n            cxt.setParams({schemaProp: undefined})\n            const schCxt = cxt.subschema({keyword: \"selectDefault\"}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.endIf()\n          cxt.pass(valid)\n        })\n      },\n    },\n    {\n      keyword: \"selectCases\",\n      dependencies: [\"select\"],\n      metaSchema: {\n        type: \"object\",\n        additionalProperties: metaSchema,\n      },\n    },\n    {\n      keyword: \"selectDefault\",\n      dependencies: [\"select\", \"selectCases\"],\n      metaSchema,\n    },\n  ]\n}\n\nmodule.exports = getDef\n"]},"metadata":{},"sourceType":"script"}