{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst code_1 = require(\"../code\");\n\nexports.error = {\n  message: _ref => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps\n      }\n    } = _ref;\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n    return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps,\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`;\n  } // TODO change to reference\n\n};\nconst def = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n\n  code(cxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt);\n    validatePropertyDeps(cxt, propDeps);\n    validateSchemaDeps(cxt, schDeps);\n  }\n\n};\n\nfunction splitDependencies(_ref3) {\n  let {\n    schema\n  } = _ref3;\n  const propertyDeps = {};\n  const schemaDeps = {};\n\n  for (const key in schema) {\n    if (key === \"__proto__\") continue;\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n    deps[key] = schema[key];\n  }\n\n  return [propertyDeps, schemaDeps];\n}\n\nfunction validatePropertyDeps(cxt) {\n  let propertyDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  if (Object.keys(propertyDeps).length === 0) return;\n  const missing = gen.let(\"missing\");\n\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop];\n    if (deps.length === 0) continue;\n    const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \")\n    });\n\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          (0, code_1.checkReportMissingProp)(cxt, depProp);\n        }\n      });\n    } else {\n      gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n      (0, code_1.reportMissingProp)(cxt, missing);\n      gen.else();\n    }\n  }\n}\n\nexports.validatePropertyDeps = validatePropertyDeps;\n\nfunction validateSchemaDeps(cxt) {\n  let schemaDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n\n  for (const prop in schemaDeps) {\n    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;\n    gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n      const schCxt = cxt.subschema({\n        keyword,\n        schemaProp: prop\n      }, valid);\n      cxt.mergeValidEvaluated(schCxt, valid);\n    }, () => gen.var(valid, true) // TODO var\n    );\n    cxt.ok(valid);\n  }\n}\n\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;","map":{"version":3,"mappings":"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","names":["exports","message","params","property","depsCount","deps","property_ies","missingProperty","def","keyword","type","schemaType","error","code","cxt","propDeps","schDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","schema","propertyDeps","schemaDeps","key","Array","isArray","gen","data","it","Object","keys","length","missing","let","prop","hasProperty","opts","ownProperties","setParams","join","allErrors","if","depProp","else","valid","name","schCxt","subschema","schemaProp","mergeValidEvaluated","var","ok"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}