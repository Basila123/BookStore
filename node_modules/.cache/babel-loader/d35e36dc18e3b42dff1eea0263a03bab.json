{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst util_2 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","alwaysValidPatterns","filter","p","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","codegen_1","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","forIn","key","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","util_2","Str","assign","break","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}