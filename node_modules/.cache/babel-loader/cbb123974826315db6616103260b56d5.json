{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\n\nconst codegen_1 = require(\"../compile/codegen\");\n\nconst util_1 = require(\"../compile/util\");\n\nconst names_1 = require(\"../compile/names\");\n\nconst util_2 = require(\"../compile/util\");\n\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: (0, codegen_1._)`${prop}`\n    }, true);\n    cxt.error();\n  });\n}\n\nexports.checkReportMissingProp = checkReportMissingProp;\n\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));\n}\n\nexports.checkMissingProp = checkMissingProp;\n\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\n\nexports.reportMissingProp = reportMissingProp;\n\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: (0, codegen_1._)`Object.prototype.hasOwnProperty`\n  });\n}\n\nexports.hasPropFunc = hasPropFunc;\n\nfunction isOwnProperty(gen, data, property) {\n  return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\n\nexports.isOwnProperty = isOwnProperty;\n\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n  return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\n\nexports.propertyInData = propertyInData;\n\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n  return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\n\nexports.noPropertyInData = noPropertyInData;\n\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\n\nexports.allSchemaProperties = allSchemaProperties;\n\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\n\nexports.schemaProperties = schemaProperties;\n\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n  const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n  return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;\n}\n\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._)`new RegExp`;\n\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  const {\n    regExp\n  } = opts.code;\n  const rx = regExp(pattern, u);\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: (0, codegen_1._)`${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`\n  });\n}\n\nexports.usePattern = usePattern;\n\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if((0, codegen_1.not)(valid), notValid);\n    });\n  }\n}\n\nexports.validateArray = validateArray;\n\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid); // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n\n    if (!merged) gen.if((0, codegen_1.not)(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\n\nexports.validateUnion = validateUnion;","map":{"version":3,"mappings":"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","names":["checkReportMissingProp","cxt","prop","gen","data","it","if","noPropertyInData","opts","ownProperties","setParams","missingProperty","error","exports","checkMissingProp","properties","missing","map","reportMissingProp","hasPropFunc","scopeValue","ref","Object","prototype","hasOwnProperty","code","isOwnProperty","property","propertyInData","cond","allSchemaProperties","schemaMap","keys","filter","p","schemaProperties","callValidateCode","func","context","passSchema","schemaCode","topSchemaRef","schemaPath","errorPath","dataAndSchema","valCxt","names_1","instancePath","parentData","parentDataProperty","rootData","dynamicRef","push","dynamicAnchors","args","object","codegen_1","newRegExp","usePattern","pattern","u","unicodeRegExp","regExp","rx","key","toString","validateArray","keyword","valid","name","allErrors","validArr","let","validateItems","assign","var","break","notValid","len","const","forRange","i","subschema","dataProp","dataPropType","util_1","Num","validateUnion","schema","Array","isArray","Error","alwaysValid","some","sch","unevaluated","schValid","block","forEach","_sch","schCxt","schemaProp","compositeRule","merged","mergeValidEvaluated","result","reset"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}