{"ast":null,"code":"\"use strict\";\n\nconst Range = require(\"./Range\");\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = { ...schema\n  };\n\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n\n  return [type].concat(hints);\n};\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n\n  const rangeFormat = range.format(logic);\n\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n\n  return hints;\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/schema-utils/dist/util/hints.js"],"names":["Range","require","module","exports","stringHints","schema","logic","hints","type","currentSchema","tmpLength","minLength","tmpFormat","formatMinimum","maxLength","formatMaximum","length","Math","max","push","pattern","JSON","stringify","format","formatExclusiveMinimum","formatExclusiveMaximum","concat","numberHints","range","minimum","left","exclusiveMinimum","maximum","right","exclusiveMaximum","rangeFormat","multipleOf"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst Range = require(\"./Range\");\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = { ...schema\n  };\n\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n\n  return [type].concat(hints);\n};\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\n\n\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n\n  const rangeFormat = range.format(logic);\n\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n\n  return hints;\n};"]},"metadata":{},"sourceType":"script"}