{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nfunction getSubschema(it, _ref) {\n  let {\n    keyword,\n    schemaProp,\n    schema,\n    schemaPath,\n    errSchemaPath,\n    topSchemaRef\n  } = _ref;\n\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`\n    };\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\n\nexports.getSubschema = getSubschema;\n\nfunction extendSubschemaData(subschema, it, _ref2) {\n  let {\n    dataProp,\n    dataPropType: dpType,\n    data,\n    dataTypes,\n    propertyName\n  } = _ref2;\n\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n\n  const {\n    gen\n  } = it;\n\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n    dataContextProps(nextData);\n    subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n    subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName; // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes;\n\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\n\nexports.extendSubschemaData = extendSubschemaData;\n\nfunction extendSubschemaMode(subschema, _ref3) {\n  let {\n    jtdDiscriminator,\n    jtdMetadata,\n    compositeRule,\n    createErrors,\n    allErrors\n  } = _ref3;\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\n\nexports.extendSubschemaMode = extendSubschemaMode;","map":{"version":3,"mappings":"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","names":["getSubschema","it","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","undefined","Error","sch","exports","extendSubschemaData","subschema","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","dataContextProps","jsPropertySyntax","parentDataProperty","codegen_1","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","extendSubschemaMode","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/compile/validate/subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"]},"metadata":{},"sourceType":"script"}