{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)`must be multiple of ${schemaCode}`;\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)`{multipleOf: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      it\n    } = cxt; // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n\n    const prec = it.opts.multipleOfPrecision;\n    const res = gen.let(\"res\");\n    const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;\n    cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AAQA,MAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE;AAAA,QAAC;AAACC;AAAD,KAAD;AAAA,WAAkB,kBAAG,uBAAuBA,UAAU,EAAtD;AAAA,GAD2B;AAEpCC,QAAM,EAAE;AAAA,QAAC;AAACD;AAAD,KAAD;AAAA,WAAkB,gBAAC,gBAAgBA,UAAU,GAA7C;AAAA;AAF4B,CAAtC;AAKA,MAAME,GAAG,GAA0B;AACjCC,SAAO,EAAE,YADwB;AAEjCC,MAAI,EAAE,QAF2B;AAGjCC,YAAU,EAAE,QAHqB;AAIjCC,OAAK,EAAE,IAJ0B;AAKjCR,OALiC;;AAMjCS,MAAI,CAACC,GAAD,EAAgB;AAClB,UAAM;AAACC,SAAD;AAAMC,UAAN;AAAYV,gBAAZ;AAAwBW;AAAxB,QAA8BH,GAApC,CADkB,CAElB;;AACA,UAAMI,IAAI,GAAGD,EAAE,CAACE,IAAH,CAAQC,mBAArB;AACA,UAAMC,GAAG,GAAGN,GAAG,CAACO,GAAJ,CAAQ,KAAR,CAAZ;AACA,UAAMC,OAAO,GAAGL,IAAI,GAChB,gBAAC,uBAAuBG,GAAG,OAAOA,GAAG,UAAUH,IAAI,EADnC,GAEhB,gBAAC,GAAGG,GAAG,iBAAiBA,GAAG,GAF/B;AAGAP,OAAG,CAACU,SAAJ,CAAc,gBAAC,IAAIlB,UAAU,cAAce,GAAG,MAAML,IAAI,IAAIV,UAAU,KAAKiB,OAAO,IAAlF;AACD;;AAfgC,CAAnC;AAkBAE,kBAAejB,GAAf","names":["error","message","schemaCode","params","def","keyword","type","schemaType","$data","code","cxt","gen","data","it","prec","opts","multipleOfPrecision","res","let","invalid","fail$data","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}