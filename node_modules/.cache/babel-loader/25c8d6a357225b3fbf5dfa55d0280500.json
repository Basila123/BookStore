{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastChild} XastChild\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').Visitor} Visitor\n */\n\nconst {\n  selectAll,\n  selectOne,\n  is\n} = require('css-select');\n\nconst xastAdaptor = require('./svgo/css-select-adapter.js');\n\nconst cssSelectOptions = {\n  xmlMode: true,\n  adapter: xastAdaptor\n};\n/**\n * @type {(node: XastNode, selector: string) => Array<XastChild>}\n */\n\nconst querySelectorAll = (node, selector) => {\n  return selectAll(selector, node, cssSelectOptions);\n};\n\nexports.querySelectorAll = querySelectorAll;\n/**\n * @type {(node: XastNode, selector: string) => null | XastChild}\n */\n\nconst querySelector = (node, selector) => {\n  return selectOne(selector, node, cssSelectOptions);\n};\n\nexports.querySelector = querySelector;\n/**\n * @type {(node: XastChild, selector: string) => boolean}\n */\n\nconst matches = (node, selector) => {\n  return is(node, selector, cssSelectOptions);\n};\n\nexports.matches = matches;\n/**\n * @type {(node: XastChild, name: string) => null | XastChild}\n */\n\nconst closestByName = (node, name) => {\n  let currentNode = node;\n\n  while (currentNode) {\n    if (currentNode.type === 'element' && currentNode.name === name) {\n      return currentNode;\n    } // @ts-ignore parentNode is hidden from public usage\n\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n};\n\nexports.closestByName = closestByName;\nconst visitSkip = Symbol();\nexports.visitSkip = visitSkip;\n/**\n * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}\n */\n\nconst visit = (node, visitor, parentNode) => {\n  const callbacks = visitor[node.type];\n\n  if (callbacks && callbacks.enter) {\n    // @ts-ignore hard to infer\n    const symbol = callbacks.enter(node, parentNode);\n\n    if (symbol === visitSkip) {\n      return;\n    }\n  } // visit root children\n\n\n  if (node.type === 'root') {\n    // copy children array to not loose cursor when children is spliced\n    for (const child of node.children) {\n      visit(child, visitor, node);\n    }\n  } // visit element children if still attached to parent\n\n\n  if (node.type === 'element') {\n    if (parentNode.children.includes(node)) {\n      for (const child of node.children) {\n        visit(child, visitor, node);\n      }\n    }\n  }\n\n  if (callbacks && callbacks.exit) {\n    // @ts-ignore hard to infer\n    callbacks.exit(node, parentNode);\n  }\n};\n\nexports.visit = visit;\n/**\n * @type {(node: XastChild, parentNode: XastParent) => void}\n */\n\nconst detachNodeFromParent = (node, parentNode) => {\n  // avoid splice to not break for loops\n  parentNode.children = parentNode.children.filter(child => child !== node);\n};\n\nexports.detachNodeFromParent = detachNodeFromParent;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/lib/xast.js"],"names":["selectAll","selectOne","is","require","xastAdaptor","cssSelectOptions","xmlMode","adapter","querySelectorAll","node","selector","exports","querySelector","matches","closestByName","name","currentNode","type","parentNode","visitSkip","Symbol","visit","visitor","callbacks","enter","symbol","child","children","includes","exit","detachNodeFromParent","filter"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastChild} XastChild\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').Visitor} Visitor\n */\n\nconst { selectAll, selectOne, is } = require('css-select');\nconst xastAdaptor = require('./svgo/css-select-adapter.js');\n\nconst cssSelectOptions = {\n  xmlMode: true,\n  adapter: xastAdaptor,\n};\n\n/**\n * @type {(node: XastNode, selector: string) => Array<XastChild>}\n */\nconst querySelectorAll = (node, selector) => {\n  return selectAll(selector, node, cssSelectOptions);\n};\nexports.querySelectorAll = querySelectorAll;\n\n/**\n * @type {(node: XastNode, selector: string) => null | XastChild}\n */\nconst querySelector = (node, selector) => {\n  return selectOne(selector, node, cssSelectOptions);\n};\nexports.querySelector = querySelector;\n\n/**\n * @type {(node: XastChild, selector: string) => boolean}\n */\nconst matches = (node, selector) => {\n  return is(node, selector, cssSelectOptions);\n};\nexports.matches = matches;\n\n/**\n * @type {(node: XastChild, name: string) => null | XastChild}\n */\nconst closestByName = (node, name) => {\n  let currentNode = node;\n  while (currentNode) {\n    if (currentNode.type === 'element' && currentNode.name === name) {\n      return currentNode;\n    }\n    // @ts-ignore parentNode is hidden from public usage\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n};\nexports.closestByName = closestByName;\n\nconst visitSkip = Symbol();\nexports.visitSkip = visitSkip;\n\n/**\n * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}\n */\nconst visit = (node, visitor, parentNode) => {\n  const callbacks = visitor[node.type];\n  if (callbacks && callbacks.enter) {\n    // @ts-ignore hard to infer\n    const symbol = callbacks.enter(node, parentNode);\n    if (symbol === visitSkip) {\n      return;\n    }\n  }\n  // visit root children\n  if (node.type === 'root') {\n    // copy children array to not loose cursor when children is spliced\n    for (const child of node.children) {\n      visit(child, visitor, node);\n    }\n  }\n  // visit element children if still attached to parent\n  if (node.type === 'element') {\n    if (parentNode.children.includes(node)) {\n      for (const child of node.children) {\n        visit(child, visitor, node);\n      }\n    }\n  }\n  if (callbacks && callbacks.exit) {\n    // @ts-ignore hard to infer\n    callbacks.exit(node, parentNode);\n  }\n};\nexports.visit = visit;\n\n/**\n * @type {(node: XastChild, parentNode: XastParent) => void}\n */\nconst detachNodeFromParent = (node, parentNode) => {\n  // avoid splice to not break for loops\n  parentNode.children = parentNode.children.filter((child) => child !== node);\n};\nexports.detachNodeFromParent = detachNodeFromParent;\n"]},"metadata":{},"sourceType":"script"}