{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`;\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)`${len} >= ${min}`;\n      if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n\n    it.items = true;\n    const valid = gen.name(\"valid\");\n\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n\n    cxt.result(valid, () => cxt.reset());\n\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)`${count}++`);\n\n      if (max === undefined) {\n        gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","min","max","undefined","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","setParams","fail","cond","pass","items","valid","name","validateItems","if","break","let","validateItemsWithCount","result","reset","schValid","count","checkLimits","_valid","block","forRange","i","subschema","dataProp","dataPropType","util_1","Num","compositeRule","assign","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/vocabularies/applicator/contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}