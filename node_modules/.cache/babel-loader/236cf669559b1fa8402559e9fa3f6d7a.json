{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\n\nconst ajv_1 = require(\"ajv\");\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst ops = codegen_1.operators;\nconst KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nconst error = {\n  message: _ref => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref;\n    return codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`;\n  },\n  params: _ref2 => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref2;\n    return codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`;\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      keyword,\n      it\n    } = cxt;\n    const {\n      opts,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fmt = gen.const(\"fmt\", codegen_1._`${fmts}[${fCxt.schemaCode}]`);\n      cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != \"object\"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n    }\n\n    function validateFormat() {\n      const format = fCxt.schema;\n      const fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n      }\n\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n\n    function compareCode(fmt) {\n      return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n    }\n  },\n\n  dependencies: [\"format\"]\n};\n\nconst formatLimitPlugin = ajv => {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\n\nexports.default = formatLimitPlugin;","map":{"version":3,"mappings":"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","names":["ops","codegen_1","KWDs","formatMaximum","okStr","ok","LTE","fail","GT","formatMinimum","GTE","LT","formatExclusiveMaximum","formatExclusiveMinimum","error","message","keyword","schemaCode","params","exports","Object","keys","type","schemaType","$data","code","cxt","gen","data","it","opts","self","validateFormats","fCxt","ajv_1","RULES","all","format","definition","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fmt","const","fail$data","compareCode","schema","fmtDef","RegExp","compare","Error","key","undefined","dependencies","formatLimitPlugin","ajv","addKeyword"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/src/limit.ts"],"sourcesContent":["import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n"]},"metadata":{},"sourceType":"script"}