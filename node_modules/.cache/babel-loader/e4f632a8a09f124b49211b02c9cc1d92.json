{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\n\nconst code_1 = require(\"./code\");\n\nconst scope_1 = require(\"./scope\");\n\nvar code_2 = require(\"./code\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return code_2._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return code_2.str;\n  }\n});\nObject.defineProperty(exports, \"strConcat\", {\n  enumerable: true,\n  get: function () {\n    return code_2.strConcat;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return code_2.nil;\n  }\n});\nObject.defineProperty(exports, \"getProperty\", {\n  enumerable: true,\n  get: function () {\n    return code_2.getProperty;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return code_2.stringify;\n  }\n});\nObject.defineProperty(exports, \"regexpCode\", {\n  enumerable: true,\n  get: function () {\n    return code_2.regexpCode;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return code_2.Name;\n  }\n});\n\nvar scope_2 = require(\"./scope\");\n\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.Scope;\n  }\n});\nObject.defineProperty(exports, \"ValueScope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScope;\n  }\n});\nObject.defineProperty(exports, \"ValueScopeName\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScopeName;\n  }\n});\nObject.defineProperty(exports, \"varKinds\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.varKinds;\n  }\n});\nexports.operators = {\n  GT: new code_1._Code(\">\"),\n  GTE: new code_1._Code(\">=\"),\n  LT: new code_1._Code(\"<\"),\n  LTE: new code_1._Code(\"<=\"),\n  EQ: new code_1._Code(\"===\"),\n  NEQ: new code_1._Code(\"!==\"),\n  NOT: new code_1._Code(\"!\"),\n  OR: new code_1._Code(\"||\"),\n  AND: new code_1._Code(\"&&\"),\n  ADD: new code_1._Code(\"+\")\n};\n\nclass Node {\n  optimizeNodes() {\n    return this;\n  }\n\n  optimizeNames(_names, _constants) {\n    return this;\n  }\n\n}\n\nclass Def extends Node {\n  constructor(varKind, name, rhs) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.rhs = rhs;\n  }\n\n  render(_ref) {\n    let {\n      es5,\n      _n\n    } = _ref;\n    const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n    return `${varKind} ${this.name}${rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (!names[this.name.str]) return;\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n  }\n\n}\n\nclass Assign extends Node {\n  constructor(lhs, rhs, sideEffects) {\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.sideEffects = sideEffects;\n  }\n\n  render(_ref2) {\n    let {\n      _n\n    } = _ref2;\n    return `${this.lhs} = ${this.rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;\n    this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names\n    };\n    return addExprNames(names, this.rhs);\n  }\n\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs, op, rhs, sideEffects) {\n    super(lhs, rhs, sideEffects);\n    this.op = op;\n  }\n\n  render(_ref3) {\n    let {\n      _n\n    } = _ref3;\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n  }\n\n}\n\nclass Label extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref4) {\n    let {\n      _n\n    } = _ref4;\n    return `${this.label}:` + _n;\n  }\n\n}\n\nclass Break extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref5) {\n    let {\n      _n\n    } = _ref5;\n    const label = this.label ? ` ${this.label}` : \"\";\n    return `break${label};` + _n;\n  }\n\n}\n\nclass Throw extends Node {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(_ref6) {\n    let {\n      _n\n    } = _ref6;\n    return `throw ${this.error};` + _n;\n  }\n\n  get names() {\n    return this.error.names;\n  }\n\n}\n\nclass AnyCode extends Node {\n  constructor(code) {\n    super();\n    this.code = code;\n  }\n\n  render(_ref7) {\n    let {\n      _n\n    } = _ref7;\n    return `${this.code};` + _n;\n  }\n\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    this.code = optimizeExpr(this.code, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n  }\n\n}\n\nclass ParentNode extends Node {\n  constructor() {\n    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.nodes = nodes;\n  }\n\n  render(opts) {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n  }\n\n  optimizeNodes() {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      const n = nodes[i].optimizeNodes();\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n);else if (n) nodes[i] = n;else nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i];\n      if (n.optimizeNames(names, constants)) continue;\n      subtractNames(names, n.names);\n      nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  get names() {\n    return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n  }\n\n}\n\nclass BlockNode extends ParentNode {\n  render(opts) {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n  }\n\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {}\n\nElse.kind = \"else\";\n\nclass If extends BlockNode {\n  constructor(condition, nodes) {\n    super(nodes);\n    this.condition = condition;\n  }\n\n  render(opts) {\n    let code = `if(${this.condition})` + super.render(opts);\n    if (this.else) code += \"else \" + this.else.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    super.optimizeNodes();\n    const cond = this.condition;\n    if (cond === true) return this.nodes; // else is ignored here\n\n    let e = this.else;\n\n    if (e) {\n      const ns = e.optimizeNodes();\n      e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n    }\n\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes;\n      if (this.nodes.length) return this;\n      return new If(not(cond), e instanceof If ? [e] : e.nodes);\n    }\n\n    if (cond === false || !this.nodes.length) return undefined;\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a;\n\n    this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    if (!(super.optimizeNames(names, constants) || this.else)) return;\n    this.condition = optimizeExpr(this.condition, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    addExprNames(names, this.condition);\n    if (this.else) addNames(names, this.else.names);\n    return names;\n  }\n\n}\n\nIf.kind = \"if\";\n\nclass For extends BlockNode {}\n\nFor.kind = \"for\";\n\nclass ForLoop extends For {\n  constructor(iteration) {\n    super();\n    this.iteration = iteration;\n  }\n\n  render(opts) {\n    return `for(${this.iteration})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iteration = optimizeExpr(this.iteration, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iteration.names);\n  }\n\n}\n\nclass ForRange extends For {\n  constructor(varKind, name, from, to) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.from = from;\n    this.to = to;\n  }\n\n  render(opts) {\n    const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n    const {\n      name,\n      from,\n      to\n    } = this;\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n  }\n\n  get names() {\n    const names = addExprNames(super.names, this.from);\n    return addExprNames(names, this.to);\n  }\n\n}\n\nclass ForIter extends For {\n  constructor(loop, varKind, name, iterable) {\n    super();\n    this.loop = loop;\n    this.varKind = varKind;\n    this.name = name;\n    this.iterable = iterable;\n  }\n\n  render(opts) {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iterable = optimizeExpr(this.iterable, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iterable.names);\n  }\n\n}\n\nclass Func extends BlockNode {\n  constructor(name, args, async) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.async = async;\n  }\n\n  render(opts) {\n    const _async = this.async ? \"async \" : \"\";\n\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n  }\n\n}\n\nFunc.kind = \"func\";\n\nclass Return extends ParentNode {\n  render(opts) {\n    return \"return \" + super.render(opts);\n  }\n\n}\n\nReturn.kind = \"return\";\n\nclass Try extends BlockNode {\n  render(opts) {\n    let code = \"try\" + super.render(opts);\n    if (this.catch) code += this.catch.render(opts);\n    if (this.finally) code += this.finally.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    var _a, _b;\n\n    super.optimizeNodes();\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a, _b;\n\n    super.optimizeNames(names, constants);\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    if (this.catch) addNames(names, this.catch.names);\n    if (this.finally) addNames(names, this.finally.names);\n    return names;\n  }\n\n}\n\nclass Catch extends BlockNode {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(opts) {\n    return `catch(${this.error})` + super.render(opts);\n  }\n\n}\n\nCatch.kind = \"catch\";\n\nclass Finally extends BlockNode {\n  render(opts) {\n    return \"finally\" + super.render(opts);\n  }\n\n}\n\nFinally.kind = \"finally\";\n\nclass CodeGen {\n  constructor(extScope) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = { ...opts,\n      _n: opts.lines ? \"\\n\" : \"\"\n    };\n    this._extScope = extScope;\n    this._scope = new scope_1.Scope({\n      parent: extScope\n    });\n    this._nodes = [new Root()];\n  }\n\n  toString() {\n    return this._root.render(this.opts);\n  } // returns unique name in the internal scope\n\n\n  name(prefix) {\n    return this._scope.name(prefix);\n  } // reserves unique name in the external scope\n\n\n  scopeName(prefix) {\n    return this._extScope.name(prefix);\n  } // reserves unique name in the external scope and assigns value to it\n\n\n  scopeValue(prefixOrName, value) {\n    const name = this._extScope.value(prefixOrName, value);\n\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n    vs.add(name);\n    return name;\n  }\n\n  getScopeValue(prefix, keyOrRef) {\n    return this._extScope.getValue(prefix, keyOrRef);\n  } // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n\n\n  scopeRefs(scopeName) {\n    return this._extScope.scopeRefs(scopeName, this._values);\n  }\n\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n\n  _def(varKind, nameOrPrefix, rhs, constant) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n\n    this._leafNode(new Def(varKind, name, rhs));\n\n    return name;\n  } // `const` declaration (`var` in es5 mode)\n\n\n  const(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n  } // `let` declaration with optional assignment (`var` in es5 mode)\n\n\n  let(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n  } // `var` declaration with optional assignment\n\n\n  var(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n  } // assignment code\n\n\n  assign(lhs, rhs, sideEffects) {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects));\n  } // `+=` code\n\n\n  add(lhs, rhs) {\n    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n  } // appends passed SafeExpr to code or executes Block\n\n\n  code(c) {\n    if (typeof c == \"function\") c();else if (c !== code_1.nil) this._leafNode(new AnyCode(c));\n    return this;\n  } // returns code for object literal for the passed argument list of key-value pairs\n\n\n  object() {\n    const code = [\"{\"];\n\n    for (var _len = arguments.length, keyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n      keyValues[_key] = arguments[_key];\n    }\n\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\");\n      code.push(key);\n\n      if (key !== value || this.opts.es5) {\n        code.push(\":\");\n        (0, code_1.addCodeArg)(code, value);\n      }\n    }\n\n    code.push(\"}\");\n    return new code_1._Code(code);\n  } // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n\n\n  if(condition, thenBody, elseBody) {\n    this._blockNode(new If(condition));\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf();\n    } else if (thenBody) {\n      this.code(thenBody).endIf();\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body');\n    }\n\n    return this;\n  } // `else if` clause - invalid without `if` or after `else` clauses\n\n\n  elseIf(condition) {\n    return this._elseNode(new If(condition));\n  } // `else` clause - only valid after `if` or `else if` clauses\n\n\n  else() {\n    return this._elseNode(new Else());\n  } // end `if` statement (needed if gen.if was used only with condition)\n\n\n  endIf() {\n    return this._endBlockNode(If, Else);\n  }\n\n  _for(node, forBody) {\n    this._blockNode(node);\n\n    if (forBody) this.code(forBody).endFor();\n    return this;\n  } // a generic `for` clause (or statement if `forBody` is passed)\n\n\n  for(iteration, forBody) {\n    return this._for(new ForLoop(iteration), forBody);\n  } // `for` statement for a range of values\n\n\n  forRange(nameOrPrefix, from, to, forBody) {\n    let varKind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n  } // `for-of` statement (in es5 mode replace with a normal for loop)\n\n\n  forOf(nameOrPrefix, iterable, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : scope_1.varKinds.const;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (this.opts.es5) {\n      const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n      return this.forRange(\"_i\", 0, (0, code_1._)`${arr}.length`, i => {\n        this.var(name, (0, code_1._)`${arr}[${i}]`);\n        forBody(name);\n      });\n    }\n\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n  } // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n\n\n  forIn(nameOrPrefix, obj, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;\n\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);\n    }\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n  } // end `for` loop\n\n\n  endFor() {\n    return this._endBlockNode(For);\n  } // `label` statement\n\n\n  label(label) {\n    return this._leafNode(new Label(label));\n  } // `break` statement\n\n\n  break(label) {\n    return this._leafNode(new Break(label));\n  } // `return` statement\n\n\n  return(value) {\n    const node = new Return();\n\n    this._blockNode(node);\n\n    this.code(value);\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(Return);\n  } // `try` statement\n\n\n  try(tryBody, catchCode, finallyCode) {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const node = new Try();\n\n    this._blockNode(node);\n\n    this.code(tryBody);\n\n    if (catchCode) {\n      const error = this.name(\"e\");\n      this._currNode = node.catch = new Catch(error);\n      catchCode(error);\n    }\n\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally();\n      this.code(finallyCode);\n    }\n\n    return this._endBlockNode(Catch, Finally);\n  } // `throw` statement\n\n\n  throw(error) {\n    return this._leafNode(new Throw(error));\n  } // start self-balancing block\n\n\n  block(body, nodeCount) {\n    this._blockStarts.push(this._nodes.length);\n\n    if (body) this.code(body).endBlock(nodeCount);\n    return this;\n  } // end the current self-balancing block\n\n\n  endBlock(nodeCount) {\n    const len = this._blockStarts.pop();\n\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n    const toClose = this._nodes.length - len;\n\n    if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n    }\n\n    this._nodes.length = len;\n    return this;\n  } // `function` heading (or definition if funcBody is passed)\n\n\n  func(name) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : code_1.nil;\n    let async = arguments.length > 2 ? arguments[2] : undefined;\n    let funcBody = arguments.length > 3 ? arguments[3] : undefined;\n\n    this._blockNode(new Func(name, args, async));\n\n    if (funcBody) this.code(funcBody).endFunc();\n    return this;\n  } // end function definition\n\n\n  endFunc() {\n    return this._endBlockNode(Func);\n  }\n\n  optimize() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    while (n-- > 0) {\n      this._root.optimizeNodes();\n\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n\n  _leafNode(node) {\n    this._currNode.nodes.push(node);\n\n    return this;\n  }\n\n  _blockNode(node) {\n    this._currNode.nodes.push(node);\n\n    this._nodes.push(node);\n  }\n\n  _endBlockNode(N1, N2) {\n    const n = this._currNode;\n\n    if (n instanceof N1 || N2 && n instanceof N2) {\n      this._nodes.pop();\n\n      return this;\n    }\n\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n  }\n\n  _elseNode(node) {\n    const n = this._currNode;\n\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"');\n    }\n\n    this._currNode = n.else = node;\n    return this;\n  }\n\n  get _root() {\n    return this._nodes[0];\n  }\n\n  get _currNode() {\n    const ns = this._nodes;\n    return ns[ns.length - 1];\n  }\n\n  set _currNode(node) {\n    const ns = this._nodes;\n    ns[ns.length - 1] = node;\n  }\n\n}\n\nexports.CodeGen = CodeGen;\n\nfunction addNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);\n\n  return names;\n}\n\nfunction addExprNames(names, from) {\n  return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\n\nfunction optimizeExpr(expr, names, constants) {\n  if (expr instanceof code_1.Name) return replaceName(expr);\n  if (!canOptimize(expr)) return expr;\n  return new code_1._Code(expr._items.reduce((items, c) => {\n    if (c instanceof code_1.Name) c = replaceName(c);\n    if (c instanceof code_1._Code) items.push(...c._items);else items.push(c);\n    return items;\n  }, []));\n\n  function replaceName(n) {\n    const c = constants[n.str];\n    if (c === undefined || names[n.str] !== 1) return n;\n    delete names[n.str];\n    return c;\n  }\n\n  function canOptimize(e) {\n    return e instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n  }\n}\n\nfunction subtractNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);\n}\n\nfunction not(x) {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)`!${par(x)}`;\n}\n\nexports.not = not;\nconst andCode = mappend(exports.operators.AND); // boolean AND (&&) expression with the passed arguments\n\nfunction and() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return args.reduce(andCode);\n}\n\nexports.and = and;\nconst orCode = mappend(exports.operators.OR); // boolean OR (||) expression with the passed arguments\n\nfunction or() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return args.reduce(orCode);\n}\n\nexports.or = or;\n\nfunction mappend(op) {\n  return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;\n}\n\nfunction par(x) {\n  return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;\n}","map":{"version":3,"mappings":";;;;;;;AACA;;AACA;;AAEA;;AAAQA;AAAAC;AAAAC;AAAA;AAAC;AAAD;AAAGF;AAAAC;AAAAC;AAAA;AAAG;AAAH;AAAKF;AAAAC;AAAAC;AAAA;AAAS;AAAT;AAAWF;AAAAC;AAAAC;AAAA;AAAG;AAAH;AAAKF;AAAAC;AAAAC;AAAA;AAAW;AAAX;AAAaF;AAAAC;AAAAC;AAAA;AAAS;AAAT;AAAWF;AAAAC;AAAAC;AAAA;AAAU;AAAV;AAAYF;AAAAC;AAAAC;AAAA;AAAI;AAAJ;;AACpE;;AAAQF;AAAAC;AAAAC;AAAA;AAAK;AAAL;AAAmBF;AAAAC;AAAAC;AAAA;AAAU;AAAV;AAAYF;AAAAC;AAAAC;AAAA;AAAc;AAAd;AAAgCF;AAAAC;AAAAC;AAAA;AAAQ;AAAR;AAQ1DC,oBAAY;AACvBC,IAAE,EAAE,IAAIC,YAAJ,CAAU,GAAV,CADmB;AAEvBC,KAAG,EAAE,IAAID,YAAJ,CAAU,IAAV,CAFkB;AAGvBE,IAAE,EAAE,IAAIF,YAAJ,CAAU,GAAV,CAHmB;AAIvBG,KAAG,EAAE,IAAIH,YAAJ,CAAU,IAAV,CAJkB;AAKvBI,IAAE,EAAE,IAAIJ,YAAJ,CAAU,KAAV,CALmB;AAMvBK,KAAG,EAAE,IAAIL,YAAJ,CAAU,KAAV,CANkB;AAOvBM,KAAG,EAAE,IAAIN,YAAJ,CAAU,GAAV,CAPkB;AAQvBO,IAAE,EAAE,IAAIP,YAAJ,CAAU,IAAV,CARmB;AASvBQ,KAAG,EAAE,IAAIR,YAAJ,CAAU,IAAV,CATkB;AAUvBS,KAAG,EAAE,IAAIT,YAAJ,CAAU,GAAV;AAVkB,CAAZ;;AAab,MAAeU,IAAf,CAAmB;AAGjBC,eAAa;AACX,WAAO,IAAP;AACD;;AAEDC,eAAa,CAACC,MAAD,EAAoBC,UAApB,EAAyC;AACpD,WAAO,IAAP;AACD;;AATgB;;AAgBnB,MAAMC,GAAN,SAAkBL,IAAlB,CAAsB;AACpBM,cAA6BC,OAA7B,EAA6DC,IAA7D,EAAiFC,GAAjF,EAA+F;AAC7F;AAD2B;AAAgC;AAAoB;AAEhF;;AAEDC,QAAM,OAAqB;AAAA,QAApB;AAACC,SAAD;AAAMC;AAAN,KAAoB;AACzB,UAAML,OAAO,GAAGI,GAAG,GAAGE,iBAASC,GAAZ,GAAkB,KAAKP,OAA1C;AACA,UAAME,GAAG,GAAG,KAAKA,GAAL,KAAaM,SAAb,GAAyB,EAAzB,GAA8B,MAAM,KAAKN,GAAG,EAAxD;AACA,WAAO,GAAGF,OAAO,IAAI,KAAKC,IAAI,GAAGC,GAAG,GAA7B,GAAmCG,EAA1C;AACD;;AAEDV,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,QAAI,CAACD,KAAK,CAAC,KAAKR,IAAL,CAAUU,GAAX,CAAV,EAA2B;AAC3B,QAAI,KAAKT,GAAT,EAAc,KAAKA,GAAL,GAAWU,YAAY,CAAC,KAAKV,GAAN,EAAWO,KAAX,EAAkBC,SAAlB,CAAvB;AACd,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,WAAO,KAAKP,GAAL,YAAoBnB,kBAApB,GAAkC,KAAKmB,GAAL,CAASO,KAA3C,GAAmD,EAA1D;AACD;;AAnBmB;;AAsBtB,MAAMI,MAAN,SAAqBpB,IAArB,CAAyB;AACvBM,cAAqBe,GAArB,EAAuCZ,GAAvC,EAAuEa,WAAvE,EAA4F;AAC1F;AADmB;AAAkB;AAAgC;AAEtE;;AAEDZ,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,WAAO,GAAG,KAAKS,GAAG,MAAM,KAAKZ,GAAG,GAAzB,GAA+BG,EAAtC;AACD;;AAEDV,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,QAAI,KAAKI,GAAL,YAAoB/B,WAApB,IAA4B,CAAC0B,KAAK,CAAC,KAAKK,GAAL,CAASH,GAAV,CAAlC,IAAoD,CAAC,KAAKI,WAA9D,EAA2E;AAC3E,SAAKb,GAAL,GAAWU,YAAY,CAAC,KAAKV,GAAN,EAAWO,KAAX,EAAkBC,SAAlB,CAAvB;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,UAAMA,KAAK,GAAG,KAAKK,GAAL,YAAoB/B,WAApB,GAA2B,EAA3B,GAAgC,EAAC,GAAG,KAAK+B,GAAL,CAASL;AAAb,KAA9C;AACA,WAAOO,YAAY,CAACP,KAAD,EAAQ,KAAKP,GAAb,CAAnB;AACD;;AAlBsB;;AAqBzB,MAAMe,QAAN,SAAuBJ,MAAvB,CAA6B;AAC3Bd,cAAYe,GAAZ,EAAwCI,EAAxC,EAAkDhB,GAAlD,EAAiEa,WAAjE,EAAsF;AACpF,UAAMD,GAAN,EAAWZ,GAAX,EAAgBa,WAAhB;AADsC;AAEvC;;AAEDZ,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,WAAO,GAAG,KAAKS,GAAG,IAAI,KAAKI,EAAE,KAAK,KAAKhB,GAAG,GAAnC,GAAyCG,EAAhD;AACD;;AAP0B;;AAU7B,MAAMc,KAAN,SAAoB1B,IAApB,CAAwB;AAEtBM,cAAqBqB,KAArB,EAAgC;AAC9B;AADmB;AADZ,iBAAmB,EAAnB;AAGR;;AAEDjB,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,WAAO,GAAG,KAAKe,KAAK,GAAb,GAAmBf,EAA1B;AACD;;AARqB;;AAWxB,MAAMgB,KAAN,SAAoB5B,IAApB,CAAwB;AAEtBM,cAAqBqB,KAArB,EAAiC;AAC/B;AADmB;AADZ,iBAAmB,EAAnB;AAGR;;AAEDjB,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,UAAMe,KAAK,GAAG,KAAKA,KAAL,GAAa,IAAI,KAAKA,KAAK,EAA3B,GAAgC,EAA9C;AACA,WAAO,QAAQA,KAAK,GAAb,GAAmBf,EAA1B;AACD;;AATqB;;AAYxB,MAAMiB,KAAN,SAAoB7B,IAApB,CAAwB;AACtBM,cAAqBwB,KAArB,EAAgC;AAC9B;AADmB;AAEpB;;AAEDpB,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,WAAO,SAAS,KAAKkB,KAAK,GAAnB,GAAyBlB,EAAhC;AACD;;AAEQ,MAALI,KAAK;AACP,WAAO,KAAKc,KAAL,CAAWd,KAAlB;AACD;;AAXqB;;AAcxB,MAAMe,OAAN,SAAsB/B,IAAtB,CAA0B;AACxBM,cAAoB0B,IAApB,EAAkC;AAChC;AADkB;AAEnB;;AAEDtB,QAAM,QAAgB;AAAA,QAAf;AAACE;AAAD,KAAe;AACpB,WAAO,GAAG,KAAKoB,IAAI,GAAZ,GAAkBpB,EAAzB;AACD;;AAEDX,eAAa;AACX,WAAO,GAAG,KAAK+B,IAAI,EAAZ,GAAiB,IAAjB,GAAwBjB,SAA/B;AACD;;AAEDb,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,SAAKe,IAAL,GAAYb,YAAY,CAAC,KAAKa,IAAN,EAAYhB,KAAZ,EAAmBC,SAAnB,CAAxB;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,WAAO,KAAKgB,IAAL,YAAqB1C,kBAArB,GAAmC,KAAK0C,IAAL,CAAUhB,KAA7C,GAAqD,EAA5D;AACD;;AApBuB;;AAuB1B,MAAeiB,UAAf,SAAkCjC,IAAlC,CAAsC;AACpCM,gBAA4C;AAAA,QAAvB4B,KAAuB,uEAAF,EAAE;AAC1C;AADmB;AAEpB;;AAEDxB,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,KAAKD,KAAL,CAAWE,MAAX,CAAkB,CAACJ,IAAD,EAAOK,CAAP,KAAaL,IAAI,GAAGK,CAAC,CAAC3B,MAAF,CAASyB,IAAT,CAAtC,EAAsD,EAAtD,CAAP;AACD;;AAEDlC,eAAa;AACX,UAAM;AAACiC;AAAD,QAAU,IAAhB;AACA,QAAII,CAAC,GAAGJ,KAAK,CAACK,MAAd;;AACA,WAAOD,CAAC,EAAR,EAAY;AACV,YAAMD,CAAC,GAAGH,KAAK,CAACI,CAAD,CAAL,CAASrC,aAAT,EAAV;AACA,UAAIuC,KAAK,CAACC,OAAN,CAAcJ,CAAd,CAAJ,EAAsBH,KAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB,EAAmB,GAAGD,CAAtB,EAAtB,KACK,IAAIA,CAAJ,EAAOH,KAAK,CAACI,CAAD,CAAL,GAAWD,CAAX,CAAP,KACAH,KAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB;AACN;;AACD,WAAOJ,KAAK,CAACK,MAAN,GAAe,CAAf,GAAmB,IAAnB,GAA0BxB,SAAjC;AACD;;AAEDb,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,UAAM;AAACiB;AAAD,QAAU,IAAhB;AACA,QAAII,CAAC,GAAGJ,KAAK,CAACK,MAAd;;AACA,WAAOD,CAAC,EAAR,EAAY;AACV;AACA,YAAMD,CAAC,GAAGH,KAAK,CAACI,CAAD,CAAf;AACA,UAAID,CAAC,CAACnC,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAJ,EAAuC;AACvC0B,mBAAa,CAAC3B,KAAD,EAAQqB,CAAC,CAACrB,KAAV,CAAb;AACAkB,WAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB;AACD;;AACD,WAAOJ,KAAK,CAACK,MAAN,GAAe,CAAf,GAAmB,IAAnB,GAA0BxB,SAAjC;AACD;;AAEQ,MAALC,KAAK;AACP,WAAO,KAAKkB,KAAL,CAAWE,MAAX,CAAkB,CAACpB,KAAD,EAAmBqB,CAAnB,KAAyBO,QAAQ,CAAC5B,KAAD,EAAQqB,CAAC,CAACrB,KAAV,CAAnD,EAAqE,EAArE,CAAP;AACD;;AApCmC;;AA2CtC,MAAe6B,SAAf,SAAiCZ,UAAjC,CAA2C;AACzCvB,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,MAAMA,IAAI,CAACvB,EAAX,GAAgB,MAAMF,MAAN,CAAayB,IAAb,CAAhB,GAAqC,GAArC,GAA2CA,IAAI,CAACvB,EAAvD;AACD;;AAHwC;;AAM3C,MAAMkC,IAAN,SAAmBb,UAAnB,CAA6B;;AAE7B,MAAMc,IAAN,SAAmBF,SAAnB,CAA4B;;AACVE,YAAO,MAAP;;AAGlB,MAAMC,EAAN,SAAiBH,SAAjB,CAA0B;AAGxBvC,cAAoB2C,SAApB,EAA+Cf,KAA/C,EAAkE;AAChE,UAAMA,KAAN;AADkB;AAEnB;;AAEDxB,QAAM,CAACyB,IAAD,EAAgB;AACpB,QAAIH,IAAI,GAAG,MAAM,KAAKiB,SAAS,GAApB,GAA0B,MAAMvC,MAAN,CAAayB,IAAb,CAArC;AACA,QAAI,KAAKe,IAAT,EAAelB,IAAI,IAAI,UAAU,KAAKkB,IAAL,CAAUxC,MAAV,CAAiByB,IAAjB,CAAlB;AACf,WAAOH,IAAP;AACD;;AAED/B,eAAa;AACX,UAAMA,aAAN;AACA,UAAMkD,IAAI,GAAG,KAAKF,SAAlB;AACA,QAAIE,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAKjB,KAAZ,CAHR,CAG0B;;AACrC,QAAIkB,CAAC,GAAG,KAAKF,IAAb;;AACA,QAAIE,CAAJ,EAAO;AACL,YAAMC,EAAE,GAAGD,CAAC,CAACnD,aAAF,EAAX;AACAmD,OAAC,GAAG,KAAKF,IAAL,GAAYV,KAAK,CAACC,OAAN,CAAcY,EAAd,IAAoB,IAAIN,IAAJ,CAASM,EAAT,CAApB,GAAoCA,EAApD;AACD;;AACD,QAAID,CAAJ,EAAO;AACL,UAAID,IAAI,KAAK,KAAb,EAAoB,OAAOC,CAAC,YAAYJ,EAAb,GAAkBI,CAAlB,GAAsBA,CAAC,CAAClB,KAA/B;AACpB,UAAI,KAAKA,KAAL,CAAWK,MAAf,EAAuB,OAAO,IAAP;AACvB,aAAO,IAAIS,EAAJ,CAAOM,GAAG,CAACH,IAAD,CAAV,EAAkBC,CAAC,YAAYJ,EAAb,GAAkB,CAACI,CAAD,CAAlB,GAAwBA,CAAC,CAAClB,KAA5C,CAAP;AACD;;AACD,QAAIiB,IAAI,KAAK,KAAT,IAAkB,CAAC,KAAKjB,KAAL,CAAWK,MAAlC,EAA0C,OAAOxB,SAAP;AAC1C,WAAO,IAAP;AACD;;AAEDb,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;;;AAClD,SAAKiC,IAAL,GAAY,WAAKA,IAAL,MAAS,IAAT,IAASK,aAAT,GAAS,MAAT,GAASA,GAAErD,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAArB;AACA,QAAI,EAAE,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,KAAyC,KAAKiC,IAAhD,CAAJ,EAA2D;AAC3D,SAAKD,SAAL,GAAiB9B,YAAY,CAAC,KAAK8B,SAAN,EAAiBjC,KAAjB,EAAwBC,SAAxB,CAA7B;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,UAAMA,KAAK,GAAG,MAAMA,KAApB;AACAO,gBAAY,CAACP,KAAD,EAAQ,KAAKiC,SAAb,CAAZ;AACA,QAAI,KAAKC,IAAT,EAAeN,QAAQ,CAAC5B,KAAD,EAAQ,KAAKkC,IAAL,CAAUlC,KAAlB,CAAR;AACf,WAAOA,KAAP;AACD;;AA3CuB;;AACRgC,UAAO,IAAP;;AAiDlB,MAAeQ,GAAf,SAA2BX,SAA3B,CAAoC;;AAClBW,WAAO,KAAP;;AAGlB,MAAMC,OAAN,SAAsBD,GAAtB,CAAyB;AACvBlD,cAAoBoD,SAApB,EAAmC;AACjC;AADkB;AAEnB;;AAEDhD,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,OAAO,KAAKuB,SAAS,GAArB,GAA2B,MAAMhD,MAAN,CAAayB,IAAb,CAAlC;AACD;;AAEDjC,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,QAAI,CAAC,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,CAAL,EAA4C;AAC5C,SAAKyC,SAAL,GAAiBvC,YAAY,CAAC,KAAKuC,SAAN,EAAiB1C,KAAjB,EAAwBC,SAAxB,CAA7B;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,WAAO4B,QAAQ,CAAC,MAAM5B,KAAP,EAAc,KAAK0C,SAAL,CAAe1C,KAA7B,CAAf;AACD;;AAjBsB;;AAoBzB,MAAM2C,QAAN,SAAuBH,GAAvB,CAA0B;AACxBlD,cACmBC,OADnB,EAEmBC,IAFnB,EAGmBoD,IAHnB,EAImBC,EAJnB,EAI+B;AAE7B;AALiB;AACA;AACA;AACA;AAGlB;;AAEDnD,QAAM,CAACyB,IAAD,EAAgB;AACpB,UAAM5B,OAAO,GAAG4B,IAAI,CAACxB,GAAL,GAAWE,iBAASC,GAApB,GAA0B,KAAKP,OAA/C;AACA,UAAM;AAACC,UAAD;AAAOoD,UAAP;AAAaC;AAAb,QAAmB,IAAzB;AACA,WAAO,OAAOtD,OAAO,IAAIC,IAAI,IAAIoD,IAAI,KAAKpD,IAAI,IAAIqD,EAAE,KAAKrD,IAAI,KAAtD,GAA8D,MAAME,MAAN,CAAayB,IAAb,CAArE;AACD;;AAEQ,MAALnB,KAAK;AACP,UAAMA,KAAK,GAAGO,YAAY,CAAC,MAAMP,KAAP,EAAc,KAAK4C,IAAnB,CAA1B;AACA,WAAOrC,YAAY,CAACP,KAAD,EAAQ,KAAK6C,EAAb,CAAnB;AACD;;AAnBuB;;AAsB1B,MAAMC,OAAN,SAAsBN,GAAtB,CAAyB;AACvBlD,cACmByD,IADnB,EAEmBxD,OAFnB,EAGmBC,IAHnB,EAIUwD,QAJV,EAIwB;AAEtB;AALiB;AACA;AACA;AACT;AAGT;;AAEDtD,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,OAAO,KAAK5B,OAAO,IAAI,KAAKC,IAAI,IAAI,KAAKuD,IAAI,IAAI,KAAKC,QAAQ,GAA9D,GAAoE,MAAMtD,MAAN,CAAayB,IAAb,CAA3E;AACD;;AAEDjC,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;AAClD,QAAI,CAAC,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,CAAL,EAA4C;AAC5C,SAAK+C,QAAL,GAAgB7C,YAAY,CAAC,KAAK6C,QAAN,EAAgBhD,KAAhB,EAAuBC,SAAvB,CAA5B;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,WAAO4B,QAAQ,CAAC,MAAM5B,KAAP,EAAc,KAAKgD,QAAL,CAAchD,KAA5B,CAAf;AACD;;AAtBsB;;AAyBzB,MAAMiD,IAAN,SAAmBpB,SAAnB,CAA4B;AAE1BvC,cAAmBE,IAAnB,EAAsC0D,IAAtC,EAAyDC,KAAzD,EAAwE;AACtE;AADiB;AAAmB;AAAmB;AAExD;;AAEDzD,QAAM,CAACyB,IAAD,EAAgB;AACpB,UAAMiC,MAAM,GAAG,KAAKD,KAAL,GAAa,QAAb,GAAwB,EAAvC;;AACA,WAAO,GAAGC,MAAM,YAAY,KAAK5D,IAAI,IAAI,KAAK0D,IAAI,GAA3C,GAAiD,MAAMxD,MAAN,CAAayB,IAAb,CAAxD;AACD;;AATyB;;AACV8B,YAAO,MAAP;;AAWlB,MAAMI,MAAN,SAAqBpC,UAArB,CAA+B;AAG7BvB,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,YAAY,MAAMzB,MAAN,CAAayB,IAAb,CAAnB;AACD;;AAL4B;;AACbkC,cAAO,QAAP;;AAOlB,MAAMC,GAAN,SAAkBzB,SAAlB,CAA2B;AAIzBnC,QAAM,CAACyB,IAAD,EAAgB;AACpB,QAAIH,IAAI,GAAG,QAAQ,MAAMtB,MAAN,CAAayB,IAAb,CAAnB;AACA,QAAI,KAAKoC,KAAT,EAAgBvC,IAAI,IAAI,KAAKuC,KAAL,CAAW7D,MAAX,CAAkByB,IAAlB,CAAR;AAChB,QAAI,KAAKqC,OAAT,EAAkBxC,IAAI,IAAI,KAAKwC,OAAL,CAAa9D,MAAb,CAAoByB,IAApB,CAAR;AAClB,WAAOH,IAAP;AACD;;AAED/B,eAAa;;;AACX,UAAMA,aAAN;AACA,eAAKsE,KAAL,MAAU,IAAV,IAAUhB,aAAV,GAAU,MAAV,GAAUA,GAAEtD,aAAF,EAAV;AACA,eAAKuE,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAExE,aAAF,EAAZ;AACA,WAAO,IAAP;AACD;;AAEDC,eAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;;;AAClD,UAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B;AACA,eAAKsD,KAAL,MAAU,IAAV,IAAUhB,aAAV,GAAU,MAAV,GAAUA,GAAErD,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAV;AACA,eAAKuD,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAEvE,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAZ;AACA,WAAO,IAAP;AACD;;AAEQ,MAALD,KAAK;AACP,UAAMA,KAAK,GAAG,MAAMA,KAApB;AACA,QAAI,KAAKuD,KAAT,EAAgB3B,QAAQ,CAAC5B,KAAD,EAAQ,KAAKuD,KAAL,CAAWvD,KAAnB,CAAR;AAChB,QAAI,KAAKwD,OAAT,EAAkB5B,QAAQ,CAAC5B,KAAD,EAAQ,KAAKwD,OAAL,CAAaxD,KAArB,CAAR;AAClB,WAAOA,KAAP;AACD;;AA9BwB;;AAqC3B,MAAM0D,KAAN,SAAoB7B,SAApB,CAA6B;AAE3BvC,cAAqBwB,KAArB,EAAgC;AAC9B;AADmB;AAEpB;;AAEDpB,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,SAAS,KAAKL,KAAK,GAAnB,GAAyB,MAAMpB,MAAN,CAAayB,IAAb,CAAhC;AACD;;AAR0B;;AACXuC,aAAO,OAAP;;AAUlB,MAAMC,OAAN,SAAsB9B,SAAtB,CAA+B;AAE7BnC,QAAM,CAACyB,IAAD,EAAgB;AACpB,WAAO,YAAY,MAAMzB,MAAN,CAAayB,IAAb,CAAnB;AACD;;AAJ4B;;AACbwC,eAAO,SAAP;;AAiClB,MAAaC,OAAb,CAAoB;AASlBtE,cAAYuE,QAAZ,EAA2D;AAAA,QAAzB1C,IAAyB,uEAAF,EAAE;AANlD,mBAA0B,EAA1B;AAEQ,wBAAyB,EAAzB;AACA,sBAAwB,EAAxB;AAIf,SAAKA,IAAL,GAAY,EAAC,GAAGA,IAAJ;AAAUvB,QAAE,EAAEuB,IAAI,CAAC2C,KAAL,GAAa,IAAb,GAAoB;AAAlC,KAAZ;AACA,SAAKC,SAAL,GAAiBF,QAAjB;AACA,SAAKG,MAAL,GAAc,IAAInE,aAAJ,CAAU;AAACoE,YAAM,EAAEJ;AAAT,KAAV,CAAd;AACA,SAAKK,MAAL,GAAc,CAAC,IAAIpC,IAAJ,EAAD,CAAd;AACD;;AAEDqC,UAAQ;AACN,WAAO,KAAKC,KAAL,CAAW1E,MAAX,CAAkB,KAAKyB,IAAvB,CAAP;AACD,GAlBiB,CAoBlB;;;AACA3B,MAAI,CAAC6E,MAAD,EAAe;AACjB,WAAO,KAAKL,MAAL,CAAYxE,IAAZ,CAAiB6E,MAAjB,CAAP;AACD,GAvBiB,CAyBlB;;;AACAC,WAAS,CAACD,MAAD,EAAe;AACtB,WAAO,KAAKN,SAAL,CAAevE,IAAf,CAAoB6E,MAApB,CAAP;AACD,GA5BiB,CA8BlB;;;AACAE,YAAU,CAACC,YAAD,EAAwCC,KAAxC,EAAwD;AAChE,UAAMjF,IAAI,GAAG,KAAKuE,SAAL,CAAeU,KAAf,CAAqBD,YAArB,EAAmCC,KAAnC,CAAb;;AACA,UAAMC,EAAE,GAAG,KAAKC,OAAL,CAAanF,IAAI,CAAC6E,MAAlB,MAA8B,KAAKM,OAAL,CAAanF,IAAI,CAAC6E,MAAlB,IAA4B,IAAIO,GAAJ,EAA1D,CAAX;AACAF,MAAE,CAACG,GAAH,CAAOrF,IAAP;AACA,WAAOA,IAAP;AACD;;AAEDsF,eAAa,CAACT,MAAD,EAAiBU,QAAjB,EAAkC;AAC7C,WAAO,KAAKhB,SAAL,CAAeiB,QAAf,CAAwBX,MAAxB,EAAgCU,QAAhC,CAAP;AACD,GAxCiB,CA0ClB;AACA;;;AACAE,WAAS,CAACX,SAAD,EAAgB;AACvB,WAAO,KAAKP,SAAL,CAAekB,SAAf,CAAyBX,SAAzB,EAAoC,KAAKK,OAAzC,CAAP;AACD;;AAEDO,WAAS;AACP,WAAO,KAAKnB,SAAL,CAAemB,SAAf,CAAyB,KAAKP,OAA9B,CAAP;AACD;;AAEOQ,MAAI,CACV5F,OADU,EAEV6F,YAFU,EAGV3F,GAHU,EAIV4F,QAJU,EAIQ;AAElB,UAAM7F,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;AACA,QAAI3F,GAAG,KAAKM,SAAR,IAAqBsF,QAAzB,EAAmC,KAAKjG,UAAL,CAAgBI,IAAI,CAACU,GAArB,IAA4BT,GAA5B;;AACnC,SAAK8F,SAAL,CAAe,IAAIlG,GAAJ,CAAQE,OAAR,EAAiBC,IAAjB,EAAuBC,GAAvB,CAAf;;AACA,WAAOD,IAAP;AACD,GA9DiB,CAgElB;;;AACAgG,OAAK,CAACJ,YAAD,EAA8B3F,GAA9B,EAA6CgG,SAA7C,EAAgE;AACnE,WAAO,KAAKN,IAAL,CAAUtF,iBAAS2F,KAAnB,EAA0BJ,YAA1B,EAAwC3F,GAAxC,EAA6CgG,SAA7C,CAAP;AACD,GAnEiB,CAqElB;;;AACAC,KAAG,CAACN,YAAD,EAA8B3F,GAA9B,EAA8CgG,SAA9C,EAAiE;AAClE,WAAO,KAAKN,IAAL,CAAUtF,iBAAS6F,GAAnB,EAAwBN,YAAxB,EAAsC3F,GAAtC,EAA2CgG,SAA3C,CAAP;AACD,GAxEiB,CA0ElB;;;AACA3F,KAAG,CAACsF,YAAD,EAA8B3F,GAA9B,EAA8CgG,SAA9C,EAAiE;AAClE,WAAO,KAAKN,IAAL,CAAUtF,iBAASC,GAAnB,EAAwBsF,YAAxB,EAAsC3F,GAAtC,EAA2CgG,SAA3C,CAAP;AACD,GA7EiB,CA+ElB;;;AACAE,QAAM,CAACtF,GAAD,EAAYZ,GAAZ,EAA2Ba,WAA3B,EAAgD;AACpD,WAAO,KAAKiF,SAAL,CAAe,IAAInF,MAAJ,CAAWC,GAAX,EAAgBZ,GAAhB,EAAqBa,WAArB,CAAf,CAAP;AACD,GAlFiB,CAoFlB;;;AACAuE,KAAG,CAACxE,GAAD,EAAYZ,GAAZ,EAAyB;AAC1B,WAAO,KAAK8F,SAAL,CAAe,IAAI/E,QAAJ,CAAaH,GAAb,EAAkBjC,kBAAUW,GAA5B,EAAiCU,GAAjC,CAAf,CAAP;AACD,GAvFiB,CAyFlB;;;AACAuB,MAAI,CAAC4E,CAAD,EAAoB;AACtB,QAAI,OAAOA,CAAP,IAAY,UAAhB,EAA4BA,CAAC,GAA7B,KACK,IAAIA,CAAC,KAAKtH,UAAV,EAAe,KAAKiH,SAAL,CAAe,IAAIxE,OAAJ,CAAY6E,CAAZ,CAAf;AACpB,WAAO,IAAP;AACD,GA9FiB,CAgGlB;;;AACAC,QAAM,GAAmD;AACvD,UAAM7E,IAAI,GAAe,CAAC,GAAD,CAAzB;;AADuD,sCAA/C8E,SAA+C;AAA/CA,eAA+C;AAAA;;AAEvD,SAAK,MAAM,CAACC,GAAD,EAAMtB,KAAN,CAAX,IAA2BqB,SAA3B,EAAsC;AACpC,UAAI9E,IAAI,CAACO,MAAL,GAAc,CAAlB,EAAqBP,IAAI,CAACgF,IAAL,CAAU,GAAV;AACrBhF,UAAI,CAACgF,IAAL,CAAUD,GAAV;;AACA,UAAIA,GAAG,KAAKtB,KAAR,IAAiB,KAAKtD,IAAL,CAAUxB,GAA/B,EAAoC;AAClCqB,YAAI,CAACgF,IAAL,CAAU,GAAV;AACA,+BAAWhF,IAAX,EAAiByD,KAAjB;AACD;AACF;;AACDzD,QAAI,CAACgF,IAAL,CAAU,GAAV;AACA,WAAO,IAAI1H,YAAJ,CAAU0C,IAAV,CAAP;AACD,GA7GiB,CA+GlB;;;AACAiF,IAAE,CAAChE,SAAD,EAA4BiE,QAA5B,EAA8CC,QAA9C,EAA8D;AAC9D,SAAKC,UAAL,CAAgB,IAAIpE,EAAJ,CAAOC,SAAP,CAAhB;;AAEA,QAAIiE,QAAQ,IAAIC,QAAhB,EAA0B;AACxB,WAAKnF,IAAL,CAAUkF,QAAV,EAAoBhE,IAApB,GAA2BlB,IAA3B,CAAgCmF,QAAhC,EAA0CE,KAA1C;AACD,KAFD,MAEO,IAAIH,QAAJ,EAAc;AACnB,WAAKlF,IAAL,CAAUkF,QAAV,EAAoBG,KAApB;AACD,KAFM,MAEA,IAAIF,QAAJ,EAAc;AACnB,YAAM,IAAIG,KAAJ,CAAU,0CAAV,CAAN;AACD;;AACD,WAAO,IAAP;AACD,GA3HiB,CA6HlB;;;AACAC,QAAM,CAACtE,SAAD,EAA0B;AAC9B,WAAO,KAAKuE,SAAL,CAAe,IAAIxE,EAAJ,CAAOC,SAAP,CAAf,CAAP;AACD,GAhIiB,CAkIlB;;;AACAC,MAAI;AACF,WAAO,KAAKsE,SAAL,CAAe,IAAIzE,IAAJ,EAAf,CAAP;AACD,GArIiB,CAuIlB;;;AACAsE,OAAK;AACH,WAAO,KAAKI,aAAL,CAAmBzE,EAAnB,EAAuBD,IAAvB,CAAP;AACD;;AAEO2E,MAAI,CAACC,IAAD,EAAYC,OAAZ,EAA2B;AACrC,SAAKR,UAAL,CAAgBO,IAAhB;;AACA,QAAIC,OAAJ,EAAa,KAAK5F,IAAL,CAAU4F,OAAV,EAAmBC,MAAnB;AACb,WAAO,IAAP;AACD,GAhJiB,CAkJlB;;;AACAC,KAAG,CAACpE,SAAD,EAAkBkE,OAAlB,EAAiC;AAClC,WAAO,KAAKF,IAAL,CAAU,IAAIjE,OAAJ,CAAYC,SAAZ,CAAV,EAAkCkE,OAAlC,CAAP;AACD,GArJiB,CAuJlB;;;AACAG,UAAQ,CACN3B,YADM,EAENxC,IAFM,EAGNC,EAHM,EAIN+D,OAJM,EAKqD;AAAA,QAA3DrH,OAA2D,uEAA3C,KAAK4B,IAAL,CAAUxB,GAAV,GAAgBE,iBAASC,GAAzB,GAA+BD,iBAAS6F,GAAG;;AAE3D,UAAMlG,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;AACA,WAAO,KAAKsB,IAAL,CAAU,IAAI/D,QAAJ,CAAapD,OAAb,EAAsBC,IAAtB,EAA4BoD,IAA5B,EAAkCC,EAAlC,CAAV,EAAiD,MAAM+D,OAAO,CAACpH,IAAD,CAA9D,CAAP;AACD,GAjKiB,CAmKlB;;;AACAwH,OAAK,CACH5B,YADG,EAEHpC,QAFG,EAGH4D,OAHG,EAI2B;AAAA,QAA9BrH,OAA8B,uEAAdM,iBAAS2F,KAAK;;AAE9B,UAAMhG,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;AACA,QAAI,KAAKjE,IAAL,CAAUxB,GAAd,EAAmB;AACjB,YAAMsH,GAAG,GAAGjE,QAAQ,YAAY1E,WAApB,GAA2B0E,QAA3B,GAAsC,KAAKlD,GAAL,CAAS,MAAT,EAAiBkD,QAAjB,CAAlD;AACA,aAAO,KAAK+D,QAAL,CAAc,IAAd,EAAoB,CAApB,EAAuB,aAAC,GAAGE,GAAG,SAA9B,EAA0C3F,CAAD,IAAM;AACpD,aAAKxB,GAAL,CAASN,IAAT,EAAe,aAAC,GAAGyH,GAAG,IAAI3F,CAAC,GAA3B;AACAsF,eAAO,CAACpH,IAAD,CAAP;AACD,OAHM,CAAP;AAID;;AACD,WAAO,KAAKkH,IAAL,CAAU,IAAI5D,OAAJ,CAAY,IAAZ,EAAkBvD,OAAlB,EAA2BC,IAA3B,EAAiCwD,QAAjC,CAAV,EAAsD,MAAM4D,OAAO,CAACpH,IAAD,CAAnE,CAAP;AACD,GAnLiB,CAqLlB;AACA;;;AACA0H,OAAK,CACH9B,YADG,EAEH+B,GAFG,EAGHP,OAHG,EAI0D;AAAA,QAA7DrH,OAA6D,uEAA7C,KAAK4B,IAAL,CAAUxB,GAAV,GAAgBE,iBAASC,GAAzB,GAA+BD,iBAAS2F,KAAK;;AAE7D,QAAI,KAAKrE,IAAL,CAAUiG,aAAd,EAA6B;AAC3B,aAAO,KAAKJ,KAAL,CAAW5B,YAAX,EAAyB,aAAC,eAAe+B,GAAG,GAA5C,EAAiDP,OAAjD,CAAP;AACD;;AACD,UAAMpH,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;AACA,WAAO,KAAKsB,IAAL,CAAU,IAAI5D,OAAJ,CAAY,IAAZ,EAAkBvD,OAAlB,EAA2BC,IAA3B,EAAiC2H,GAAjC,CAAV,EAAiD,MAAMP,OAAO,CAACpH,IAAD,CAA9D,CAAP;AACD,GAlMiB,CAoMlB;;;AACAqH,QAAM;AACJ,WAAO,KAAKJ,aAAL,CAAmBjE,GAAnB,CAAP;AACD,GAvMiB,CAyMlB;;;AACA7B,OAAK,CAACA,KAAD,EAAY;AACf,WAAO,KAAK4E,SAAL,CAAe,IAAI7E,KAAJ,CAAUC,KAAV,CAAf,CAAP;AACD,GA5MiB,CA8MlB;;;AACA0G,OAAK,CAAC1G,KAAD,EAAa;AAChB,WAAO,KAAK4E,SAAL,CAAe,IAAI3E,KAAJ,CAAUD,KAAV,CAAf,CAAP;AACD,GAjNiB,CAmNlB;;;AACA2G,QAAM,CAAC7C,KAAD,EAAwB;AAC5B,UAAMkC,IAAI,GAAG,IAAItD,MAAJ,EAAb;;AACA,SAAK+C,UAAL,CAAgBO,IAAhB;;AACA,SAAK3F,IAAL,CAAUyD,KAAV;AACA,QAAIkC,IAAI,CAACzF,KAAL,CAAWK,MAAX,KAAsB,CAA1B,EAA6B,MAAM,IAAI+E,KAAJ,CAAU,wCAAV,CAAN;AAC7B,WAAO,KAAKG,aAAL,CAAmBpD,MAAnB,CAAP;AACD,GA1NiB,CA4NlB;;;AACAkE,KAAG,CAACC,OAAD,EAAiBC,SAAjB,EAAgDC,WAAhD,EAAmE;AACpE,QAAI,CAACD,SAAD,IAAc,CAACC,WAAnB,EAAgC,MAAM,IAAIpB,KAAJ,CAAU,8CAAV,CAAN;AAChC,UAAMK,IAAI,GAAG,IAAIrD,GAAJ,EAAb;;AACA,SAAK8C,UAAL,CAAgBO,IAAhB;;AACA,SAAK3F,IAAL,CAAUwG,OAAV;;AACA,QAAIC,SAAJ,EAAe;AACb,YAAM3G,KAAK,GAAG,KAAKtB,IAAL,CAAU,GAAV,CAAd;AACA,WAAKmI,SAAL,GAAiBhB,IAAI,CAACpD,KAAL,GAAa,IAAIG,KAAJ,CAAU5C,KAAV,CAA9B;AACA2G,eAAS,CAAC3G,KAAD,CAAT;AACD;;AACD,QAAI4G,WAAJ,EAAiB;AACf,WAAKC,SAAL,GAAiBhB,IAAI,CAACnD,OAAL,GAAe,IAAIG,OAAJ,EAAhC;AACA,WAAK3C,IAAL,CAAU0G,WAAV;AACD;;AACD,WAAO,KAAKjB,aAAL,CAAmB/C,KAAnB,EAA0BC,OAA1B,CAAP;AACD,GA5OiB,CA8OlB;;;AACAiE,OAAK,CAAC9G,KAAD,EAAY;AACf,WAAO,KAAKyE,SAAL,CAAe,IAAI1E,KAAJ,CAAUC,KAAV,CAAf,CAAP;AACD,GAjPiB,CAmPlB;;;AACA+G,OAAK,CAACC,IAAD,EAAeC,SAAf,EAAiC;AACpC,SAAKC,YAAL,CAAkBhC,IAAlB,CAAuB,KAAK9B,MAAL,CAAY3C,MAAnC;;AACA,QAAIuG,IAAJ,EAAU,KAAK9G,IAAL,CAAU8G,IAAV,EAAgBG,QAAhB,CAAyBF,SAAzB;AACV,WAAO,IAAP;AACD,GAxPiB,CA0PlB;;;AACAE,UAAQ,CAACF,SAAD,EAAmB;AACzB,UAAMG,GAAG,GAAG,KAAKF,YAAL,CAAkBG,GAAlB,EAAZ;;AACA,QAAID,GAAG,KAAKnI,SAAZ,EAAuB,MAAM,IAAIuG,KAAJ,CAAU,sCAAV,CAAN;AACvB,UAAM8B,OAAO,GAAG,KAAKlE,MAAL,CAAY3C,MAAZ,GAAqB2G,GAArC;;AACA,QAAIE,OAAO,GAAG,CAAV,IAAgBL,SAAS,KAAKhI,SAAd,IAA2BqI,OAAO,KAAKL,SAA3D,EAAuE;AACrE,YAAM,IAAIzB,KAAJ,CAAU,mCAAmC8B,OAAO,OAAOL,SAAS,WAApE,CAAN;AACD;;AACD,SAAK7D,MAAL,CAAY3C,MAAZ,GAAqB2G,GAArB;AACA,WAAO,IAAP;AACD,GApQiB,CAsQlB;;;AACAG,MAAI,CAAC7I,IAAD,EAAgE;AAAA,QAAnD0D,IAAmD,uEAAtC5E,UAAsC;AAAA,QAAjC6E,KAAiC;AAAA,QAAhBmF,QAAgB;;AAClE,SAAKlC,UAAL,CAAgB,IAAInD,IAAJ,CAASzD,IAAT,EAAe0D,IAAf,EAAqBC,KAArB,CAAhB;;AACA,QAAImF,QAAJ,EAAc,KAAKtH,IAAL,CAAUsH,QAAV,EAAoBC,OAApB;AACd,WAAO,IAAP;AACD,GA3QiB,CA6QlB;;;AACAA,SAAO;AACL,WAAO,KAAK9B,aAAL,CAAmBxD,IAAnB,CAAP;AACD;;AAEDuF,UAAQ,GAAM;AAAA,QAALnH,CAAK,uEAAD,CAAC;;AACZ,WAAOA,CAAC,KAAK,CAAb,EAAgB;AACd,WAAK+C,KAAL,CAAWnF,aAAX;;AACA,WAAKmF,KAAL,CAAWlF,aAAX,CAAyB,KAAKkF,KAAL,CAAWpE,KAApC,EAA2C,KAAKZ,UAAhD;AACD;AACF;;AAEOmG,WAAS,CAACoB,IAAD,EAAe;AAC9B,SAAKgB,SAAL,CAAezG,KAAf,CAAqB8E,IAArB,CAA0BW,IAA1B;;AACA,WAAO,IAAP;AACD;;AAEOP,YAAU,CAACO,IAAD,EAAqB;AACrC,SAAKgB,SAAL,CAAezG,KAAf,CAAqB8E,IAArB,CAA0BW,IAA1B;;AACA,SAAKzC,MAAL,CAAY8B,IAAZ,CAAiBW,IAAjB;AACD;;AAEOF,eAAa,CAACgC,EAAD,EAAuBC,EAAvB,EAA4C;AAC/D,UAAMrH,CAAC,GAAG,KAAKsG,SAAf;;AACA,QAAItG,CAAC,YAAYoH,EAAb,IAAoBC,EAAE,IAAIrH,CAAC,YAAYqH,EAA3C,EAAgD;AAC9C,WAAKxE,MAAL,CAAYiE,GAAZ;;AACA,aAAO,IAAP;AACD;;AACD,UAAM,IAAI7B,KAAJ,CAAU,0BAA0BoC,EAAE,GAAG,GAAGD,EAAE,CAACE,IAAI,IAAID,EAAE,CAACC,IAAI,EAAxB,GAA6BF,EAAE,CAACE,IAAI,GAA1E,CAAN;AACD;;AAEOnC,WAAS,CAACG,IAAD,EAAgB;AAC/B,UAAMtF,CAAC,GAAG,KAAKsG,SAAf;;AACA,QAAI,EAAEtG,CAAC,YAAYW,EAAf,CAAJ,EAAwB;AACtB,YAAM,IAAIsE,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,SAAKqB,SAAL,GAAiBtG,CAAC,CAACa,IAAF,GAASyE,IAA1B;AACA,WAAO,IAAP;AACD;;AAEgB,MAALvC,KAAK;AACf,WAAO,KAAKF,MAAL,CAAY,CAAZ,CAAP;AACD;;AAEoB,MAATyD,SAAS;AACnB,UAAMtF,EAAE,GAAG,KAAK6B,MAAhB;AACA,WAAO7B,EAAE,CAACA,EAAE,CAACd,MAAH,GAAY,CAAb,CAAT;AACD;;AAEoB,MAAToG,SAAS,CAAChB,IAAD,EAAiB;AACpC,UAAMtE,EAAE,GAAG,KAAK6B,MAAhB;AACA7B,MAAE,CAACA,EAAE,CAACd,MAAH,GAAY,CAAb,CAAF,GAAoBoF,IAApB;AACD;;AAjUiB;;AAApBvI;;AAwUA,SAASwD,QAAT,CAAkB5B,KAAlB,EAAoC4C,IAApC,EAAmD;AACjD,OAAK,MAAMvB,CAAX,IAAgBuB,IAAhB,EAAsB5C,KAAK,CAACqB,CAAD,CAAL,GAAW,CAACrB,KAAK,CAACqB,CAAD,CAAL,IAAY,CAAb,KAAmBuB,IAAI,CAACvB,CAAD,CAAJ,IAAW,CAA9B,CAAX;;AACtB,SAAOrB,KAAP;AACD;;AAED,SAASO,YAAT,CAAsBP,KAAtB,EAAwC4C,IAAxC,EAAsD;AACpD,SAAOA,IAAI,YAAYtE,kBAAhB,GAA8BsD,QAAQ,CAAC5B,KAAD,EAAQ4C,IAAI,CAAC5C,KAAb,CAAtC,GAA4DA,KAAnE;AACD;;AAGD,SAASG,YAAT,CAAsByI,IAAtB,EAAsC5I,KAAtC,EAAwDC,SAAxD,EAA4E;AAC1E,MAAI2I,IAAI,YAAYtK,WAApB,EAA0B,OAAOuK,WAAW,CAACD,IAAD,CAAlB;AAC1B,MAAI,CAACE,WAAW,CAACF,IAAD,CAAhB,EAAwB,OAAOA,IAAP;AACxB,SAAO,IAAItK,YAAJ,CACLsK,IAAI,CAACG,MAAL,CAAY3H,MAAZ,CAAmB,CAAC4H,KAAD,EAAoBpD,CAApB,KAA4C;AAC7D,QAAIA,CAAC,YAAYtH,WAAjB,EAAuBsH,CAAC,GAAGiD,WAAW,CAACjD,CAAD,CAAf;AACvB,QAAIA,CAAC,YAAYtH,YAAjB,EAAwB0K,KAAK,CAAChD,IAAN,CAAW,GAAGJ,CAAC,CAACmD,MAAhB,EAAxB,KACKC,KAAK,CAAChD,IAAN,CAAWJ,CAAX;AACL,WAAOoD,KAAP;AACD,GALD,EAKG,EALH,CADK,CAAP;;AASA,WAASH,WAAT,CAAqBxH,CAArB,EAA4B;AAC1B,UAAMuE,CAAC,GAAG3F,SAAS,CAACoB,CAAC,CAACnB,GAAH,CAAnB;AACA,QAAI0F,CAAC,KAAK7F,SAAN,IAAmBC,KAAK,CAACqB,CAAC,CAACnB,GAAH,CAAL,KAAiB,CAAxC,EAA2C,OAAOmB,CAAP;AAC3C,WAAOrB,KAAK,CAACqB,CAAC,CAACnB,GAAH,CAAZ;AACA,WAAO0F,CAAP;AACD;;AAED,WAASkD,WAAT,CAAqB1G,CAArB,EAAgC;AAC9B,WACEA,CAAC,YAAY9D,YAAb,IACA8D,CAAC,CAAC2G,MAAF,CAASE,IAAT,CACGrD,CAAD,IAAOA,CAAC,YAAYtH,WAAb,IAAqB0B,KAAK,CAAC4F,CAAC,CAAC1F,GAAH,CAAL,KAAiB,CAAtC,IAA2CD,SAAS,CAAC2F,CAAC,CAAC1F,GAAH,CAAT,KAAqBH,SADzE,CAFF;AAMD;AACF;;AAED,SAAS4B,aAAT,CAAuB3B,KAAvB,EAAyC4C,IAAzC,EAAwD;AACtD,OAAK,MAAMvB,CAAX,IAAgBuB,IAAhB,EAAsB5C,KAAK,CAACqB,CAAD,CAAL,GAAW,CAACrB,KAAK,CAACqB,CAAD,CAAL,IAAY,CAAb,KAAmBuB,IAAI,CAACvB,CAAD,CAAJ,IAAW,CAA9B,CAAX;AACvB;;AAGD,SAAgBiB,GAAhB,CAAoB4G,CAApB,EAAsC;AACpC,SAAO,OAAOA,CAAP,IAAY,SAAZ,IAAyB,OAAOA,CAAP,IAAY,QAArC,IAAiDA,CAAC,KAAK,IAAvD,GAA8D,CAACA,CAA/D,GAAmE,aAAC,IAAIC,GAAG,CAACD,CAAD,CAAG,EAArF;AACD;;AAFD9K;AAIA,MAAMgL,OAAO,GAAGC,OAAO,CAACjL,kBAAUU,GAAX,CAAvB,C,CAEA;;AACA,SAAgBwK,GAAhB,GAAmC;AAAA,qCAAZpG,IAAY;AAAZA,QAAY;AAAA;;AACjC,SAAOA,IAAI,CAAC9B,MAAL,CAAYgI,OAAZ,CAAP;AACD;;AAFDhL;AAIA,MAAMmL,MAAM,GAAGF,OAAO,CAACjL,kBAAUS,EAAX,CAAtB,C,CAEA;;AACA,SAAgB2K,EAAhB,GAAkC;AAAA,qCAAZtG,IAAY;AAAZA,QAAY;AAAA;;AAChC,SAAOA,IAAI,CAAC9B,MAAL,CAAYmI,MAAZ,CAAP;AACD;;AAFDnL;;AAMA,SAASiL,OAAT,CAAiB5I,EAAjB,EAAyB;AACvB,SAAO,CAACyI,CAAD,EAAIO,CAAJ,KAAWP,CAAC,KAAK5K,UAAN,GAAYmL,CAAZ,GAAgBA,CAAC,KAAKnL,UAAN,GAAY4K,CAAZ,GAAgB,aAAC,GAAGC,GAAG,CAACD,CAAD,CAAG,IAAIzI,EAAE,IAAI0I,GAAG,CAACM,CAAD,CAAG,EAA5E;AACD;;AAED,SAASN,GAAT,CAAaD,CAAb,EAAoB;AAClB,SAAOA,CAAC,YAAY5K,WAAb,GAAoB4K,CAApB,GAAwB,aAAC,IAAIA,CAAC,GAArC;AACD","names":["Object","enumerable","get","exports","GT","code_1","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_names","_constants","Def","constructor","varKind","name","rhs","render","es5","_n","scope_1","var","undefined","names","constants","str","optimizeExpr","Assign","lhs","sideEffects","addExprNames","AssignOp","op","Label","label","Break","Throw","error","AnyCode","code","ParentNode","nodes","opts","reduce","n","i","length","Array","isArray","splice","subtractNames","addNames","BlockNode","Root","Else","If","condition","else","cond","e","ns","not","_a","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","args","async","_async","Return","Try","catch","finally","_b","Catch","Finally","CodeGen","extScope","lines","_extScope","_scope","parent","_nodes","toString","_root","prefix","scopeName","scopeValue","prefixOrName","value","vs","_values","Set","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","const","_constant","let","assign","c","object","keyValues","key","push","if","thenBody","elseBody","_blockNode","endIf","Error","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forRange","forOf","arr","forIn","obj","ownProperties","break","return","try","tryBody","catchCode","finallyCode","_currNode","throw","block","body","nodeCount","_blockStarts","endBlock","len","pop","toClose","func","funcBody","endFunc","optimize","N1","N2","kind","expr","replaceName","canOptimize","_items","items","some","x","par","andCode","mappend","and","orCode","or","y"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/ajv-formats/node_modules/ajv/lib/compile/codegen/index.ts"],"sourcesContent":["import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n"]},"metadata":{},"sourceType":"script"}