{"ast":null,"code":"'use strict';\n\nconst regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;\nconst regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nconst regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Convert transform string to JS representation.\n *\n * @type {(transformString: string) => Array<TransformItem>}\n */\n\nexports.transform2js = transformString => {\n  // JS representation of the transform data\n\n  /**\n   * @type {Array<TransformItem>}\n   */\n  const transforms = []; // current transform context\n\n  /**\n   * @type {null | TransformItem}\n   */\n\n  let current = null; // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n\n  for (const item of transformString.split(regTransformSplit)) {\n    var num;\n\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        current = {\n          name: item,\n          data: []\n        };\n        transforms.push(current); // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        // eslint-disable-next-line no-cond-assign\n        while (num = regNumericValues.exec(item)) {\n          num = Number(num);\n\n          if (current != null) {\n            current.data.push(num);\n          }\n        }\n      }\n    }\n  } // return empty array if broken transform (no data)\n\n\n  return current == null || current.data.length == 0 ? [] : transforms;\n};\n/**\n * Multiply transforms into one.\n *\n * @type {(transforms: Array<TransformItem>) => TransformItem}\n */\n\n\nexports.transformsMultiply = transforms => {\n  // convert transforms objects to the matrices\n  const matrixData = transforms.map(transform => {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n\n    return transformToMatrix(transform);\n  }); // multiply all matrices into one\n\n  const matrixTransform = {\n    name: 'matrix',\n    data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []\n  };\n  return matrixTransform;\n};\n/**\n * math utilities in radians.\n */\n\n\nconst mth = {\n  /**\n   * @type {(deg: number) => number}\n   */\n  rad: deg => {\n    return deg * Math.PI / 180;\n  },\n\n  /**\n   * @type {(rad: number) => number}\n   */\n  deg: rad => {\n    return rad * 180 / Math.PI;\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  cos: deg => {\n    return Math.cos(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  acos: (val, floatPrecision) => {\n    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  sin: deg => {\n    return Math.sin(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  asin: (val, floatPrecision) => {\n    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  tan: deg => {\n    return Math.tan(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  atan: (val, floatPrecision) => {\n    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));\n  }\n};\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * Decompose matrix into simple transforms. See\n * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}\n */\n\nexports.matrixToTransform = (transform, params) => {\n  let floatPrecision = params.floatPrecision;\n  let data = transform.data;\n  let transforms = [];\n  let sx = Number(Math.hypot(data[0], data[1]).toFixed(params.transformPrecision));\n  let sy = Number(((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision));\n  let colsSum = data[0] * data[2] + data[1] * data[3];\n  let rowsSum = data[0] * data[1] + data[2] * data[3];\n  let scaleBefore = rowsSum != 0 || sx == sy; // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5)\n    });\n  } // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n\n\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)]\n    }); // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)]\n    });\n    sx = data[0];\n    sy = data[3]; // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({\n        name: 'scale',\n        data: [sx, sy]\n      });\n    }\n\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n        rotate = [mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)];\n    if (rotate[0]) transforms.push({\n      name: 'rotate',\n      data: rotate\n    });\n    if (rowsSum && colsSum) transforms.push({\n      name: 'skewX',\n      data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n    }); // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n          sin = data[1] / (scaleBefore ? sx : sy),\n          x = data[4] * (scaleBefore ? 1 : sy),\n          y = data[5] * (scaleBefore ? 1 : sx),\n          denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore ? 1 : sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    } // Too many transformations, return original matrix if it isn't just a scale/translate\n\n  } else if (data[1] || data[2]) {\n    return [transform];\n  }\n\n  if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n    name: 'scale',\n    data: sx == sy ? [sx] : [sx, sy]\n  });\n  return transforms;\n};\n/**\n * Convert transform to the matrix data.\n *\n * @type {(transform: TransformItem) => Array<number> }\n */\n\n\nconst transformToMatrix = transform => {\n  if (transform.name === 'matrix') {\n    return transform.data;\n  }\n\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      return [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n          sin = mth.sin(transform.data[0]),\n          cx = transform.data[1] || 0,\n          cy = transform.data[2] || 0;\n      return [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n\n    default:\n      throw Error(`Unknown transform ${transform.name}`);\n  }\n};\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @type {(\n *   cursor: [x: number, y: number],\n *   arc: Array<number>,\n *   transform: Array<number>\n * ) => Array<number>}\n */\n\n\nexports.transformArc = (cursor, arc, transform) => {\n  const x = arc[5] - cursor[0];\n  const y = arc[6] - cursor[1];\n  let a = arc[0];\n  let b = arc[1];\n  const rot = arc[2] * Math.PI / 180;\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot); // skip if radius is 0\n\n  if (a > 0 && b > 0) {\n    let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      a *= h;\n      b *= h;\n    }\n  }\n\n  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];\n  const m = multiplyTransformMatrices(transform, ellipse); // Decompose the new ellipse matrix\n\n  const lastCol = m[2] * m[2] + m[3] * m[3];\n  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;\n  const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    const majorAxisSqr = (squareSum + root) / 2;\n    const minorAxisSqr = (squareSum - root) / 2;\n    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;\n    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;\n    const rowsSum = m[0] * m[2] + m[1] * m[3];\n    const term1 = m[0] * sub + m[2] * rowsSum;\n    const term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;\n  }\n\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n\n  return arc;\n};\n/**\n * Multiply transformation matrices.\n *\n * @type {(a: Array<number>, b: Array<number>) => Array<number>}\n */\n\n\nconst multiplyTransformMatrices = (a, b) => {\n  return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/_transforms.js"],"names":["regTransformTypes","regTransformSplit","regNumericValues","exports","transform2js","transformString","transforms","current","item","split","num","test","name","data","push","exec","Number","length","transformsMultiply","matrixData","map","transform","transformToMatrix","matrixTransform","reduce","multiplyTransformMatrices","mth","rad","deg","Math","PI","cos","acos","val","floatPrecision","toFixed","sin","asin","tan","atan","matrixToTransform","params","sx","hypot","transformPrecision","sy","colsSum","rowsSum","scaleBefore","slice","angle","min","max","rotate","shift","x","y","denom","pow","cx","cy","Error","transformArc","cursor","arc","a","b","rot","h","sqrt","ellipse","m","lastCol","squareSum","root","majorAxisSqr","minorAxisSqr","major","abs","sub","term1","term2"],"mappings":"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","sourcesContent":["'use strict';\n\nconst regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;\nconst regTransformSplit =\n  /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nconst regNumericValues = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Convert transform string to JS representation.\n *\n * @type {(transformString: string) => Array<TransformItem>}\n */\nexports.transform2js = (transformString) => {\n  // JS representation of the transform data\n  /**\n   * @type {Array<TransformItem>}\n   */\n  const transforms = [];\n  // current transform context\n  /**\n   * @type {null | TransformItem}\n   */\n  let current = null;\n  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n  for (const item of transformString.split(regTransformSplit)) {\n    var num;\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        current = { name: item, data: [] };\n        transforms.push(current);\n        // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        // eslint-disable-next-line no-cond-assign\n        while ((num = regNumericValues.exec(item))) {\n          num = Number(num);\n          if (current != null) {\n            current.data.push(num);\n          }\n        }\n      }\n    }\n  }\n  // return empty array if broken transform (no data)\n  return current == null || current.data.length == 0 ? [] : transforms;\n};\n\n/**\n * Multiply transforms into one.\n *\n * @type {(transforms: Array<TransformItem>) => TransformItem}\n */\nexports.transformsMultiply = (transforms) => {\n  // convert transforms objects to the matrices\n  const matrixData = transforms.map((transform) => {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n    return transformToMatrix(transform);\n  });\n  // multiply all matrices into one\n  const matrixTransform = {\n    name: 'matrix',\n    data:\n      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],\n  };\n  return matrixTransform;\n};\n\n/**\n * math utilities in radians.\n */\nconst mth = {\n  /**\n   * @type {(deg: number) => number}\n   */\n  rad: (deg) => {\n    return (deg * Math.PI) / 180;\n  },\n\n  /**\n   * @type {(rad: number) => number}\n   */\n  deg: (rad) => {\n    return (rad * 180) / Math.PI;\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  cos: (deg) => {\n    return Math.cos(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  acos: (val, floatPrecision) => {\n    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  sin: (deg) => {\n    return Math.sin(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  asin: (val, floatPrecision) => {\n    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));\n  },\n\n  /**\n   * @type {(deg: number) => number}\n   */\n  tan: (deg) => {\n    return Math.tan(mth.rad(deg));\n  },\n\n  /**\n   * @type {(val: number, floatPrecision: number) => number}\n   */\n  atan: (val, floatPrecision) => {\n    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));\n  },\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * Decompose matrix into simple transforms. See\n * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html\n *\n * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}\n */\nexports.matrixToTransform = (transform, params) => {\n  let floatPrecision = params.floatPrecision;\n  let data = transform.data;\n  let transforms = [];\n  let sx = Number(\n    Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)\n  );\n  let sy = Number(\n    ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(\n      params.transformPrecision\n    )\n  );\n  let colsSum = data[0] * data[2] + data[1] * data[3];\n  let rowsSum = data[0] * data[1] + data[2] * data[3];\n  let scaleBefore = rowsSum != 0 || sx == sy;\n\n  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5),\n    });\n  }\n\n  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)],\n    });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)],\n    });\n    sx = data[0];\n    sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);\n      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);\n      transforms.push({ name: 'scale', data: [sx, sy] });\n    }\n    var angle = Math.min(Math.max(-1, data[0] / sx), 1),\n      rotate = [\n        mth.acos(angle, floatPrecision) *\n          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),\n      ];\n\n    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });\n\n    if (rowsSum && colsSum)\n      transforms.push({\n        name: 'skewX',\n        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],\n      });\n\n    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n        sin = data[1] / (scaleBefore ? sx : sy),\n        x = data[4] * (scaleBefore ? 1 : sy),\n        y = data[5] * (scaleBefore ? 1 : sx),\n        denom =\n          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *\n          (scaleBefore ? 1 : sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n  } else if (data[1] || data[2]) {\n    return [transform];\n  }\n\n  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)\n    transforms.push({\n      name: 'scale',\n      data: sx == sy ? [sx] : [sx, sy],\n    });\n\n  return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @type {(transform: TransformItem) => Array<number> }\n */\nconst transformToMatrix = (transform) => {\n  if (transform.name === 'matrix') {\n    return transform.data;\n  }\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      return [\n        transform.data[0],\n        0,\n        0,\n        transform.data[1] || transform.data[0],\n        0,\n        0,\n      ];\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n        sin = mth.sin(transform.data[0]),\n        cx = transform.data[1] || 0,\n        cy = transform.data[2] || 0;\n      return [\n        cos,\n        sin,\n        -sin,\n        cos,\n        (1 - cos) * cx + sin * cy,\n        (1 - cos) * cy - sin * cx,\n      ];\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n    default:\n      throw Error(`Unknown transform ${transform.name}`);\n  }\n};\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @type {(\n *   cursor: [x: number, y: number],\n *   arc: Array<number>,\n *   transform: Array<number>\n * ) => Array<number>}\n */\nexports.transformArc = (cursor, arc, transform) => {\n  const x = arc[5] - cursor[0];\n  const y = arc[6] - cursor[1];\n  let a = arc[0];\n  let b = arc[1];\n  const rot = (arc[2] * Math.PI) / 180;\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot);\n  // skip if radius is 0\n  if (a > 0 && b > 0) {\n    let h =\n      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +\n      Math.pow(y * cos - x * sin, 2) / (4 * b * b);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      a *= h;\n      b *= h;\n    }\n  }\n  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];\n  const m = multiplyTransformMatrices(transform, ellipse);\n  // Decompose the new ellipse matrix\n  const lastCol = m[2] * m[2] + m[3] * m[3];\n  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;\n  const root =\n    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);\n\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    const majorAxisSqr = (squareSum + root) / 2;\n    const minorAxisSqr = (squareSum - root) / 2;\n    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;\n    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;\n    const rowsSum = m[0] * m[2] + m[1] * m[3];\n    const term1 = m[0] * sub + m[2] * rowsSum;\n    const term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] =\n      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *\n        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *\n        180) /\n      Math.PI;\n  }\n\n  if (transform[0] < 0 !== transform[3] < 0) {\n    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically\n    arc[4] = 1 - arc[4];\n  }\n\n  return arc;\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @type {(a: Array<number>, b: Array<number>) => Array<number>}\n */\nconst multiplyTransformMatrices = (a, b) => {\n  return [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    a[0] * b[4] + a[2] * b[5] + a[4],\n    a[1] * b[4] + a[3] * b[5] + a[5],\n  ];\n};\n"]},"metadata":{},"sourceType":"script"}