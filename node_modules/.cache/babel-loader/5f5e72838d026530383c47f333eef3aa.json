{"ast":null,"code":"'use strict';\n\nconst {\n  removeLeadingZero\n} = require('../lib/svgo/tools');\n\nexports.name = 'cleanupNumericValues';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'rounds numeric values to the fixed precision, removes default ‘px’ units';\nconst regNumericValues = /^([-+]?\\d*\\.?\\d+([eE][-+]?\\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;\nconst absoluteLengths = {\n  // relative to px\n  cm: 96 / 2.54,\n  mm: 96 / 25.4,\n  in: 96,\n  pt: 4 / 3,\n  pc: 16,\n  px: 1\n};\n/**\n * Round numeric values to the fixed precision,\n * remove default 'px' units.\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   floatPrecision?: number,\n *   leadingZero?: boolean,\n *   defaultPx?: boolean,\n *   convertToPx?: boolean\n * }>}\n */\n\nexports.fn = (_root, params) => {\n  const {\n    floatPrecision = 3,\n    leadingZero = true,\n    defaultPx = true,\n    convertToPx = true\n  } = params;\n  return {\n    element: {\n      enter: node => {\n        if (node.attributes.viewBox != null) {\n          const nums = node.attributes.viewBox.split(/\\s,?\\s*|,\\s*/g);\n          node.attributes.viewBox = nums.map(value => {\n            const num = Number(value);\n            return Number.isNaN(num) ? value : Number(num.toFixed(floatPrecision));\n          }).join(' ');\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          // The `version` attribute is a text string and cannot be rounded\n          if (name === 'version') {\n            continue;\n          }\n\n          const match = value.match(regNumericValues); // if attribute value matches regNumericValues\n\n          if (match) {\n            // round it to the fixed precision\n            let num = Number(Number(match[1]).toFixed(floatPrecision));\n            /**\n             * @type {any}\n             */\n\n            let matchedUnit = match[3] || '';\n            /**\n             * @type{'' | keyof typeof absoluteLengths}\n             */\n\n            let units = matchedUnit; // convert absolute values to pixels\n\n            if (convertToPx && units !== '' && units in absoluteLengths) {\n              const pxNum = Number((absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision));\n\n              if (pxNum.toString().length < match[0].length) {\n                num = pxNum;\n                units = 'px';\n              }\n            } // and remove leading zero\n\n\n            let str;\n\n            if (leadingZero) {\n              str = removeLeadingZero(num);\n            } else {\n              str = num.toString();\n            } // remove default 'px' units\n\n\n            if (defaultPx && units === 'px') {\n              units = '';\n            }\n\n            node.attributes[name] = str + units;\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/cleanupNumericValues.js"],"names":["removeLeadingZero","require","exports","name","type","active","description","regNumericValues","absoluteLengths","cm","mm","in","pt","pc","px","fn","_root","params","floatPrecision","leadingZero","defaultPx","convertToPx","element","enter","node","attributes","viewBox","nums","split","map","value","num","Number","isNaN","toFixed","join","Object","entries","match","matchedUnit","units","pxNum","toString","length","str"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { removeLeadingZero } = require('../lib/svgo/tools');\n\nexports.name = 'cleanupNumericValues';\nexports.type = 'visitor';\nexports.active = true;\nexports.description =\n  'rounds numeric values to the fixed precision, removes default ‘px’ units';\n\nconst regNumericValues =\n  /^([-+]?\\d*\\.?\\d+([eE][-+]?\\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;\n\nconst absoluteLengths = {\n  // relative to px\n  cm: 96 / 2.54,\n  mm: 96 / 25.4,\n  in: 96,\n  pt: 4 / 3,\n  pc: 16,\n  px: 1,\n};\n\n/**\n * Round numeric values to the fixed precision,\n * remove default 'px' units.\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   floatPrecision?: number,\n *   leadingZero?: boolean,\n *   defaultPx?: boolean,\n *   convertToPx?: boolean\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    floatPrecision = 3,\n    leadingZero = true,\n    defaultPx = true,\n    convertToPx = true,\n  } = params;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (node.attributes.viewBox != null) {\n          const nums = node.attributes.viewBox.split(/\\s,?\\s*|,\\s*/g);\n          node.attributes.viewBox = nums\n            .map((value) => {\n              const num = Number(value);\n              return Number.isNaN(num)\n                ? value\n                : Number(num.toFixed(floatPrecision));\n            })\n            .join(' ');\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          // The `version` attribute is a text string and cannot be rounded\n          if (name === 'version') {\n            continue;\n          }\n\n          const match = value.match(regNumericValues);\n\n          // if attribute value matches regNumericValues\n          if (match) {\n            // round it to the fixed precision\n            let num = Number(Number(match[1]).toFixed(floatPrecision));\n            /**\n             * @type {any}\n             */\n            let matchedUnit = match[3] || '';\n            /**\n             * @type{'' | keyof typeof absoluteLengths}\n             */\n            let units = matchedUnit;\n\n            // convert absolute values to pixels\n            if (convertToPx && units !== '' && units in absoluteLengths) {\n              const pxNum = Number(\n                (absoluteLengths[units] * Number(match[1])).toFixed(\n                  floatPrecision\n                )\n              );\n              if (pxNum.toString().length < match[0].length) {\n                num = pxNum;\n                units = 'px';\n              }\n            }\n\n            // and remove leading zero\n            let str;\n            if (leadingZero) {\n              str = removeLeadingZero(num);\n            } else {\n              str = num.toString();\n            }\n\n            // remove default 'px' units\n            if (defaultPx && units === 'px') {\n              units = '';\n            }\n\n            node.attributes[name] = str + units;\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}