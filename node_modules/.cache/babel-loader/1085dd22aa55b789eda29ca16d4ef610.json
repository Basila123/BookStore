{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  parsePathData,\n  stringifyPathData\n} = require('../lib/path.js');\n/**\n * @type {[number, number]}\n */\n\n\nvar prevCtrlPoint;\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\n\nconst path2js = path => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n\n  const pathData = []; // JS representation of the path data\n\n  const newPathData = parsePathData(path.attributes.d);\n\n  for (const {\n    command,\n    args\n  } of newPathData) {\n    pathData.push({\n      command,\n      args\n    });\n  } // First moveto is actually absolute. Subsequent coordinates were separated above.\n\n\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  } // @ts-ignore legacy\n\n\n  path.pathJS = pathData;\n  return pathData;\n};\n\nexports.path2js = path2js;\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\n\nconst convertRelativeToAbsolute = data => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let {\n    command,\n    args\n  } of data) {\n    args = args.slice(); // moveto (x y)\n\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    } // horizontal lineto (x)\n\n\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n\n    if (command === 'H') {\n      cursor[0] = args[0];\n    } // vertical lineto (y)\n\n\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n\n    if (command === 'V') {\n      cursor[1] = args[0];\n    } // lineto (x y)\n\n\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    } // curveto (x1 y1 x2 y2 x y)\n\n\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    } // smooth curveto (x2 y2 x y)\n\n\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    } // quadratic Bézier curveto (x1 y1 x y)\n\n\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    } // smooth quadratic Bézier curveto (x y)\n\n\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    } // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n\n\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    } // closepath\n\n\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({\n      command,\n      args\n    });\n  }\n\n  return newData;\n};\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\n\n\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n  const pathData = [];\n\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (pathData.length !== 0 && (item.command === 'M' || item.command === 'm')) {\n      const last = pathData[pathData.length - 1];\n\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n\n    pathData.push({\n      command: item.command,\n      args: item.args\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags\n  });\n};\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\n\n\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\n\n\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2)); // Axis-aligned bounding box check.\n\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every(set1 => {\n    return points2.list.every(set2 => {\n      return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];\n    });\n  })) return false; // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull); // Check intersection of every subpath of the first path with every subpath of the second.\n\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n          // create the initial simplex\n      direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        } // add a new point\n\n\n        simplex.push(getSupport(hull1, hull2, direction)); // see if the new point was on the correct side of the origin\n\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false; // process the simplex\n\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  } // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n\n\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n        max = -Infinity,\n        value;\n\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\n\n\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n        b = simplex[0],\n        AO = minus(simplex[1]),\n        AB = sub(b, a); // AO is in the same direction as AB\n\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO); // only A remains in the simplex\n\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2],\n        // [a, b, c] = simplex\n    b = simplex[1],\n        c = simplex[0],\n        AB = sub(b, a),\n        AC = sub(c, a),\n        AO = minus(a),\n        ACB = orth(AB, AC),\n        // the vector perpendicular to AB facing away from C\n    ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n\n  return false;\n}\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\n\n\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\n\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\n\n\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\n\n\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = {\n    list: [],\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0\n  }; // Writes data about the extreme points on each axle\n\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];\n    }\n\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];\n    }\n\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath = points.list.length === 0 ? {\n      list: [],\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    } : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = {\n          list: [],\n          minX: 0,\n          minY: 0,\n          maxX: 0,\n          maxY: 0\n        };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n\n        break;\n\n      case 'T':\n        if (basePoint != null && prev != null && (prev.command == 'Q' || prev.command == 'T')) {\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [0.5 * (basePoint[0] + data[0]), 0.5 * (basePoint[1] + data[1])]);\n        }\n\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        addPoint(subPath, [0.5 * (data[2] + data[4]), 0.5 * (data[3] + data[5])]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n\n        break;\n\n      case 'S':\n        if (basePoint != null && prev != null && (prev.command == 'C' || prev.command == 'S')) {\n          addPoint(subPath, [basePoint[0] + 0.5 * prevCtrlPoint[0], basePoint[1] + 0.5 * prevCtrlPoint[1]]);\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        }\n\n        if (ctrlPoint != null) {\n          addPoint(subPath, [0.5 * (ctrlPoint[0] + data[0]), 0.5 * (ctrlPoint[1] + data[1])]);\n        }\n\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n\n          for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n            if (basePoint != null) {\n              addPoint(subPath, [0.5 * (basePoint[0] + cData[0]), 0.5 * (basePoint[1] + cData[1])]);\n            }\n\n            addPoint(subPath, [0.5 * (cData[0] + cData[2]), 0.5 * (cData[1] + cData[3])]);\n            addPoint(subPath, [0.5 * (cData[2] + cData[4]), 0.5 * (cData[3] + cData[5])]);\n            if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n          }\n        }\n\n        break;\n    } // Save final command coordinates\n\n\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\n\n\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n      minY = 0,\n      bottom = 0;\n\n  for (let i = 0; i < points.list.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {\n      lower.pop();\n    }\n\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n      maxY = points.list.length - 1,\n      top = 0;\n\n  for (let i = points.list.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {\n      upper.pop();\n    }\n\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n\n    upper.push(points.list[i]);\n  } // last points are equal to starting points of the other part\n\n\n  upper.pop();\n  lower.pop();\n  const hullList = lower.concat(upper);\n  /**\n   * @type {Point}\n   */\n\n  const hull = {\n    list: hullList,\n    minX: 0,\n    // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length\n  };\n  return hull;\n}\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\n\n\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\n\n\nconst a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = Math.PI * 120 / 180;\n\n  const rad = Math.PI / 180 * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n\n\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n        y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    var cx = k * rx * y / ry + (x1 + x2) / 2;\n    var cy = k * -ry * x / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n        x2old = x2,\n        y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n      s1 = Math.sin(f1),\n      c2 = Math.cos(f2),\n      s2 = Math.sin(f2),\n      t = Math.tan(df / 4),\n      hx = 4 / 3 * rx * t,\n      hy = 4 / 3 * ry * t,\n      m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n\n    return newres;\n  }\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/_path.js"],"names":["parsePathData","stringifyPathData","require","prevCtrlPoint","path2js","path","pathJS","pathData","newPathData","attributes","d","command","args","push","length","exports","convertRelativeToAbsolute","data","newData","start","cursor","slice","js2path","params","item","last","pop","precision","floatPrecision","disableSpaceAfterFlags","noSpaceAfterFlags","set","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","list","every","set1","set2","hullNest1","map","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","a","b","sub","supportPoint","polygon","index","max","Infinity","value","AO","AB","orth","shift","c","AC","ACB","ABC","splice","v","v1","v2","from","o","points","addPoint","point","Math","min","i","pathDataItem","subPath","prev","basePoint","ctrlPoint","toAbsolute","n","curves","a2c","apply","concat","cData","sort","lower","bottom","cross","upper","top","hullList","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","x","y","cos","sin","rotateY","h","sqrt","rx2","ry2","k","abs","cx","cy","f1","asin","Number","toFixed","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","t","tan","hx","hy","m","newres"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { parsePathData, stringifyPathData } = require('../lib/path.js');\n\n/**\n * @type {[number, number]}\n */\nvar prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\nconst path2js = (path) => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = []; // JS representation of the path data\n  const newPathData = parsePathData(path.attributes.d);\n  for (const { command, args } of newPathData) {\n    pathData.push({ command, args });\n  }\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  }\n  // @ts-ignore legacy\n  path.pathJS = pathData;\n  return pathData;\n};\nexports.path2js = path2js;\n\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\nconst convertRelativeToAbsolute = (data) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let { command, args } of data) {\n    args = args.slice();\n\n    // moveto (x y)\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n    if (command === 'H') {\n      cursor[0] = args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n    if (command === 'V') {\n      cursor[1] = args[0];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({ command, args });\n  }\n  return newData;\n};\n\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n\n  const pathData = [];\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (\n      pathData.length !== 0 &&\n      (item.command === 'M' || item.command === 'm')\n    ) {\n      const last = pathData[pathData.length - 1];\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n    pathData.push({\n      command: item.command,\n      args: item.args,\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags,\n  });\n};\n\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2));\n\n  // Axis-aligned bounding box check.\n  if (\n    points1.maxX <= points2.minX ||\n    points2.maxX <= points1.minX ||\n    points1.maxY <= points2.minY ||\n    points2.maxY <= points1.minY ||\n    points1.list.every((set1) => {\n      return points2.list.every((set2) => {\n        return (\n          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||\n          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||\n          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||\n          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]\n        );\n      });\n    })\n  )\n    return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n\n      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error(\n            'Error: infinite loop while processing mergePaths plugin.'\n          );\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n  function supportPoint(polygon, direction) {\n    var index =\n        direction[1] >= 0\n          ? direction[0] < 0\n            ? polygon.maxY\n            : polygon.maxX\n          : direction[0] < 0\n          ? polygon.minX\n          : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2], // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n  return false;\n}\n\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\n  // Writes data about the extreme points on each axle\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length\n        ? Math.max(point[1], points.maxY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length\n        ? Math.max(point[0], points.maxX)\n        : point[0];\n    }\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length\n        ? Math.min(point[1], points.minY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length\n        ? Math.min(point[0], points.minX)\n        : point[0];\n    }\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath =\n      points.list.length === 0\n        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }\n        : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint =\n      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n        break;\n\n      case 'T':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'Q' || prev.command == 'T')\n        ) {\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [\n            0.5 * (basePoint[0] + data[0]),\n            0.5 * (basePoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        addPoint(subPath, [\n          0.5 * (data[2] + data[4]),\n          0.5 * (data[3] + data[5]),\n        ]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n        break;\n\n      case 'S':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'C' || prev.command == 'S')\n        ) {\n          addPoint(subPath, [\n            basePoint[0] + 0.5 * prevCtrlPoint[0],\n            basePoint[1] + 0.5 * prevCtrlPoint[1],\n          ]);\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n        }\n        if (ctrlPoint != null) {\n          addPoint(subPath, [\n            0.5 * (ctrlPoint[0] + data[0]),\n            0.5 * (ctrlPoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n          for (\n            var cData;\n            (cData = curves.splice(0, 6).map(toAbsolute)).length;\n\n          ) {\n            if (basePoint != null) {\n              addPoint(subPath, [\n                0.5 * (basePoint[0] + cData[0]),\n                0.5 * (basePoint[1] + cData[1]),\n              ]);\n            }\n            addPoint(subPath, [\n              0.5 * (cData[0] + cData[2]),\n              0.5 * (cData[1] + cData[3]),\n            ]);\n            addPoint(subPath, [\n              0.5 * (cData[2] + cData[4]),\n              0.5 * (cData[3] + cData[5]),\n            ]);\n            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));\n          }\n        }\n        break;\n    }\n\n    // Save final command coordinates\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (let i = 0; i < points.list.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=\n        0\n    ) {\n      lower.pop();\n    }\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n    maxY = points.list.length - 1,\n    top = 0;\n  for (let i = points.list.length; i--; ) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=\n        0\n    ) {\n      upper.pop();\n    }\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points.list[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n\n  const hullList = lower.concat(upper);\n\n  /**\n   * @type {Point}\n   */\n  const hull = {\n    list: hullList,\n    minX: 0, // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length,\n  };\n\n  return hull;\n}\n\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\nconst a2c = (\n  x1,\n  y1,\n  rx,\n  ry,\n  angle,\n  large_arc_flag,\n  sweep_flag,\n  x2,\n  y2,\n  recursive\n) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = (Math.PI * 120) / 180;\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k =\n      (large_arc_flag == sweep_flag ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)\n        )\n      );\n    var cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = (4 / 3) * rx * t,\n    hy = (4 / 3) * ry * t,\n    m = [\n      -hx * s1,\n      hy * c1,\n      x2 + hx * s2 - x1,\n      y2 - hy * c2 - y1,\n      x2 - x1,\n      y2 - y1,\n    ];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] =\n        i % 2\n          ? rotateY(res[i - 1], res[i], rad)\n          : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}