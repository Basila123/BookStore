{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7\n};\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\n\nconst isCommand = c => {\n  return c in argsCountPerCommand;\n};\n/**\n * @type {(c: string) => boolean}\n */\n\n\nconst isWsp = c => {\n  const codePoint = c.codePointAt(0);\n  return codePoint === 0x20 || codePoint === 0x9 || codePoint === 0xd || codePoint === 0xa;\n};\n/**\n * @type {(c: string) => boolean}\n */\n\n\nconst isDigit = c => {\n  const codePoint = c.codePointAt(0);\n\n  if (codePoint == null) {\n    return false;\n  }\n\n  return 48 <= codePoint && codePoint <= 57;\n};\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, number | null]}\n */\n\n\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state =\n  /** @type {ReadNumberState} */\n  'none';\n\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n\n    if (c === 'E' || c == 'e') {\n      if (state === 'whole' || state === 'decimal_point' || state === 'decimal') {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  const number = Number.parseFloat(value);\n\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n/**\n * @type {(string: string) => Array<PathDataItem>}\n */\n\n\nconst parsePathData = string => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = [];\n  /**\n   * @type {null | PathDataCommand}\n   */\n\n  let command = null;\n  let args =\n  /** @type {number[]} */\n  [];\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n\n    if (isWsp(c)) {\n      continue;\n    } // allow comma only between arguments\n\n\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n\n      hadComma = true;\n      continue;\n    }\n\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false; // flush command without arguments\n\n      if (argsCount === 0) {\n        pathData.push({\n          command,\n          args\n        });\n      }\n\n      continue;\n    } // avoid parsing arguments if no command detected\n\n\n    if (command == null) {\n      return pathData;\n    } // read next argument\n\n\n    let newCursor = i;\n    let number = null;\n\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n\n    if (number == null) {\n      return pathData;\n    }\n\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor; // flush arguments when necessary count is reached\n\n    if (args.length === argsCount) {\n      pathData.push({\n        command,\n        args\n      }); // subsequent moveto coordinates are threated as implicit lineto commands\n\n      if (command === 'M') {\n        command = 'L';\n      }\n\n      if (command === 'm') {\n        command = 'l';\n      }\n\n      args = [];\n    }\n  }\n\n  return pathData;\n};\n\nexports.parsePathData = parsePathData;\n/**\n * @type {(number: number, precision?: number) => string}\n */\n\nconst stringifyNumber = (number, precision) => {\n  if (precision != null) {\n    const ratio = 10 ** precision;\n    number = Math.round(number * ratio) / ratio;\n  } // remove zero whole from decimal number\n\n\n  return number.toString().replace(/^0\\./, '.').replace(/^-0\\./, '-.');\n};\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\n\n\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let prev = '';\n\n  for (let i = 0; i < args.length; i += 1) {\n    const number = args[i];\n    const numberString = stringifyNumber(number, precision);\n\n    if (disableSpaceAfterFlags && (command === 'A' || command === 'a') && ( // consider combined arcs\n    i % 7 === 4 || i % 7 === 5)) {\n      result += numberString;\n    } else if (i === 0 || numberString.startsWith('-')) {\n      // avoid space before first and negative numbers\n      result += numberString;\n    } else if (prev.includes('.') && numberString.startsWith('.')) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += numberString;\n    } else {\n      result += ` ${numberString}`;\n    }\n\n    prev = numberString;\n  }\n\n  return result;\n};\n/**\n * @typedef {{\n *   pathData: Array<PathDataItem>;\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @type {(options: StringifyPathDataOptions) => string}\n */\n\n\nconst stringifyPathData = _ref => {\n  let {\n    pathData,\n    precision,\n    disableSpaceAfterFlags\n  } = _ref;\n  // combine sequence of the same commands\n  let combined = [];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const {\n      command,\n      args\n    } = pathData[i];\n\n    if (i === 0) {\n      combined.push({\n        command,\n        args\n      });\n    } else {\n      /**\n       * @type {PathDataItem}\n       */\n      const last = combined[combined.length - 1]; // match leading moveto with following lineto\n\n      if (i === 1) {\n        if (command === 'L') {\n          last.command = 'M';\n        }\n\n        if (command === 'l') {\n          last.command = 'm';\n        }\n      }\n\n      if (last.command === command && last.command !== 'M' && last.command !== 'm' || // combine matching moveto and lineto sequences\n      last.command === 'M' && command === 'L' || last.command === 'm' && command === 'l') {\n        last.args = [...last.args, ...args];\n      } else {\n        combined.push({\n          command,\n          args\n        });\n      }\n    }\n  }\n\n  let result = '';\n\n  for (const {\n    command,\n    args\n  } of combined) {\n    result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n\n  return result;\n};\n\nexports.stringifyPathData = stringifyPathData;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/lib/path.js"],"names":["argsCountPerCommand","M","m","Z","z","L","l","H","h","V","v","C","c","S","s","Q","q","T","t","A","a","isCommand","isWsp","codePoint","codePointAt","isDigit","readNumber","string","cursor","i","value","state","length","number","Number","parseFloat","isNaN","parsePathData","pathData","command","args","argsCount","canHaveComma","hadComma","charAt","push","newCursor","position","exports","stringifyNumber","precision","ratio","Math","round","toString","replace","stringifyArgs","disableSpaceAfterFlags","result","prev","numberString","startsWith","includes","stringifyPathData","combined","last"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7,\n};\n\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\nconst isCommand = (c) => {\n  return c in argsCountPerCommand;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isWsp = (c) => {\n  const codePoint = c.codePointAt(0);\n  return (\n    codePoint === 0x20 ||\n    codePoint === 0x9 ||\n    codePoint === 0xd ||\n    codePoint === 0xa\n  );\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isDigit = (c) => {\n  const codePoint = c.codePointAt(0);\n  if (codePoint == null) {\n    return false;\n  }\n  return 48 <= codePoint && codePoint <= 57;\n};\n\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, number | null]}\n */\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state = /** @type {ReadNumberState} */ ('none');\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n    if (c === 'E' || c == 'e') {\n      if (\n        state === 'whole' ||\n        state === 'decimal_point' ||\n        state === 'decimal'\n      ) {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n    break;\n  }\n  const number = Number.parseFloat(value);\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n\n/**\n * @type {(string: string) => Array<PathDataItem>}\n */\nconst parsePathData = (string) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = [];\n  /**\n   * @type {null | PathDataCommand}\n   */\n  let command = null;\n  let args = /** @type {number[]} */ ([]);\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n    if (isWsp(c)) {\n      continue;\n    }\n    // allow comma only between arguments\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n      hadComma = true;\n      continue;\n    }\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false;\n      // flush command without arguments\n      if (argsCount === 0) {\n        pathData.push({ command, args });\n      }\n      continue;\n    }\n    // avoid parsing arguments if no command detected\n    if (command == null) {\n      return pathData;\n    }\n    // read next argument\n    let newCursor = i;\n    let number = null;\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n    if (number == null) {\n      return pathData;\n    }\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor;\n    // flush arguments when necessary count is reached\n    if (args.length === argsCount) {\n      pathData.push({ command, args });\n      // subsequent moveto coordinates are threated as implicit lineto commands\n      if (command === 'M') {\n        command = 'L';\n      }\n      if (command === 'm') {\n        command = 'l';\n      }\n      args = [];\n    }\n  }\n  return pathData;\n};\nexports.parsePathData = parsePathData;\n\n/**\n * @type {(number: number, precision?: number) => string}\n */\nconst stringifyNumber = (number, precision) => {\n  if (precision != null) {\n    const ratio = 10 ** precision;\n    number = Math.round(number * ratio) / ratio;\n  }\n  // remove zero whole from decimal number\n  return number.toString().replace(/^0\\./, '.').replace(/^-0\\./, '-.');\n};\n\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let prev = '';\n  for (let i = 0; i < args.length; i += 1) {\n    const number = args[i];\n    const numberString = stringifyNumber(number, precision);\n    if (\n      disableSpaceAfterFlags &&\n      (command === 'A' || command === 'a') &&\n      // consider combined arcs\n      (i % 7 === 4 || i % 7 === 5)\n    ) {\n      result += numberString;\n    } else if (i === 0 || numberString.startsWith('-')) {\n      // avoid space before first and negative numbers\n      result += numberString;\n    } else if (prev.includes('.') && numberString.startsWith('.')) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += numberString;\n    } else {\n      result += ` ${numberString}`;\n    }\n    prev = numberString;\n  }\n  return result;\n};\n\n/**\n * @typedef {{\n *   pathData: Array<PathDataItem>;\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @type {(options: StringifyPathDataOptions) => string}\n */\nconst stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {\n  // combine sequence of the same commands\n  let combined = [];\n  for (let i = 0; i < pathData.length; i += 1) {\n    const { command, args } = pathData[i];\n    if (i === 0) {\n      combined.push({ command, args });\n    } else {\n      /**\n       * @type {PathDataItem}\n       */\n      const last = combined[combined.length - 1];\n      // match leading moveto with following lineto\n      if (i === 1) {\n        if (command === 'L') {\n          last.command = 'M';\n        }\n        if (command === 'l') {\n          last.command = 'm';\n        }\n      }\n      if (\n        (last.command === command &&\n          last.command !== 'M' &&\n          last.command !== 'm') ||\n        // combine matching moveto and lineto sequences\n        (last.command === 'M' && command === 'L') ||\n        (last.command === 'm' && command === 'l')\n      ) {\n        last.args = [...last.args, ...args];\n      } else {\n        combined.push({ command, args });\n      }\n    }\n  }\n  let result = '';\n  for (const { command, args } of combined) {\n    result +=\n      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n  return result;\n};\nexports.stringifyPathData = stringifyPathData;\n"]},"metadata":{},"sourceType":"script"}