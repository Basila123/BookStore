{"ast":null,"code":"'use strict';\n\nexports.type = 'visitor';\nexports.name = 'sortAttrs';\nexports.active = false;\nexports.description = 'Sort element attributes for better compression';\n/**\n * Sort element attributes for better compression\n *\n * @author Nikolay Frantsev\n *\n * @type {import('../lib/types').Plugin<{\n *   order?: Array<string>\n *   xmlnsOrder?: 'front' | 'alphabetical'\n * }>}\n */\n\nexports.fn = (_root, params) => {\n  const {\n    order = ['id', 'width', 'height', 'x', 'x1', 'x2', 'y', 'y1', 'y2', 'cx', 'cy', 'r', 'fill', 'stroke', 'marker', 'd', 'points'],\n    xmlnsOrder = 'front'\n  } = params;\n  /**\n   * @type {(name: string) => number}\n   */\n\n  const getNsPriority = name => {\n    if (xmlnsOrder === 'front') {\n      // put xmlns first\n      if (name === 'xmlns') {\n        return 3;\n      } // xmlns:* attributes second\n\n\n      if (name.startsWith('xmlns:')) {\n        return 2;\n      }\n    } // other namespaces after and sort them alphabetically\n\n\n    if (name.includes(':')) {\n      return 1;\n    } // other attributes\n\n\n    return 0;\n  };\n  /**\n   * @type {(a: [string, string], b: [string, string]) => number}\n   */\n\n\n  const compareAttrs = (_ref, _ref2) => {\n    let [aName] = _ref;\n    let [bName] = _ref2;\n    // sort namespaces\n    const aPriority = getNsPriority(aName);\n    const bPriority = getNsPriority(bName);\n    const priorityNs = bPriority - aPriority;\n\n    if (priorityNs !== 0) {\n      return priorityNs;\n    } // extract the first part from attributes\n    // for example \"fill\" from \"fill\" and \"fill-opacity\"\n\n\n    const [aPart] = aName.split('-');\n    const [bPart] = bName.split('-'); // rely on alphabetical sort when the first part is the same\n\n    if (aPart !== bPart) {\n      const aInOrderFlag = order.includes(aPart) ? 1 : 0;\n      const bInOrderFlag = order.includes(bPart) ? 1 : 0; // sort by position in order param\n\n      if (aInOrderFlag === 1 && bInOrderFlag === 1) {\n        return order.indexOf(aPart) - order.indexOf(bPart);\n      } // put attributes from order param before others\n\n\n      const priorityOrder = bInOrderFlag - aInOrderFlag;\n\n      if (priorityOrder !== 0) {\n        return priorityOrder;\n      }\n    } // sort alphabetically\n\n\n    return aName < bName ? -1 : 1;\n  };\n\n  return {\n    element: {\n      enter: node => {\n        const attrs = Object.entries(node.attributes);\n        attrs.sort(compareAttrs);\n        /**\n         * @type {Record<string, string>}\n         */\n\n        const sortedAttributes = {};\n\n        for (const [name, value] of attrs) {\n          sortedAttributes[name] = value;\n        }\n\n        node.attributes = sortedAttributes;\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/sortAttrs.js"],"names":["exports","type","name","active","description","fn","_root","params","order","xmlnsOrder","getNsPriority","startsWith","includes","compareAttrs","aName","bName","aPriority","bPriority","priorityNs","aPart","split","bPart","aInOrderFlag","bInOrderFlag","indexOf","priorityOrder","element","enter","node","attrs","Object","entries","attributes","sort","sortedAttributes","value"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.type = 'visitor';\nexports.name = 'sortAttrs';\nexports.active = false;\nexports.description = 'Sort element attributes for better compression';\n\n/**\n * Sort element attributes for better compression\n *\n * @author Nikolay Frantsev\n *\n * @type {import('../lib/types').Plugin<{\n *   order?: Array<string>\n *   xmlnsOrder?: 'front' | 'alphabetical'\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    order = [\n      'id',\n      'width',\n      'height',\n      'x',\n      'x1',\n      'x2',\n      'y',\n      'y1',\n      'y2',\n      'cx',\n      'cy',\n      'r',\n      'fill',\n      'stroke',\n      'marker',\n      'd',\n      'points',\n    ],\n    xmlnsOrder = 'front',\n  } = params;\n\n  /**\n   * @type {(name: string) => number}\n   */\n  const getNsPriority = (name) => {\n    if (xmlnsOrder === 'front') {\n      // put xmlns first\n      if (name === 'xmlns') {\n        return 3;\n      }\n      // xmlns:* attributes second\n      if (name.startsWith('xmlns:')) {\n        return 2;\n      }\n    }\n    // other namespaces after and sort them alphabetically\n    if (name.includes(':')) {\n      return 1;\n    }\n    // other attributes\n    return 0;\n  };\n\n  /**\n   * @type {(a: [string, string], b: [string, string]) => number}\n   */\n  const compareAttrs = ([aName], [bName]) => {\n    // sort namespaces\n    const aPriority = getNsPriority(aName);\n    const bPriority = getNsPriority(bName);\n    const priorityNs = bPriority - aPriority;\n    if (priorityNs !== 0) {\n      return priorityNs;\n    }\n    // extract the first part from attributes\n    // for example \"fill\" from \"fill\" and \"fill-opacity\"\n    const [aPart] = aName.split('-');\n    const [bPart] = bName.split('-');\n    // rely on alphabetical sort when the first part is the same\n    if (aPart !== bPart) {\n      const aInOrderFlag = order.includes(aPart) ? 1 : 0;\n      const bInOrderFlag = order.includes(bPart) ? 1 : 0;\n      // sort by position in order param\n      if (aInOrderFlag === 1 && bInOrderFlag === 1) {\n        return order.indexOf(aPart) - order.indexOf(bPart);\n      }\n      // put attributes from order param before others\n      const priorityOrder = bInOrderFlag - aInOrderFlag;\n      if (priorityOrder !== 0) {\n        return priorityOrder;\n      }\n    }\n    // sort alphabetically\n    return aName < bName ? -1 : 1;\n  };\n\n  return {\n    element: {\n      enter: (node) => {\n        const attrs = Object.entries(node.attributes);\n        attrs.sort(compareAttrs);\n        /**\n         * @type {Record<string, string>}\n         */\n        const sortedAttributes = {};\n        for (const [name, value] of attrs) {\n          sortedAttributes[name] = value;\n        }\n        node.attributes = sortedAttributes;\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}