{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n/*\n * Constants (parser usage)\n */\n\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = {\n  type: C_ESCAPED_SINGLE_QUOTE,\n  value: `\\\\'`\n};\nconst T_ESCAPED_DOUBLE_QUOTE = {\n  type: C_ESCAPED_DOUBLE_QUOTE,\n  value: `\\\\\"`\n};\nconst T_SINGLE_QUOTE = {\n  type: C_SINGLE_QUOTE,\n  value: L_SINGLE_QUOTE\n};\nconst T_DOUBLE_QUOTE = {\n  type: C_DOUBLE_QUOTE,\n  value: L_DOUBLE_QUOTE\n};\nconst T_NEWLINE = {\n  type: C_NEWLINE,\n  value: L_NEWLINE\n};\n\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, _ref) => {\n    let {\n      value\n    } = _ref;\n\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0\n    },\n    quotes: false\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next)\n        });\n        pos = next - 1;\n        break;\n\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n        ast.nodes.push({\n          type: C_STRING,\n          value\n        });\n        pos = next;\n    }\n\n    pos++;\n  }\n\n  return ast;\n}\n\nfunction changeWrappingQuotes(node, ast) {\n  const {\n    types\n  } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = changeChildQuotes(ast.nodes, node.quote);\n}\n/**\n * @param {string} parentQuote\n */\n\n\nfunction changeChildQuotes(childNodes, parentQuote) {\n  const updatedChildren = [];\n\n  for (const child of childNodes) {\n    if (child.type === C_ESCAPED_DOUBLE_QUOTE && parentQuote === L_SINGLE_QUOTE) {\n      updatedChildren.push(T_DOUBLE_QUOTE);\n    } else if (child.type === C_ESCAPED_SINGLE_QUOTE && parentQuote === L_DOUBLE_QUOTE) {\n      updatedChildren.push(T_SINGLE_QUOTE);\n    } else {\n      updatedChildren.push(child);\n    }\n  }\n\n  return updatedChildren;\n}\n\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return valueParser(value).walk(child => {\n    if (child.type !== C_STRING) {\n      return;\n    }\n\n    const ast = parse(child.value);\n\n    if (ast.quotes) {\n      changeWrappingQuotes(child, ast);\n    } else if (preferredQuote === C_SINGLE) {\n      child.quote = L_SINGLE_QUOTE;\n    } else {\n      child.quote = L_DOUBLE_QUOTE;\n    }\n\n    child.value = stringify(ast);\n  }).toString();\n}\n\nfunction minify(original, cache, preferredQuote) {\n  const key = original + '|' + preferredQuote;\n\n  if (cache.has(key)) {\n    return cache.get(key);\n  }\n\n  const newValue = normalize(original, preferredQuote);\n  cache.set(key, newValue);\n  return newValue;\n}\n\nfunction pluginCreator(opts) {\n  const {\n    preferredQuote\n  } = Object.assign({}, {\n    preferredQuote: 'double'\n  }, opts);\n  return {\n    postcssPlugin: 'postcss-normalize-string',\n\n    OnceExit(css) {\n      const cache = new Map();\n      css.walk(node => {\n        switch (node.type) {\n          case 'rule':\n            node.selector = minify(node.selector, cache, preferredQuote);\n            break;\n\n          case 'decl':\n            node.value = minify(node.value, cache, preferredQuote);\n            break;\n\n          case 'atrule':\n            node.params = minify(node.params, cache, preferredQuote);\n            break;\n        }\n      });\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-normalize-string/src/index.js"],"names":["valueParser","require","SINGLE_QUOTE","charCodeAt","DOUBLE_QUOTE","BACKSLASH","NEWLINE","SPACE","FEED","TAB","CR","WORD_END","C_STRING","C_ESCAPED_SINGLE_QUOTE","C_ESCAPED_DOUBLE_QUOTE","C_SINGLE_QUOTE","C_DOUBLE_QUOTE","C_NEWLINE","C_SINGLE","L_SINGLE_QUOTE","L_DOUBLE_QUOTE","L_NEWLINE","T_ESCAPED_SINGLE_QUOTE","type","value","T_ESCAPED_DOUBLE_QUOTE","T_SINGLE_QUOTE","T_DOUBLE_QUOTE","T_NEWLINE","stringify","ast","nodes","reduce","str","parse","code","next","pos","len","length","types","escapedSingleQuote","escapedDoubleQuote","singleQuote","doubleQuote","quotes","push","slice","lastIndex","test","changeWrappingQuotes","node","quote","changeChildQuotes","childNodes","parentQuote","updatedChildren","child","normalize","preferredQuote","walk","toString","minify","original","cache","key","has","get","newValue","set","pluginCreator","opts","Object","assign","postcssPlugin","OnceExit","css","Map","selector","params","postcss","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\n\n/*\n * Constants (parser usage)\n */\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\n\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\\\'` };\nconst T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\\\\"` };\nconst T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };\nconst T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };\nconst T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };\n\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, { value }) => {\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0,\n    },\n    quotes: false,\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        );\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next),\n        });\n        pos = next - 1;\n        break;\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n\n        ast.nodes.push({\n          type: C_STRING,\n          value,\n        });\n\n        pos = next;\n    }\n    pos++;\n  }\n\n  return ast;\n}\n\nfunction changeWrappingQuotes(node, ast) {\n  const { types } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (\n    node.quote === L_SINGLE_QUOTE &&\n    types[C_ESCAPED_SINGLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_DOUBLE_QUOTE]\n  ) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (\n    node.quote === L_DOUBLE_QUOTE &&\n    types[C_ESCAPED_DOUBLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_SINGLE_QUOTE]\n  ) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = changeChildQuotes(ast.nodes, node.quote);\n}\n/**\n * @param {string} parentQuote\n */\nfunction changeChildQuotes(childNodes, parentQuote) {\n  const updatedChildren = [];\n  for (const child of childNodes) {\n    if (\n      child.type === C_ESCAPED_DOUBLE_QUOTE &&\n      parentQuote === L_SINGLE_QUOTE\n    ) {\n      updatedChildren.push(T_DOUBLE_QUOTE);\n    } else if (\n      child.type === C_ESCAPED_SINGLE_QUOTE &&\n      parentQuote === L_DOUBLE_QUOTE\n    ) {\n      updatedChildren.push(T_SINGLE_QUOTE);\n    } else {\n      updatedChildren.push(child);\n    }\n  }\n  return updatedChildren;\n}\n\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return valueParser(value)\n    .walk((child) => {\n      if (child.type !== C_STRING) {\n        return;\n      }\n\n      const ast = parse(child.value);\n\n      if (ast.quotes) {\n        changeWrappingQuotes(child, ast);\n      } else if (preferredQuote === C_SINGLE) {\n        child.quote = L_SINGLE_QUOTE;\n      } else {\n        child.quote = L_DOUBLE_QUOTE;\n      }\n\n      child.value = stringify(ast);\n    })\n    .toString();\n}\n\nfunction minify(original, cache, preferredQuote) {\n  const key = original + '|' + preferredQuote;\n  if (cache.has(key)) {\n    return cache.get(key);\n  }\n  const newValue = normalize(original, preferredQuote);\n  cache.set(key, newValue);\n  return newValue;\n}\n\nfunction pluginCreator(opts) {\n  const { preferredQuote } = Object.assign(\n    {},\n    {\n      preferredQuote: 'double',\n    },\n    opts\n  );\n\n  return {\n    postcssPlugin: 'postcss-normalize-string',\n\n    OnceExit(css) {\n      const cache = new Map();\n\n      css.walk((node) => {\n        switch (node.type) {\n          case 'rule':\n            node.selector = minify(node.selector, cache, preferredQuote);\n            break;\n          case 'decl':\n            node.value = minify(node.value, cache, preferredQuote);\n            break;\n          case 'atrule':\n            node.params = minify(node.params, cache, preferredQuote);\n            break;\n        }\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]},"metadata":{},"sourceType":"script"}