{"ast":null,"code":"'use strict';\n\nconst hasAllProps = require('./hasAllProps');\n\nconst getDecls = require('./getDecls');\n\nconst getRules = require('./getRules');\n\nfunction isConflictingProp(propA, propB) {\n  if (!propB.prop || propB.important !== propA.important) {\n    return;\n  }\n\n  const parts = propA.prop.split('-');\n  return parts.some(() => {\n    parts.pop();\n    return parts.join('-') === propB.prop;\n  });\n}\n\nfunction hasConflicts(match, nodes) {\n  const firstNode = Math.min.apply(null, match.map(n => nodes.indexOf(n)));\n  const lastNode = Math.max.apply(null, match.map(n => nodes.indexOf(n)));\n  const between = nodes.slice(firstNode + 1, lastNode);\n  return match.some(a => between.some(b => isConflictingProp(a, b)));\n}\n\nmodule.exports = function mergeRules(rule, properties, callback) {\n  let decls = getDecls(rule, properties);\n\n  while (decls.length) {\n    const last = decls[decls.length - 1];\n    const props = decls.filter(node => node.important === last.important);\n    const rules = getRules(props, properties);\n\n    if (hasAllProps(rules, ...properties) && !hasConflicts(rules, rule.nodes)) {\n      if (callback(rules, last, props)) {\n        decls = decls.filter(node => !rules.includes(node));\n      }\n    }\n\n    decls = decls.filter(node => node !== last);\n  }\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-merge-longhand/src/lib/mergeRules.js"],"names":["hasAllProps","require","getDecls","getRules","isConflictingProp","propA","propB","prop","important","parts","split","some","pop","join","hasConflicts","match","nodes","firstNode","Math","min","apply","map","n","indexOf","lastNode","max","between","slice","a","b","module","exports","mergeRules","rule","properties","callback","decls","length","last","props","filter","node","rules","includes"],"mappings":"AAAA;;AACA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAxB;;AAEA,SAASG,iBAAT,CAA2BC,KAA3B,EAAkCC,KAAlC,EAAyC;AACvC,MAAI,CAACA,KAAK,CAACC,IAAP,IAAeD,KAAK,CAACE,SAAN,KAAoBH,KAAK,CAACG,SAA7C,EAAwD;AACtD;AACD;;AAED,QAAMC,KAAK,GAAGJ,KAAK,CAACE,IAAN,CAAWG,KAAX,CAAiB,GAAjB,CAAd;AAEA,SAAOD,KAAK,CAACE,IAAN,CAAW,MAAM;AACtBF,IAAAA,KAAK,CAACG,GAAN;AAEA,WAAOH,KAAK,CAACI,IAAN,CAAW,GAAX,MAAoBP,KAAK,CAACC,IAAjC;AACD,GAJM,CAAP;AAKD;;AAED,SAASO,YAAT,CAAsBC,KAAtB,EAA6BC,KAA7B,EAAoC;AAClC,QAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASC,KAAT,CAChB,IADgB,EAEhBL,KAAK,CAACM,GAAN,CAAWC,CAAD,IAAON,KAAK,CAACO,OAAN,CAAcD,CAAd,CAAjB,CAFgB,CAAlB;AAIA,QAAME,QAAQ,GAAGN,IAAI,CAACO,GAAL,CAASL,KAAT,CACf,IADe,EAEfL,KAAK,CAACM,GAAN,CAAWC,CAAD,IAAON,KAAK,CAACO,OAAN,CAAcD,CAAd,CAAjB,CAFe,CAAjB;AAIA,QAAMI,OAAO,GAAGV,KAAK,CAACW,KAAN,CAAYV,SAAS,GAAG,CAAxB,EAA2BO,QAA3B,CAAhB;AAEA,SAAOT,KAAK,CAACJ,IAAN,CAAYiB,CAAD,IAAOF,OAAO,CAACf,IAAR,CAAckB,CAAD,IAAOzB,iBAAiB,CAACwB,CAAD,EAAIC,CAAJ,CAArC,CAAlB,CAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBC,IAApB,EAA0BC,UAA1B,EAAsCC,QAAtC,EAAgD;AAC/D,MAAIC,KAAK,GAAGlC,QAAQ,CAAC+B,IAAD,EAAOC,UAAP,CAApB;;AAEA,SAAOE,KAAK,CAACC,MAAb,EAAqB;AACnB,UAAMC,IAAI,GAAGF,KAAK,CAACA,KAAK,CAACC,MAAN,GAAe,CAAhB,CAAlB;AACA,UAAME,KAAK,GAAGH,KAAK,CAACI,MAAN,CAAcC,IAAD,IAAUA,IAAI,CAACjC,SAAL,KAAmB8B,IAAI,CAAC9B,SAA/C,CAAd;AACA,UAAMkC,KAAK,GAAGvC,QAAQ,CAACoC,KAAD,EAAQL,UAAR,CAAtB;;AAEA,QAAIlC,WAAW,CAAC0C,KAAD,EAAQ,GAAGR,UAAX,CAAX,IAAqC,CAACpB,YAAY,CAAC4B,KAAD,EAAQT,IAAI,CAACjB,KAAb,CAAtD,EAA2E;AACzE,UAAImB,QAAQ,CAACO,KAAD,EAAQJ,IAAR,EAAcC,KAAd,CAAZ,EAAkC;AAChCH,QAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAcC,IAAD,IAAU,CAACC,KAAK,CAACC,QAAN,CAAeF,IAAf,CAAxB,CAAR;AACD;AACF;;AAEDL,IAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAcC,IAAD,IAAUA,IAAI,KAAKH,IAAhC,CAAR;AACD;AACF,CAhBD","sourcesContent":["'use strict';\nconst hasAllProps = require('./hasAllProps');\nconst getDecls = require('./getDecls');\nconst getRules = require('./getRules');\n\nfunction isConflictingProp(propA, propB) {\n  if (!propB.prop || propB.important !== propA.important) {\n    return;\n  }\n\n  const parts = propA.prop.split('-');\n\n  return parts.some(() => {\n    parts.pop();\n\n    return parts.join('-') === propB.prop;\n  });\n}\n\nfunction hasConflicts(match, nodes) {\n  const firstNode = Math.min.apply(\n    null,\n    match.map((n) => nodes.indexOf(n))\n  );\n  const lastNode = Math.max.apply(\n    null,\n    match.map((n) => nodes.indexOf(n))\n  );\n  const between = nodes.slice(firstNode + 1, lastNode);\n\n  return match.some((a) => between.some((b) => isConflictingProp(a, b)));\n}\n\nmodule.exports = function mergeRules(rule, properties, callback) {\n  let decls = getDecls(rule, properties);\n\n  while (decls.length) {\n    const last = decls[decls.length - 1];\n    const props = decls.filter((node) => node.important === last.important);\n    const rules = getRules(props, properties);\n\n    if (hasAllProps(rules, ...properties) && !hasConflicts(rules, rule.nodes)) {\n      if (callback(rules, last, props)) {\n        decls = decls.filter((node) => !rules.includes(node));\n      }\n    }\n\n    decls = decls.filter((node) => node !== last);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}