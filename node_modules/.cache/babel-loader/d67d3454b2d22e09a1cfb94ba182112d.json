{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nconst {\n  parsePathData\n} = require('../lib/path.js');\n\nconst {\n  intersects\n} = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'removeOffCanvasPaths';\nexports.active = false;\nexports.description = 'removes elements that are drawn outside of the viewbox (disabled by default)';\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('../lib/types').Plugin<void>}\n */\n\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = ''; // find viewbox\n\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (node.attributes.height != null && node.attributes.width != null) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          } // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n\n\n          viewBox = viewBox.replace(/[,+]|px/g, ' ').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, ''); // ensure that the dimensions are 4 values separated by space\n\n          const m = /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBox);\n\n          if (m == null) {\n            return;\n          }\n\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]); // store the viewBox boundaries\n\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height\n          };\n        } // consider that any item with a transform attribute is visible\n\n\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (node.name === 'path' && node.attributes.d != null && viewBoxData != null) {\n          const pathData = parsePathData(node.attributes.d); // consider that a M command within the viewBox is visible\n\n          let visible = false;\n\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n\n              if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {\n                visible = true;\n              }\n            }\n          }\n\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n\n          const {\n            left,\n            top,\n            width,\n            height\n          } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const viewBoxPathData = [{\n            command: 'M',\n            args: [left, top]\n          }, {\n            command: 'h',\n            args: [width]\n          }, {\n            command: 'v',\n            args: [height]\n          }, {\n            command: 'H',\n            args: [left]\n          }, {\n            command: 'z',\n            args: []\n          }];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-svgo/node_modules/svgo/plugins/removeOffCanvasPaths.js"],"names":["visitSkip","detachNodeFromParent","require","parsePathData","intersects","exports","type","name","active","description","fn","viewBoxData","element","enter","node","parentNode","viewBox","attributes","height","width","replace","m","exec","left","Number","parseFloat","top","right","bottom","transform","d","pathData","visible","pathDataItem","command","x","y","args","length","push","viewBoxPathData"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { parsePathData } = require('../lib/path.js');\nconst { intersects } = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'removeOffCanvasPaths';\nexports.active = false;\nexports.description =\n  'removes elements that are drawn outside of the viewbox (disabled by default)';\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('../lib/types').Plugin<void>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = '';\n          // find viewbox\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (\n            node.attributes.height != null &&\n            node.attributes.width != null\n          ) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          }\n\n          // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n          viewBox = viewBox\n            .replace(/[,+]|px/g, ' ')\n            .replace(/\\s+/g, ' ')\n            .replace(/^\\s*|\\s*$/g, '');\n          // ensure that the dimensions are 4 values separated by space\n          const m =\n            /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(\n              viewBox\n            );\n          if (m == null) {\n            return;\n          }\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]);\n\n          // store the viewBox boundaries\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height,\n          };\n        }\n\n        // consider that any item with a transform attribute is visible\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (\n          node.name === 'path' &&\n          node.attributes.d != null &&\n          viewBoxData != null\n        ) {\n          const pathData = parsePathData(node.attributes.d);\n\n          // consider that a M command within the viewBox is visible\n          let visible = false;\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n              if (\n                x >= viewBoxData.left &&\n                x <= viewBoxData.right &&\n                y >= viewBoxData.top &&\n                y <= viewBoxData.bottom\n              ) {\n                visible = true;\n              }\n            }\n          }\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({ command: 'z', args: [] });\n          }\n\n          const { left, top, width, height } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const viewBoxPathData = [\n            { command: 'M', args: [left, top] },\n            { command: 'h', args: [width] },\n            { command: 'v', args: [height] },\n            { command: 'H', args: [left] },\n            { command: 'z', args: [] },\n          ];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"]},"metadata":{},"sourceType":"script"}