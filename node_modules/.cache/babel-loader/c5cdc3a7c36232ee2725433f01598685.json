{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: \"must NOT have additional properties\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      opts\n    } = it;\n    it.props = true;\n    if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema)) return;\n    const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n    const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n    checkAdditionalProperties();\n    cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n\n    function checkAdditionalProperties() {\n      gen.forIn(\"key\", data, key => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen.if(isAdditional(key), () => additionalPropertyCode(key));\n      });\n    }\n\n    function isAdditional(key) {\n      let definedProp;\n\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n      } else if (props.length) {\n        definedProp = (0, codegen_1.or)(...props.map(p => (0, codegen_1._)`${key} === ${p}`));\n      } else {\n        definedProp = codegen_1.nil;\n      }\n\n      if (patProps.length) {\n        definedProp = (0, codegen_1.or)(definedProp, ...patProps.map(p => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n      }\n\n      return (0, codegen_1.not)(definedProp);\n    }\n\n    function deleteAdditional(key) {\n      gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n    }\n\n    function additionalPropertyCode(key) {\n      if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n        deleteAdditional(key);\n        return;\n      }\n\n      if (schema === false) {\n        cxt.setParams({\n          additionalProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n\n      if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.name(\"valid\");\n\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.reset();\n            deleteAdditional(key);\n          });\n        } else {\n          applyAdditionalSchema(key, valid);\n          if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key, valid, errors) {\n      const subschema = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: util_1.Type.Str\n      };\n\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        });\n      }\n\n      cxt.subschema(subschema, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","additionalProperty","def","keyword","type","schemaType","allowUndefined","trackErrors","code","cxt","gen","schema","parentSchema","data","errsCount","it","Error","allErrors","opts","props","removeAdditional","properties","patProps","patternProperties","checkAdditionalProperties","ok","names_1","errors","forIn","key","length","additionalPropertyCode","if","isAdditional","definedProp","propsSchema","map","p","codegen_1","deleteAdditional","setParams","break","valid","name","applyAdditionalSchema","reset","subschema","dataProp","dataPropType","util_1","Str","Object","assign","compositeRule","createErrors","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}