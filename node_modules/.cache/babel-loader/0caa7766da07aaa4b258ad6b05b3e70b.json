{"ast":null,"code":"'use strict';\n\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1\n};\n/**\n * @param {number} value\n * @param {number | false} prec\n */\n\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n\n  return value;\n}\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\n\n\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression':\n      {\n        const {\n          left,\n          right,\n          operator: op\n        } = node;\n        let str = '';\n\n        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n          str += `(${stringify(left, prec)})`;\n        } else {\n          str += stringify(left, prec);\n        }\n\n        str += order[op] ? ` ${node.operator} ` : node.operator;\n\n        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {\n          str += `(${stringify(right, prec)})`;\n        } else {\n          str += stringify(right, prec);\n        }\n\n        return str;\n      }\n\n    case 'Number':\n      return round(node.value, prec).toString();\n\n    case 'Function':\n      return node.value.toString();\n\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\n\n\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n  const shouldPrintCalc = node.type === 'MathExpression' || node.type === 'Function';\n\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item\n      });\n    }\n  }\n\n  return str;\n};","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-calc/src/lib/stringifier.js"],"names":["order","round","value","prec","precision","Math","pow","stringify","node","type","left","right","operator","op","str","toString","content","unit","module","exports","calc","originalValue","options","result","item","shouldPrintCalc","warnWhenCannotResolve","warn","plugin"],"mappings":"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","sourcesContent":["'use strict';\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1,\n};\n\n/**\n * @param {number} value\n * @param {number | false} prec\n */\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n  return value;\n}\n\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression': {\n      const { left, right, operator: op } = node;\n      let str = '';\n      if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n        str += `(${stringify(left, prec)})`;\n      } else {\n        str += stringify(left, prec);\n      }\n\n      str += order[op] ? ` ${node.operator} ` : node.operator;\n\n      if (\n        right.type === 'MathExpression' &&\n        order[op] < order[right.operator]\n      ) {\n        str += `(${stringify(right, prec)})`;\n      } else {\n        str += stringify(right, prec);\n      }\n\n      return str;\n    }\n    case 'Number':\n      return round(node.value, prec).toString();\n    case 'Function':\n      return node.value.toString();\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n\n  const shouldPrintCalc =\n    node.type === 'MathExpression' || node.type === 'Function';\n\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`;\n\n    // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item,\n      });\n    }\n  }\n  return str;\n};\n"]},"metadata":{},"sourceType":"script"}