{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst equal = require(\"fast-deep-equal\");\n\nconst SCALAR_TYPES = [\"number\", \"integer\", \"string\", \"boolean\", \"null\"];\n\nfunction getDef() {\n  return {\n    keyword: \"uniqueItemProperties\",\n    type: \"array\",\n    schemaType: \"array\",\n\n    compile(keys, parentSchema) {\n      const scalar = getScalarKeys(keys, parentSchema);\n      return data => {\n        if (data.length <= 1) return true;\n\n        for (let k = 0; k < keys.length; k++) {\n          const key = keys[k];\n\n          if (scalar[k]) {\n            const hash = {};\n\n            for (const x of data) {\n              if (!x || typeof x != \"object\") continue;\n              let p = x[key];\n              if (p && typeof p == \"object\") continue;\n              if (typeof p == \"string\") p = '\"' + p;\n              if (hash[p]) return false;\n              hash[p] = true;\n            }\n          } else {\n            for (let i = data.length; i--;) {\n              const x = data[i];\n              if (!x || typeof x != \"object\") continue;\n\n              for (let j = i; j--;) {\n                const y = data[j];\n                if (y && typeof y == \"object\" && equal(x[key], y[key])) return false;\n              }\n            }\n          }\n        }\n\n        return true;\n      };\n    },\n\n    metaSchema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }\n  };\n}\n\nexports.default = getDef;\n\nfunction getScalarKeys(keys, schema) {\n  return keys.map(key => {\n    var _a, _b, _c;\n\n    const t = (_c = (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b[key]) === null || _c === void 0 ? void 0 : _c.type;\n    return Array.isArray(t) ? !t.includes(\"object\") && !t.includes(\"array\") : SCALAR_TYPES.includes(t);\n  });\n}\n\nmodule.exports = getDef;","map":{"version":3,"mappings":";;;;;;AACA;;AAEA,MAAMA,YAAY,GAAG,CAAC,QAAD,EAAW,SAAX,EAAsB,QAAtB,EAAgC,SAAhC,EAA2C,MAA3C,CAArB;;AAEA,SAAwBC,MAAxB,GAA8B;AAC5B,SAAO;AACLC,WAAO,EAAE,sBADJ;AAELC,QAAI,EAAE,OAFD;AAGLC,cAAU,EAAE,OAHP;;AAILC,WAAO,CAACC,IAAD,EAAiBC,YAAjB,EAA8C;AACnD,YAAMC,MAAM,GAAGC,aAAa,CAACH,IAAD,EAAOC,YAAP,CAA5B;AAEA,aAAQG,IAAD,IAAS;AACd,YAAIA,IAAI,CAACC,MAAL,IAAe,CAAnB,EAAsB,OAAO,IAAP;;AACtB,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACK,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACpC,gBAAMC,GAAG,GAAGP,IAAI,CAACM,CAAD,CAAhB;;AACA,cAAIJ,MAAM,CAACI,CAAD,CAAV,EAAe;AACb,kBAAME,IAAI,GAAwB,EAAlC;;AACA,iBAAK,MAAMC,CAAX,IAAgBL,IAAhB,EAAsB;AACpB,kBAAI,CAACK,CAAD,IAAM,OAAOA,CAAP,IAAY,QAAtB,EAAgC;AAChC,kBAAIC,CAAC,GAAGD,CAAC,CAACF,GAAD,CAAT;AACA,kBAAIG,CAAC,IAAI,OAAOA,CAAP,IAAY,QAArB,EAA+B;AAC/B,kBAAI,OAAOA,CAAP,IAAY,QAAhB,EAA0BA,CAAC,GAAG,MAAMA,CAAV;AAC1B,kBAAIF,IAAI,CAACE,CAAD,CAAR,EAAa,OAAO,KAAP;AACbF,kBAAI,CAACE,CAAD,CAAJ,GAAU,IAAV;AACD;AACF,WAVD,MAUO;AACL,iBAAK,IAAIC,CAAC,GAAGP,IAAI,CAACC,MAAlB,EAA0BM,CAAC,EAA3B,GAAiC;AAC/B,oBAAMF,CAAC,GAAGL,IAAI,CAACO,CAAD,CAAd;AACA,kBAAI,CAACF,CAAD,IAAM,OAAOA,CAAP,IAAY,QAAtB,EAAgC;;AAChC,mBAAK,IAAIG,CAAC,GAAGD,CAAb,EAAgBC,CAAC,EAAjB,GAAuB;AACrB,sBAAMC,CAAC,GAAGT,IAAI,CAACQ,CAAD,CAAd;AACA,oBAAIC,CAAC,IAAI,OAAOA,CAAP,IAAY,QAAjB,IAA6BC,KAAK,CAACL,CAAC,CAACF,GAAD,CAAF,EAASM,CAAC,CAACN,GAAD,CAAV,CAAtC,EAAwD,OAAO,KAAP;AACzD;AACF;AACF;AACF;;AACD,eAAO,IAAP;AACD,OA1BD;AA2BD,KAlCI;;AAmCLQ,cAAU,EAAE;AACVlB,UAAI,EAAE,OADI;AAEVmB,WAAK,EAAE;AAACnB,YAAI,EAAE;AAAP;AAFG;AAnCP,GAAP;AAwCD;;AAzCDoB;;AA2CA,SAASd,aAAT,CAAuBH,IAAvB,EAAuCkB,MAAvC,EAA8D;AAC5D,SAAOlB,IAAI,CAACmB,GAAL,CAAUZ,GAAD,IAAQ;;;AACtB,UAAMa,CAAC,GAAG,wBAAM,CAACJ,KAAP,MAAY,IAAZ,IAAYK,aAAZ,GAAY,MAAZ,GAAYA,GAAEC,UAAd,MAAwB,IAAxB,IAAwBC,aAAxB,GAAwB,MAAxB,GAAwBA,GAAGhB,GAAH,CAAxB,MAA+B,IAA/B,IAA+BiB,aAA/B,GAA+B,MAA/B,GAA+BA,GAAE3B,IAA3C;AACA,WAAO4B,KAAK,CAACC,OAAN,CAAcN,CAAd,IACH,CAACA,CAAC,CAACO,QAAF,CAAW,QAAX,CAAD,IAAyB,CAACP,CAAC,CAACO,QAAF,CAAW,OAAX,CADvB,GAEHjC,YAAY,CAACiC,QAAb,CAAsBP,CAAtB,CAFJ;AAGD,GALM,CAAP;AAMD;;AAEDQ,MAAM,CAACX,OAAP,GAAiBtB,MAAjB","names":["SCALAR_TYPES","getDef","keyword","type","schemaType","compile","keys","parentSchema","scalar","getScalarKeys","data","length","k","key","hash","x","p","i","j","y","equal","metaSchema","items","exports","schema","map","t","_a","properties","_b","_c","Array","isArray","includes","module"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv-keywords/src/definitions/uniqueItemProperties.ts"],"sourcesContent":["import type {FuncKeywordDefinition, AnySchemaObject} from \"ajv\"\nimport equal = require(\"fast-deep-equal\")\n\nconst SCALAR_TYPES = [\"number\", \"integer\", \"string\", \"boolean\", \"null\"]\n\nexport default function getDef(): FuncKeywordDefinition {\n  return {\n    keyword: \"uniqueItemProperties\",\n    type: \"array\",\n    schemaType: \"array\",\n    compile(keys: string[], parentSchema: AnySchemaObject) {\n      const scalar = getScalarKeys(keys, parentSchema)\n\n      return (data) => {\n        if (data.length <= 1) return true\n        for (let k = 0; k < keys.length; k++) {\n          const key = keys[k]\n          if (scalar[k]) {\n            const hash: Record<string, any> = {}\n            for (const x of data) {\n              if (!x || typeof x != \"object\") continue\n              let p = x[key]\n              if (p && typeof p == \"object\") continue\n              if (typeof p == \"string\") p = '\"' + p\n              if (hash[p]) return false\n              hash[p] = true\n            }\n          } else {\n            for (let i = data.length; i--; ) {\n              const x = data[i]\n              if (!x || typeof x != \"object\") continue\n              for (let j = i; j--; ) {\n                const y = data[j]\n                if (y && typeof y == \"object\" && equal(x[key], y[key])) return false\n              }\n            }\n          }\n        }\n        return true\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\"},\n    },\n  }\n}\n\nfunction getScalarKeys(keys: string[], schema: AnySchemaObject): boolean[] {\n  return keys.map((key) => {\n    const t = schema.items?.properties?.[key]?.type\n    return Array.isArray(t)\n      ? !t.includes(\"object\") && !t.includes(\"array\")\n      : SCALAR_TYPES.includes(t)\n  })\n}\n\nmodule.exports = getDef\n"]},"metadata":{},"sourceType":"script"}