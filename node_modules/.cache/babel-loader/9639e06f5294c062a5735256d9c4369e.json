{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n\nconst getValue = node => parseFloat(node.value);\n/* Works because toString() normalizes the formatting,\n   so comparing the string forms behaves the same as number equality*/\n\n\nconst conversions = new Map([[[0.25, 0.1, 0.25, 1].toString(), 'ease'], [[0, 0, 1, 1].toString(), 'linear'], [[0.42, 0, 1, 1].toString(), 'ease-in'], [[0, 0, 0.58, 1].toString(), 'ease-out'], [[0.42, 0, 0.58, 1].toString(), 'ease-in-out']]);\n\nfunction reduce(node) {\n  if (node.type !== 'function') {\n    return false;\n  }\n\n  if (!node.value) {\n    return;\n  }\n\n  const lowerCasedValue = node.value.toLowerCase();\n\n  if (lowerCasedValue === 'steps') {\n    // Don't bother checking the step-end case as it has the same length\n    // as steps(1)\n    if (node.nodes[0].type === 'word' && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'start' || node.nodes[2].value.toLowerCase() === 'jump-start')) {\n      node.type = 'word';\n      node.value = 'step-start';\n      delete node.nodes;\n      return;\n    }\n\n    if (node.nodes[0].type === 'word' && getValue(node.nodes[0]) === 1 && node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'end' || node.nodes[2].value.toLowerCase() === 'jump-end')) {\n      node.type = 'word';\n      node.value = 'step-end';\n      delete node.nodes;\n      return;\n    } // The end case is actually the browser default, so it isn't required.\n\n\n    if (node.nodes[2] && node.nodes[2].type === 'word' && (node.nodes[2].value.toLowerCase() === 'end' || node.nodes[2].value.toLowerCase() === 'jump-end')) {\n      node.nodes = [node.nodes[0]];\n      return;\n    }\n\n    return false;\n  }\n\n  if (lowerCasedValue === 'cubic-bezier') {\n    const values = node.nodes.filter((list, index) => {\n      return index % 2 === 0;\n    }).map(getValue);\n\n    if (values.length !== 4) {\n      return;\n    }\n\n    const match = conversions.get(values.toString());\n\n    if (match) {\n      node.type = 'word';\n      node.value = match;\n      delete node.nodes;\n      return;\n    }\n  }\n}\n\nfunction transform(value) {\n  return valueParser(value).walk(reduce).toString();\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-normalize-timing-functions',\n\n    OnceExit(css) {\n      const cache = new Map();\n      css.walkDecls(/^(-\\w+-)?(animation|transition)(-timing-function)?$/i, decl => {\n        const value = decl.value;\n\n        if (cache.has(value)) {\n          decl.value = cache.get(value);\n          return;\n        }\n\n        const result = transform(value);\n        decl.value = result;\n        cache.set(value, result);\n      });\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/postcss-normalize-timing-functions/src/index.js"],"names":["valueParser","require","getValue","node","parseFloat","value","conversions","Map","toString","reduce","type","lowerCasedValue","toLowerCase","nodes","values","filter","list","index","map","length","match","get","transform","walk","pluginCreator","postcssPlugin","OnceExit","css","cache","walkDecls","decl","has","result","set","postcss","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\n\nconst getValue = (node) => parseFloat(node.value);\n\n/* Works because toString() normalizes the formatting,\n   so comparing the string forms behaves the same as number equality*/\nconst conversions = new Map([\n  [[0.25, 0.1, 0.25, 1].toString(), 'ease'],\n  [[0, 0, 1, 1].toString(), 'linear'],\n  [[0.42, 0, 1, 1].toString(), 'ease-in'],\n  [[0, 0, 0.58, 1].toString(), 'ease-out'],\n  [[0.42, 0, 0.58, 1].toString(), 'ease-in-out'],\n]);\nfunction reduce(node) {\n  if (node.type !== 'function') {\n    return false;\n  }\n\n  if (!node.value) {\n    return;\n  }\n\n  const lowerCasedValue = node.value.toLowerCase();\n\n  if (lowerCasedValue === 'steps') {\n    // Don't bother checking the step-end case as it has the same length\n    // as steps(1)\n    if (\n      node.nodes[0].type === 'word' &&\n      getValue(node.nodes[0]) === 1 &&\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'start' ||\n        node.nodes[2].value.toLowerCase() === 'jump-start')\n    ) {\n      node.type = 'word';\n      node.value = 'step-start';\n\n      delete node.nodes;\n\n      return;\n    }\n\n    if (\n      node.nodes[0].type === 'word' &&\n      getValue(node.nodes[0]) === 1 &&\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'end' ||\n        node.nodes[2].value.toLowerCase() === 'jump-end')\n    ) {\n      node.type = 'word';\n      node.value = 'step-end';\n\n      delete node.nodes;\n\n      return;\n    }\n\n    // The end case is actually the browser default, so it isn't required.\n    if (\n      node.nodes[2] &&\n      node.nodes[2].type === 'word' &&\n      (node.nodes[2].value.toLowerCase() === 'end' ||\n        node.nodes[2].value.toLowerCase() === 'jump-end')\n    ) {\n      node.nodes = [node.nodes[0]];\n\n      return;\n    }\n\n    return false;\n  }\n\n  if (lowerCasedValue === 'cubic-bezier') {\n    const values = node.nodes\n      .filter((list, index) => {\n        return index % 2 === 0;\n      })\n      .map(getValue);\n\n    if (values.length !== 4) {\n      return;\n    }\n\n    const match = conversions.get(values.toString());\n\n    if (match) {\n      node.type = 'word';\n      node.value = match;\n\n      delete node.nodes;\n\n      return;\n    }\n  }\n}\n\nfunction transform(value) {\n  return valueParser(value).walk(reduce).toString();\n}\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-normalize-timing-functions',\n\n    OnceExit(css) {\n      const cache = new Map();\n\n      css.walkDecls(\n        /^(-\\w+-)?(animation|transition)(-timing-function)?$/i,\n        (decl) => {\n          const value = decl.value;\n\n          if (cache.has(value)) {\n            decl.value = cache.get(value);\n\n            return;\n          }\n\n          const result = transform(value);\n\n          decl.value = result;\n          cache.set(value, result);\n        }\n      );\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"]},"metadata":{},"sourceType":"script"}