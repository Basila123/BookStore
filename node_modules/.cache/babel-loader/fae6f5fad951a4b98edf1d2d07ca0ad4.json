{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateAdditionalItems = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        len\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must NOT have more than ${len} items`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        len\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{limit: ${len}}`;\n  }\n};\nconst def = {\n  keyword: \"additionalItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n\n  code(cxt) {\n    const {\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      items\n    } = parentSchema;\n\n    if (!Array.isArray(items)) {\n      (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n      return;\n    }\n\n    validateAdditionalItems(cxt, items);\n  }\n\n};\n\nfunction validateAdditionalItems(cxt, items) {\n  const {\n    gen,\n    schema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  it.items = true;\n  const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n\n  if (schema === false) {\n    cxt.setParams({\n      len: items.length\n    });\n    cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);\n  } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n    const valid = gen.var(\"valid\", (0, codegen_1._)`${len} <= ${items.length}`); // TODO var\n\n    gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n    cxt.ok(valid);\n  }\n\n  function validateItems(valid) {\n    gen.forRange(\"i\", items.length, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      if (!it.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n    });\n  }\n}\n\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;","map":{"version":3,"mappings":";;;;;;;AAOA;;AACA;;AAIA,MAAMA,KAAK,GAA2B;AACpCC,SAAO,EAAE;AAAA,QAAC;AAACC,YAAM,EAAE;AAACC;AAAD;AAAT,KAAD;AAAA,WAAqB,kBAAG,2BAA2BA,GAAG,QAAtD;AAAA,GAD2B;AAEpCD,QAAM,EAAE;AAAA,QAAC;AAACA,YAAM,EAAE;AAACC;AAAD;AAAT,KAAD;AAAA,WAAqB,gBAAC,WAAWA,GAAG,GAApC;AAAA;AAF4B,CAAtC;AAKA,MAAMC,GAAG,GAA0B;AACjCC,SAAO,EAAE,iBADwB;AAEjCC,MAAI,EAAE,OAF2B;AAGjCC,YAAU,EAAE,CAAC,SAAD,EAAY,QAAZ,CAHqB;AAIjCC,QAAM,EAAE,aAJyB;AAKjCR,OALiC;;AAMjCS,MAAI,CAACC,GAAD,EAAgB;AAClB,UAAM;AAACC,kBAAD;AAAeC;AAAf,QAAqBF,GAA3B;AACA,UAAM;AAACG;AAAD,QAAUF,YAAhB;;AACA,QAAI,CAACG,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAL,EAA2B;AACzB,kCAAgBD,EAAhB,EAAoB,sEAApB;AACA;AACD;;AACDI,2BAAuB,CAACN,GAAD,EAAMG,KAAN,CAAvB;AACD;;AAdgC,CAAnC;;AAiBA,SAAgBG,uBAAhB,CAAwCN,GAAxC,EAAyDG,KAAzD,EAA2E;AACzE,QAAM;AAACI,OAAD;AAAMC,UAAN;AAAcC,QAAd;AAAoBd,WAApB;AAA6BO;AAA7B,MAAmCF,GAAzC;AACAE,IAAE,CAACC,KAAH,GAAW,IAAX;AACA,QAAMV,GAAG,GAAGc,GAAG,CAACG,KAAJ,CAAU,KAAV,EAAiB,gBAAC,GAAGD,IAAI,SAAzB,CAAZ;;AACA,MAAID,MAAM,KAAK,KAAf,EAAsB;AACpBR,OAAG,CAACW,SAAJ,CAAc;AAAClB,SAAG,EAAEU,KAAK,CAACS;AAAZ,KAAd;AACAZ,OAAG,CAACa,IAAJ,CAAS,gBAAC,GAAGpB,GAAG,OAAOU,KAAK,CAACS,MAAM,EAAnC;AACD,GAHD,MAGO,IAAI,OAAOJ,MAAP,IAAiB,QAAjB,IAA6B,CAAC,8BAAkBN,EAAlB,EAAsBM,MAAtB,CAAlC,EAAiE;AACtE,UAAMM,KAAK,GAAGP,GAAG,CAACQ,GAAJ,CAAQ,OAAR,EAAiB,gBAAC,GAAGtB,GAAG,OAAOU,KAAK,CAACS,MAAM,EAA3C,CAAd,CADsE,CACT;;AAC7DL,OAAG,CAACS,EAAJ,CAAO,mBAAIF,KAAJ,CAAP,EAAmB,MAAMG,aAAa,CAACH,KAAD,CAAtC;AACAd,OAAG,CAACkB,EAAJ,CAAOJ,KAAP;AACD;;AAED,WAASG,aAAT,CAAuBH,KAAvB,EAAkC;AAChCP,OAAG,CAACY,QAAJ,CAAa,GAAb,EAAkBhB,KAAK,CAACS,MAAxB,EAAgCnB,GAAhC,EAAsC2B,CAAD,IAAM;AACzCpB,SAAG,CAACqB,SAAJ,CAAc;AAAC1B,eAAD;AAAU2B,gBAAQ,EAAEF,CAApB;AAAuBG,oBAAY,EAAEC,YAAKC;AAA1C,OAAd,EAA8DX,KAA9D;AACA,UAAI,CAACZ,EAAE,CAACwB,SAAR,EAAmBnB,GAAG,CAACS,EAAJ,CAAO,mBAAIF,KAAJ,CAAP,EAAmB,MAAMP,GAAG,CAACoB,KAAJ,EAAzB;AACpB,KAHD;AAID;AACF;;AAnBDC;AAqBAA,kBAAelC,GAAf","names":["error","message","params","len","def","keyword","type","schemaType","before","code","cxt","parentSchema","it","items","Array","isArray","validateAdditionalItems","gen","schema","data","const","setParams","length","pass","valid","var","if","validateItems","ok","forRange","i","subschema","dataProp","dataPropType","util_1","Num","allErrors","break","exports"],"sources":["/home/hp/Js/React_practise/BookStore/books/node_modules/css-minimizer-webpack-plugin/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}